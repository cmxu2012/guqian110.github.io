<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Qian's World</title><link href="http://guqian110.github.io/" rel="alternate"></link><link href="http://guqian110.github.io/feeds/all.atom.xml" rel="self"></link><id>http://guqian110.github.io/</id><updated>2015-03-16T00:00:00+08:00</updated><entry><title>相关系数及Matlab函数</title><link href="http://guqian110.github.io/pages/2015/03/16/correlation_coefficient_and_matlab_function.html" rel="alternate"></link><updated>2015-03-16T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-03-16:pages/2015/03/16/correlation_coefficient_and_matlab_function.html</id><summary type="html">&lt;h2&gt;Correlation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;首先总结一下基础背景知识：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Correlation_and_dependence"&gt;相关 &lt;code&gt;Correlation&lt;/code&gt;&lt;/a&gt; 是概率论与统计学中用来刻画两个随机变量之间统计关系的强弱和方向的量。在广义的定义下，有很多种类的相关系数（&lt;code&gt;correlation coefficient&lt;/code&gt;），它们通常用字母 &lt;code&gt;ρ&lt;/code&gt; 或者 &lt;code&gt;r&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;p&gt;我们通常说的相关系数的学名是：&lt;a href="http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient"&gt;皮尔逊积差系数（Pearson's product moment coefficient）&lt;/a&gt;，这种相关系数只对两个变量的线性关系敏感。&lt;/p&gt;
&lt;h3&gt;Pearson's product moment coefficient&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在统计学中，基于总体的定义如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Pearson 相关系数使用两个变量的协方差（&lt;code&gt;covariance&lt;/code&gt;）和标准差（&lt;code&gt;standard deviations&lt;/code&gt;）来定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq1" src="http://upload.wikimedia.org/math/5/c/f/5cfbb6f9088ef5fbc8a84f59da872984.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中，cov 是协方差，sigma 是标准差。因为 cov 可以写作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq2" src="http://upload.wikimedia.org/math/8/8/a/88a377faf813d502d6ab1f8193481223.png" /&gt;&lt;/p&gt;
&lt;p&gt;所以 Person 相关系数的定义式可以写作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq3" src="http://upload.wikimedia.org/math/e/2/6/e26e29b58777e55d79883c77edca4428.png" /&gt;&lt;/p&gt;
&lt;p&gt;根据概率论知识可以得到如下的变形形式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq4" src="http://upload.wikimedia.org/math/0/9/d/09d413641c8ba8f54b6113e5857c69f8.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于样本来估计协方差和标准差，可以得到定义如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq5" src="http://upload.wikimedia.org/math/e/3/c/e3c7ff025788887bba2f3dfca7df94b9.png" /&gt;&lt;/p&gt;
&lt;p&gt;通过变形，可以得到下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq6" src="http://upload.wikimedia.org/math/8/0/5/8059a4dddb8b6c2c5e1eeefcb9630d93.png" /&gt;&lt;/p&gt;
&lt;h3&gt;Properties&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E7%9B%B8%E5%85%B3"&gt;wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当两个变量的标准差都不为零，相关系数才有定义。从柯西-施瓦茨不等式可知，相关系数的绝对值不超过1。当两个变量的线性关系增强时，相关系数趋于1或-1。当一个变量增加而另一变量也增加时，相关系数大于0。当一个变量的增加而另一变量减少时，相关系数小于0。当两个变量独立时，相关系数为0.但反之并不成立。这是因为相关系数仅仅反映了两个变量之间是否线性相关。比如说，X是区间［－1，1］上的一个均匀分布的随机变量。Y = X2.那么Y是完全由X确定。因此Y和X是不独立的。但是相关系数为0。或者说他们是不相关的。当Y和X服从联合正态分布时，其相互独立和不相关是等价的。&lt;/p&gt;
&lt;p&gt;当一个或两个变量带有测量误差时，他们的相关性就受到削弱，这时，“反衰减”性（disattenuation）是一个更准确的系数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_6ce23c390101c6zc.html"&gt;【总结】matlab求两个序列的相关性&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相关系数只是一个比率，不是等单位量度，无什么单位名称，也不是相关的百分数，一般取小数点后两位来表示。相关系数的正负号只表示相关的方向，绝对值表示相关的程度。因为不是等单位的度量，因而不能说相关系数0.7是0.35两倍，只能说相关系数为0.7的二列变量相关程度比相关系数为0.35的二列变量相关程度更为密切和更高。也不能说相关系数从0.70到0.80与相关系数从0.30到0.40增加的程度一样大。&lt;/p&gt;
&lt;p&gt;对于相关系数的大小所表示的意义目前在统计学界尚不一致，但通常按下是这样认为的：&lt;/p&gt;
&lt;p&gt;相关系数      相关程度&lt;/p&gt;
&lt;p&gt;0.00-±0.30    微相关&lt;/p&gt;
&lt;p&gt;±0.30-±0.50   实相关&lt;/p&gt;
&lt;p&gt;±0.50-±0.80   显著相关&lt;/p&gt;
&lt;p&gt;±0.80-±1.00   高度相关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复习了基础知识，另外还有两个概念：&lt;/p&gt;
&lt;h3&gt;Cross-correlation&lt;/h3&gt;
&lt;p&gt;对于连续函数，有下面的定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq7" src="http://upload.wikimedia.org/math/3/a/a/3aa0f20ebd9e984d8a17642c11d43de2.png" /&gt;&lt;/p&gt;
&lt;p&gt;对于离散函数，有下面的定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq8" src="http://upload.wikimedia.org/math/d/f/6/df665b17d676571c9dc7a1800e1b186a.png" /&gt;&lt;/p&gt;
&lt;p&gt;在信号处理中，用 互相关 &lt;a href="http://en.wikipedia.org/wiki/Cross-correlation"&gt;Cross-correlation&lt;/a&gt; 来&lt;strong&gt;衡量两个序列之间的相似程度&lt;/strong&gt;，通常可以用于在长序列中寻找一个特定的短序列（也就是通信系统的同步中）。&lt;/p&gt;
&lt;p&gt;在数理统计中，互相关用来两个随机序列的相关性。&lt;/p&gt;
&lt;p&gt;从定义式中可以看到，互相关函数和卷积运算类似，也是两个序列滑动相乘，但是区别在于：&lt;/p&gt;
&lt;p&gt;互相关的两个序列都不翻转，直接滑动相乘，求和；卷积的其中一个序列需要先翻转，然后滑动相乘，求和。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;f(t) 和 g(t) 做相关 = f*(-t) 与 g(t) 做卷积&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Autocorrelation&lt;/h3&gt;
&lt;p&gt;自相关 &lt;a href="http://en.wikipedia.org/wiki/Autocorrelation"&gt;Autocorrelation&lt;/a&gt; 是互相关的一种特殊情况，就是一个序列和它本身做相关，而不是两个序列，它&lt;strong&gt;主要用来衡量一个序列在不同时刻取值的相似程度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在数理统计中，自相关的定义式如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq9" src="http://upload.wikimedia.org/math/3/7/c/37c9812eaf2deca258f5526ac9067aa2.png" /&gt;&lt;/p&gt;
&lt;p&gt;如果随机过程是一个宽平稳过程，那么均值和方差都不是时间的函数，所以，自相关定义式变为：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq10" src="http://upload.wikimedia.org/math/1/c/c/1cc9b1b80ab17d64568bca15bc7a5a9d.png" /&gt;&lt;/p&gt;
&lt;p&gt;在某些学科中，会去掉归一化因子 σ2，使用 自协方差 来代替 自相关。但是归一化因子可以让自相关的取值在 [-1, +1] 之间，不会随着序列的绝对大小而变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在信号处理中，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自相关的定义会去掉归一化，即不用减去均值，也不用除以方差。当除以方差时，一般叫做另外一个名字：自相关系数 &lt;code&gt;autocorrelation coefficient&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于连续函数，自相关的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq11" src="http://upload.wikimedia.org/math/9/8/c/98cd888f0d13972a937f5d37d9f24623.png" /&gt;&lt;/p&gt;
&lt;p&gt;对于离散函数，自相关的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq12" src="http://upload.wikimedia.org/math/4/c/2/4c23ef05df69ee440a2bda5a0b1d83bc.png" /&gt;&lt;/p&gt;
&lt;p&gt;自相关有很多性质，比如对称性、&lt;a href="http://en.wikipedia.org/wiki/Wiener%E2%80%93Khinchin_theorem"&gt;维纳-辛钦定理（Wiener–Khinchin theorem）&lt;/a&gt; 等，就不再重复了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Matlab function&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;xcorr&lt;/h3&gt;
&lt;p&gt;在 Matlab 中，计算自相关和互相关，可以使用同一个函数：&lt;code&gt;xcorr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;自相关：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;互相关：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为两个长度为 N 的序列进行相关，可以知道最多有 2N - 1 个非 0 的移位相乘结果，所以 xcorr 的返回结果就是长度为 2N - 1 的向量。（如果其中一个序列的长度小于 N，则会先补零再计算相关）&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;help xcorr&lt;/code&gt; 来查看详细的函数说明。&lt;/p&gt;
&lt;p&gt;下面举个使用例子：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c"&gt;%correlation&lt;/span&gt;
&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;c3&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;对于序列 x = [1, 2, 3]，移位相乘、求和，可以得到结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于序列 y 类似。&lt;/p&gt;
&lt;p&gt;对于 x、y 的互相关，当两个序列对齐的时候，相关性最高（归一化后为 1，意味着两个序列线性相关）&lt;/p&gt;
&lt;p&gt;xcorr 默认的返回结果是没有经过归一化的，而通常的应用中都要求归一化以得到精确的估计。解决这一问题的方法就是使用 xcorr 函数提供的 &lt;code&gt;option&lt;/code&gt; 选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;'biased' 有偏估计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'unbiased' 无偏估计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'coeff' 归一化，返回到最大值（对齐时）为理想的 1.0（= xcorr(x)./max(xcorr(x)) ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'none' 未经归一化的原始数据，默认的返回结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;corrcoef&lt;/h3&gt;
&lt;p&gt;可以用 &lt;code&gt;corrcoef&lt;/code&gt; 函数来求两个序列的相关系数，函数的返回值为一个 2×2 的矩阵，对角线上的值为两个序列的自相关系数，非对角线上的值为两个序列的互相关系数。&lt;/p&gt;
&lt;p&gt;在上面的例子中加入下面两句：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;c4&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;corrcoef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;返回结果为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为 z 是 x 的线性函数，且系数为 -1，所以非对角线上的值为 -1。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Correlation_and_dependence"&gt;correlation wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient"&gt;pearson wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cross-correlation"&gt;Cross-correlation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Autocorrelation"&gt;Autocorrelation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_6ce23c390101c6zc.html"&gt;【总结】matlab求两个序列的相关性&lt;/a&gt;&lt;/p&gt;</summary><category term="correlation coefficient"></category><category term="matlab"></category></entry><entry><title>关于冒险和毛刺</title><link href="http://guqian110.github.io/pages/2015/03/13/summary_of_hazard_and_glitch.html" rel="alternate"></link><updated>2015-03-13T21:44:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-03-13:pages/2015/03/13/summary_of_hazard_and_glitch.html</id><summary type="html">&lt;h2&gt;Hazards &amp;amp; Glitch&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;所谓 “冒险” &lt;code&gt;Hazard&lt;/code&gt;，是指一种数字电路中由于设计或者是外部因素，造成的数字信号错误的现象，而这个错误的信号就叫做毛刺 &lt;code&gt;Glitch&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Hazard_(logic)"&gt;Hazard on wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In digital logic, a hazard in a system is an undesirable effect caused by either a deficiency in the system or external influences. Logic hazards are manifestations of a problem in which changes in the input variables do not change the output correctly due to some form of delay caused by logic elements (NOT, AND, OR gates, etc.) This results in the logic not performing its function properly. The three different most common kinds of hazards are usually referred to as static, dynamic and function hazards.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据导致冒险的原因，一般将冒险分类如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态冒险 &lt;code&gt;Static hazards&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;静态冒险，是指输入信号发生变化前后，输出信号保持不变，但是在输入信号变化时，输出信号可能产生瞬间错误输出。&lt;/p&gt;
&lt;p&gt;根据发生的错误的值，可以将静态冒险分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Static-1 Hazard: 输入变化前后，输出应该保持 1，但是在输入变化瞬间输出发生错误，变为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Static-0 Hazard: 输入变化前后，输出应该保持 0，但是在输入变化瞬间输出发生错误，变为 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据导致冒险的原因分类，可以将静态冒险分为以下两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑冒险 &lt;code&gt;logic hazard&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;只有 1 个输入发生变化，导致的静态冒险。&lt;/p&gt;
&lt;p&gt;经分析可知产生逻辑冒险的原因是门的延迟。（参考&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能冒险 &lt;code&gt;function hazard&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2 个或者 2 个以上的输入发生变化，导致的静态冒险。&lt;/p&gt;
&lt;p&gt;经分析可知产生功能冒险的原因是两个或两个以上的输入不可能同时发生变化，它们的变化总有先有后。参考&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态冒险 &lt;code&gt;Dynamic hazards&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;动态冒险，是指输入信号变化前后，输入信号发生变化，而且在输入信号发生变化时，输出信号会变化 3 次以上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;首先我们应该尽可能避免存在冒险的设计，这样就不存在解决毛刺的问题。&lt;/p&gt;
&lt;p&gt;比如在数字电路设计中，常常采用格雷码计数器取代普通的二进制计数器，这是因为格雷码计数器的输出每次只有一位跳变，消除了竞争冒险的发生条件，避免了毛刺的产生。&lt;/p&gt;
&lt;p&gt;再比如遵循同步设计原则，即使有毛刺，一般也不会对系统造成危害。（因为同步电路信号的变化都发生在时钟沿，只要毛刺不出现在时钟的沿口并且不满足数据的建立和保持时间，就不会对系统造成危害。一般毛刺很短，多为几纳秒，基本上都不可能满足数据的建立和保持时间）&lt;/p&gt;
&lt;p&gt;设计无冒险的电路，会导致电路变复杂，成本上升。对于简单电路中的冒险，我们可以采用以下的方法来解决。&lt;/p&gt;
&lt;h3&gt;Static hazards&lt;/h3&gt;
&lt;p&gt;首先判断输入信号是否会同时发生变化，可以分为两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只有一个输入变化，对应的就是 logic hazards&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断是否存在冒险（&lt;strong&gt;代数法&lt;/strong&gt; or &lt;strong&gt;卡诺图法&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;代数法比较繁琐，但是适用范围广，对两级以上的电路均适用。注意函数表达式不能化简，否则对应的逻辑电路改变，由电路延迟造成的冒险也随之改变。&lt;/p&gt;
&lt;p&gt;卡诺图法方便直观，但是只适用于两级电路。&lt;/p&gt;
&lt;p&gt;函数表达式中的积项或和项是和卡诺图中的合并圈一一对应的，由此可知，&lt;strong&gt;函数的最简不一定是最佳的，必要的冗余反而可增加电路工作的可靠性。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冒险（&lt;strong&gt;增加冗余项/冗余圈&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;至少有 2 个输入同时变化，对应的就是 function hazards&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断是否存在冒险&lt;/p&gt;
&lt;p&gt;产生功能冒险的充要条件（同时满足以下 3 个条件）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;必须有 P （P &amp;gt;= 2) 个变量同时发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入变量变化前后函数值相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由变化的 P 个变量组合所构成的 2^P 个格，既有 1 又有 0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冒险（&lt;strong&gt;选通脉冲&lt;/strong&gt; or &lt;strong&gt;滤波电路&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;只要输入信号不是按照循环码的方式变化，就会产生功能冒险。功能冒险是函数的逻辑功能决定的，所以不能在设计中消除，需要加额外的选通脉冲。&lt;/p&gt;
&lt;p&gt;选通脉冲的思路：一般说来，冒险出现在信号发生电平转换的时刻，也就是说在输出信号的建立时间内会发生冒险，而在输出信号的保持时间内是不会有毛刺信号出现的。如果在输出信号的保持时间内对其进行"采样"，就可以消除毛刺信号的影响。&lt;/p&gt;
&lt;p&gt;需要注意的是必须对选通脉冲的宽度及产生时间有严格的要求。加上选通脉冲之后，电路的输出就不再是电平信号，而是变为脉冲信号。&lt;/p&gt;
&lt;p&gt;还有另外一种方法：在对输出波形要求不高的时候，可以在输出端接一个滤波电容来消除冒险，但是这种方法会破坏波形的边沿，所以只适用于低速电路。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较 3 种消除冒险的方法：&lt;/p&gt;
&lt;p&gt;增加冗余只能消除 logic hazards，而不能消除 function hazards；&lt;/p&gt;
&lt;p&gt;增加滤波电路虽然简单，但是会破坏波形；&lt;/p&gt;
&lt;p&gt;加选通脉冲的方法则对两种类型的冒险都有效。&lt;/p&gt;
&lt;p&gt;目前很多中规模集成电路（Medium Scale Integrated, MSI）中都设有使能端，其作用之一就是作为选通脉冲的输入端，待电路稳定之后才使输出有效。&lt;/p&gt;
&lt;h3&gt;Dynamic hazards&lt;/h3&gt;
&lt;p&gt;要解决动态冒险，首先就得知道动态冒险产生的原因：&lt;/p&gt;
&lt;p&gt;产生动态冒险的原因是输入可以有多条变化路径到达输出，而这些路径的时延都各不相同，显然这就会导致输出变化多次，比如一个输出应该从 1 变为 0，但是实际中却先从 1 变为 0，然后又从 0 变回 1，最终返回到正确值 0。&lt;/p&gt;
&lt;p&gt;动态的解决相对比较复杂，但是 &lt;strong&gt;只要消除了静态冒险，那么就不会存在动态冒险。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;in FPGA Design&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;本部分来自：&lt;a href="http://www.fpga.com.cn/advance/glitch/giltch.htm"&gt;关于毛刺问题的探讨&lt;/a&gt; 和 &lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;信号在 FPGA 器件内部通过连线和逻辑单元时，都有一定的延时。延时的大小与连线的长短和逻辑单元的数目有关，同时还受器件的制造工艺、工作电压、温度等条件的影响。信号的高低电平转换也需要一定的过渡时间。由于存在这两方面因素，多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化,往往会出现一些不正确的尖峰信号，即毛刺信号。与分立元件不同，由于PLD内部不存在寄生电容电感，这些毛刺将被完整的保留并向下一级传递，因此毛刺现象在PLD、FPGA设计中尤为突出。&lt;/p&gt;
&lt;p&gt;可以概括的讲，&lt;strong&gt;只要输入信号同时变化，（经过内部走线）组合逻辑必将产生毛刺。将它们的输出直接连接到时钟输入端、清零或置位端口的设计方法是错误的，这可能会导致严重的后果。所以我们必须检查设计中所有时钟、清零和置位等对毛刺敏感的输入端口，确保输入不会含有任何毛刺。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如前所述，优秀的设计方案，如采用格雷码计数器，同步电路等，可以大大减少毛刺，但它并不能完全消除毛刺。 毛刺并不是对所有输入都有危害，例如 D 触发器的 D 输入端，只要毛刺不出现在时钟的上升沿并且满足数据的建立和保持时间，就不会对系统造成危害。因此我们可以说 D 触发器的 D 输入端对毛刺不敏感。但对于 D 触发器的时钟端，置位端，清零端，则都是对毛刺敏感的输入端，任何一点毛刺就会使系统出错，但只要认真处理，我们可以把危害降到最低直至消除。下面我们就对几种具体的信号进行探讨。&lt;/p&gt;
&lt;h3&gt;clock&lt;/h3&gt;
&lt;p&gt;时钟信号是系统中非常关键的信号，参见其他&lt;a href="http://guqian110.github.io/tag/clock-design.html"&gt;几篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;set/clear&lt;/h3&gt;
&lt;p&gt;清除和置位信号要求象对待时钟那样小心地考虑它们，因为这些信号对毛刺也是非常敏感的。正如使用时钟那样，最好的清除和置位是从器件的引脚单直接地驱动。有一个主复位Reset引脚是常用的最好方法，主复位引脚给设计项目中每个触发器馈送清除或置位信号。几乎所有PLD器件都有专门的全局清零脚和全局置位。如果必须从器件内产生清除或置位信号，则要按照“门控时钟”的设计原则去建立这些信号，确保输入无毛刺。 &lt;/p&gt;
&lt;h3&gt;combinational output&lt;/h3&gt;
&lt;p&gt;当PLD输出引脚给出系统内其它部分的边沿敏感信号或电平敏感信号时，这些出信号必须象内部时钟、清除和置位信号一样小心地对待。只要可能就应在PLD输出端寄存那些对险象敏感的组合输出。如果你不能寄存险象敏感的输出，则应符合“门控时钟”中讨论的门控时钟的条件。决不能用多级逻辑驱动毛刺敏感的输出。&lt;/p&gt;
&lt;h3&gt;asynchronous input&lt;/h3&gt;
&lt;p&gt;对于异步输入信号导致的毛刺，解决思想就是 同步化。参见&lt;a href="http://guqian110.github.io/pages/2014/10/09/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html"&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Hazard_(logic)"&gt;Hazard on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2883561/"&gt;Digital Design (4th Edition)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.fpga.com.cn/advance/glitch/giltch.htm"&gt;关于毛刺问题的探讨&lt;/a&gt;&lt;/p&gt;</summary><category term="hazard"></category><category term="glitch"></category></entry><entry><title>OFDM 中的 IFFT/FFT 注意事项</title><link href="http://guqian110.github.io/pages/2015/03/10/ifft_and_fft_in_ofdm.html" rel="alternate"></link><updated>2015-03-10T19:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-03-10:pages/2015/03/10/ifft_and_fft_in_ofdm.html</id><summary type="html">&lt;p&gt;在做 OFDM 项目时，发现一个容易犯错的地方：IFFT/FFT。&lt;/p&gt;
&lt;p&gt;在很多介绍 OFDM 的书中，给出结论：在发射机，基带信号的复包络采用值正好是待发射序列的 IDFT，所以在 N 是 2 的指数时，可以采用 IFFT 来快速计算；在接收机，将接收的频带信号解调到基带，采样得到基带复包络，然后做 DFT (FFT) 即可得到原始的发射序列。&lt;/p&gt;
&lt;p&gt;这个结论是正确的，但是需要注意的一点是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调制/解调所做的运算的形式和 IFFT/FFT 是相同的，但是有一个功率归一化的系数的差别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多书（&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;）都给出了公式推导，然而这些公式并不严谨，这些公式只是为了说明做的变换形式是 IFFT/FFT。&lt;/p&gt;
&lt;p&gt;有的书（&lt;a href="http://book.douban.com/subject/1140934/"&gt;宽带无线通信OFDM技术&lt;/a&gt;）则给出了更加详细，严谨的公式推导。&lt;/p&gt;
&lt;h3&gt;IFFT / FFT&lt;/h3&gt;
&lt;p&gt;&lt;img alt="fft/ifft" src="http://guqian110.github.io/images/xilinx_fft_core_notes/theory.png" /&gt;&lt;/p&gt;
&lt;h3&gt;IFFT /FFT in OFDM&lt;/h3&gt;
&lt;p&gt;OFDM 中 &lt;strong&gt;功率归一化因子&lt;/strong&gt; 为 1/sqr(N)，而标准的 IFFT 中的系数为 1/N，所以在调用标准 IFFT 函数之后，需要额外乘以一个 sqr(N) ：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/N × sqr(N) = 1/sqr(N)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而在接收端，也要先除以一个 sqr(N)，然后再进行 FFT 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1140934/"&gt;宽带无线通信OFDM技术&lt;/a&gt;&lt;/p&gt;</summary><category term="IFFT"></category><category term="FFT"></category><category term="OFDM"></category></entry><entry><title>信噪比小结</title><link href="http://guqian110.github.io/pages/2015/03/10/summary_of_snr_and_noise.html" rel="alternate"></link><updated>2015-03-10T19:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-03-10:pages/2015/03/10/summary_of_snr_and_noise.html</id><summary type="html">&lt;p&gt;所谓 &lt;code&gt;信噪比（SNR, Signal-to-noise ratio）&lt;/code&gt; 就是指 信号的功率 和噪声的功率 的比值。我们可以用它来比较信号的和背景噪声的相对大小，如果比值大于 1（0 dB），说明信号功率比噪声功率强。&lt;/p&gt;
&lt;h2&gt;SNR Def&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;信噪比的定义式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="def" src="http://upload.wikimedia.org/math/f/0/e/f0e032777062c3f945554f1c63d9c864.png" /&gt;&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;P&lt;/code&gt; 表示信号/噪声的平均功率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果信号和噪声的方差已知，且两者的均值都为0，则信噪比可以写为下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq1" src="http://upload.wikimedia.org/math/9/0/9/9098fa286b51274407110dd98832b8b7.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果信号和噪声是使用相同的阻抗来测量的（功率这个词本来就源于物理，在电子系统中，功率 &lt;code&gt;P = UI = V^2/R&lt;/code&gt;），那么信噪比公式可以用幅度的平方比值来计算：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq2" src="http://upload.wikimedia.org/math/6/9/d/69d4d7d398cf17a0184463ae42b4b18b.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;A&lt;/code&gt; 为信号/噪声的 &lt;code&gt;均方根（ root mean square, RMS）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般信号的动态范围都很大，所以通常采用分贝的方式来表示信噪比&lt;/p&gt;
&lt;p&gt;&lt;img alt="ep3" src="http://upload.wikimedia.org/math/8/e/7/8e7f17468834710c835579e252528515.png" /&gt;&lt;/p&gt;
&lt;p&gt;把 均方根 带入，就可以得到下面的公式&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq4" src="http://upload.wikimedia.org/math/6/f/7/6f7dd3340b9b31a3d3afa11532c5480e.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般 SNR 指的是 &lt;strong&gt;平均&lt;/strong&gt; 信噪比，因为通常 SNR  的瞬时值是不同的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信噪比的概念也可以这么理解：将噪声的功率归一化为 1（0 dB），看信号的功率可以达到多大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;SNR in telecom&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在物理学中，交流电信号的 平均功率 = (电压×电流) 的均值，如下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq5" src="http://upload.wikimedia.org/math/b/a/1/ba1615e4d1dc51196247c5a912227dba.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq6" src="http://upload.wikimedia.org/math/c/6/9/c69fbca997fb4cc8a82823fe47c2e47d.png" /&gt;&lt;/p&gt;
&lt;p&gt;但是在信号处理和通信中，一般假设电阻的阻值为 1 欧姆，所以在计算能量、功率时，电阻因子会被忽略。这可能会引起一些困扰。&lt;/p&gt;
&lt;p&gt;所以信号的功率表示式简化为下面的公式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq7" src="http://upload.wikimedia.org/math/a/e/7/ae780e83e953d7329de754a42fcddb63.png" /&gt;&lt;/p&gt;
&lt;p&gt;（其中，&lt;code&gt;A&lt;/code&gt; 是交流信号的幅度）&lt;/p&gt;
&lt;h3&gt;Eb/N0&lt;/h3&gt;
&lt;p&gt;在数字系统中可以使用 SNR 表示噪声的等级，但是更常用的是 &lt;code&gt;Eb/N0 (energy per bit to noise power spectral density ratio)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Eb/N0 是一种归一化的 SNR，称为 “ SNR 每 bit ”，在比较不同的调制方案的 &lt;code&gt;误比特率（BER, bit error rate）&lt;/code&gt; 性能时，因为这种方法不考虑带宽的因素，所以很有效。&lt;/p&gt;
&lt;p&gt;其中 Eb 是平均比特能量，它表示平均每个 bit 包含的能量。&lt;/p&gt;
&lt;p&gt;信号的功率就等于符号中每个比特的功率 Eb × 每个符号所包含的比特数 fb（也就是比特速率）；噪声的能量可以用功率谱密度来计算，N0×B，代入信噪比的定义式，就有下面的换算公式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq9" src="http://upload.wikimedia.org/math/3/5/3/353410b95506c2f45e069c58ff3d121b.png" /&gt;&lt;/p&gt;
&lt;p&gt;P.S. 上面的公式左边使用的是载噪比 CNR，在抑制载波的调制方式中，等于信噪比 SNR。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;AWGN&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;高斯分布（&lt;code&gt;Gaussian distribution&lt;/code&gt;）可以使用 &lt;code&gt;N(μ,σ2 )&lt;/code&gt; 来表示，其中 μ 是均值，σ 是标准差。&lt;/p&gt;
&lt;p&gt;对噪声进行建模，最简单的就是 &lt;strong&gt;加性高斯白噪声 (AWGN, Additive White Gaussian Noise)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加性：叠加在信号之上，而且无论有无信号，噪声都是始终存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高斯：噪声幅度的取值是随机过程，它的概率密度函数服从高斯分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;白噪声：噪声的功率谱密度函数取值是常数，在坐标系中表现为一条直线，在每个频率点的谱密度都一样，就像白光包含各种频率的光一样，所以叫做白噪声。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时满足这三个的条件的噪声就叫做 加性高斯白噪声。&lt;/p&gt;
&lt;p&gt;高斯白噪声的功率谱函数：&lt;code&gt;P(f) = N0/2&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;N0&lt;/code&gt; 是 &lt;strong&gt;单边噪声功率谱密度&lt;/strong&gt;，&lt;code&gt;N0/2&lt;/code&gt; 是 &lt;strong&gt;双边噪声功率谱密度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为功率谱密度函数的定义域是无穷大的，所以高斯噪声的功率也是无穷大的，它的功率只有在带限时才有意义。&lt;/p&gt;
&lt;p&gt;在计算前面 SNR 时，我们可以使用下面两种方法来得到 Pn：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果均值为 0，&lt;code&gt;Pn = 方差 σ2 = R(0)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果已知功率谱密度函数 P(f)，那么直接对其定积分&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Signal-to-noise_ratio"&gt;Signal-to-noise ratio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Eb/N0"&gt;Eb/N0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Gaussian_noise"&gt;Gaussian noise&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.c114.net/thread-663445-1-1.html"&gt;关于白噪声功率谱密度和方差的关系 &lt;/a&gt;&lt;/p&gt;</summary><category term="SNR"></category></entry><entry><title>学习 Vim 之 BufExplorer、NERDTree、WinManager、Powerline 插件</title><link href="http://guqian110.github.io/pages/2015/03/04/learning_vim_bufexplorer_nerdtree_winmanager_powerline.html" rel="alternate"></link><updated>2015-03-04T22:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-03-04:pages/2015/03/04/learning_vim_bufexplorer_nerdtree_winmanager_powerline.html</id><summary type="html">&lt;h2&gt;BufExplorer&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;:ls&lt;/code&gt; 命令可以查看打开的 buffer，然后在不同的 buffer 之间切换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;bn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 &lt;code&gt;n&lt;/code&gt; 是 buffer 的标号。&lt;/p&gt;
&lt;p&gt;这种内置的方法效率比较低，尤其是当我们打开很多个 Buffer 之后，问题更加明显。所以就有了各种 buf 类的插件，最有名的就是：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=42"&gt;BufExplorer&lt;/a&gt; 和 &lt;a href="http://www.vim.org/scripts/script.php?script_id=159"&gt;MiniBufferExplorer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不同的人使用习惯不同，在 stackoverflow 上有专门讨论两者的优劣的问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1649187/vim-minibufexpl-versus-bufexplorer-plugins"&gt;ViM: minibufexpl versus bufexplorer plugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我个人觉得 BufExplorer 更好一些，主要原因在于 Mini 在打开很多 buffer时（&amp;gt;8个），切换 buffer 效率很低，而且 Mini 会占用几行宝贵的屏幕资源。&lt;/p&gt;
&lt;p&gt;下面就主要说 BufExlplorer。&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bufexplorer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zip&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 vim，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Config&lt;/h3&gt;
&lt;p&gt;查看 help 文档，自定义配置，我的简单配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; Config BufExplorer&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;bufExplorerDefaultHelp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;       &lt;span class="s"&gt;&amp;quot; Do not show default help.&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;bufExplorerShowRelativePath&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot; Show relative paths.&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;bufExplorerSortBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;mru&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;        &lt;span class="s"&gt;&amp;quot; Sort by most recently used.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;NERDTree&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;NERDTree 是一款可以提供树形目录的 vim 插件，使用它我们可以在 vim 内以树形结构浏览文件目录。&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NERD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 vim，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Usage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入 &lt;code&gt;:NERDTree&lt;/code&gt; 打开 NERDTree 窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用快捷键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;o 打开/关闭光标所在目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;t 在新 tab 中打开文件，并跳转到该 tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;T 在新 tab 中打开文件，并不跳转到该 tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p 跳转到父节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P 跳转到根节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;q 关闭 NERDTree 窗口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Powerline&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;状态栏也是一个非常重要的窗口，可以为我们提供一些文档的基本信息，我们可以自己 DIY，在 .vimrc 文件中添加相关的设置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;statusline&lt;/span&gt;&lt;span class="o"&gt;=%&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FORMAT&lt;/span&gt;&lt;span class="o"&gt;=%&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;TYPE&lt;/span&gt;&lt;span class="o"&gt;=%&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;POS&lt;/span&gt;&lt;span class="o"&gt;=%&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;%%&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;strftime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d/%m/%y\ -\ %H:%M&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;)}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以使用 &lt;a href="https://github.com/Lokaltog/vim-powerline"&gt;Powerline&lt;/a&gt; 插件，一款可以提供非常漂亮的状态栏的插件。它会覆盖掉 .vimrc 中对状态的配置，删除插件后配置信息可以重新起作用。&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Lokaltog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;powerline&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 vim，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Config&lt;/h3&gt;
&lt;p&gt;为了保证状态栏始终显示，在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;laststatus&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置之后，应该就可以看到漂亮的状态栏了。&lt;/p&gt;
&lt;p&gt;查看 help：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;powerline&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们还可以自定义一些选项，比如颜色主题等。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;WinManager&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;我们已经安装很多插件，比如 Taglist，BufExlporer、NERDTree 等，这时候我们就需要一个窗口管理插件来将它们组合起来 —— &lt;a href="http://www.vim.org/scripts/script.php?script_id=95"&gt;WinManager&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;winmanager&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 vim，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Config&lt;/h3&gt;
&lt;p&gt;查看 help 文档，我们可以进行简单的设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; Config Winmanager&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;let g:winManagerWindowLayout=&amp;quot;&lt;/span&gt;&lt;span class="nx"&gt;NERDTree&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nx"&gt;TagList&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;let g:NERDTree_title=&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;NERDTree&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&amp;quot;

nmap &lt;span class="nt"&gt;&amp;lt;C&lt;/span&gt;&lt;span class="na"&gt;-m&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; :WMToggle&lt;span class="nt"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;

function! NERDTree_Start()  
    exec &amp;#39;NERDTree&amp;#39;  
endfunction

function! NERDTree_IsValid()  
    return 1  
endfunction
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时候我们按下组合键 Ctrl-m 即可切换是否显示 winmanager 窗口布局。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;最后附上效果图一张：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/learning-vim-bufexplorer-nerdtree-winmanager-powerline/screenshot.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-netrw-bufexplorer-winmanager-plugin/"&gt;vi/vim使用进阶: 文件浏览和缓冲区浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/bokee/article/details/6633193"&gt; 将Vim改造为强大的IDE—Vim集成Ctags/Taglist/Cscope/Winmanager/NERDTree/OmniCppComplete（有图有真相）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/chijianqiang/archive/2012/11/06/vim-3.html"&gt;谁说Vim不是IDE？（三）&lt;/a&gt;&lt;/p&gt;</summary><category term="vim"></category><category term="BufExplorer"></category><category term="NERDTree"></category><category term="WinManager"></category><category term="Powerline"></category></entry><entry><title>活着 有感</title><link href="http://guqian110.github.io/pages/2015/02/05/to_live_review.html" rel="alternate"></link><updated>2015-02-05T14:13:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-02-05:pages/2015/02/05/to_live_review.html</id><summary type="html">&lt;p&gt;寒假前的最后几天，偷懒没有去实验室，在宿舍温暖的被窝里面看完了余华的《活着》。看完之后，有种想说却说不出的难受，或许这就是 “活着” 的沉重吧。作为代码狗，我的语文水平对不起当年的体育老师，但是还是想写一点胡言乱语，日后回首，不知会是番什么滋味。。。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;苦难文学，每个人的一生都是在苦难中度过：&lt;/p&gt;
&lt;p&gt;故事是关于一个叫做 福贵
的男人的一生：年少时，他是地主少爷，是吃喝嫖赌的败家子，当他挥霍光全部家产后，父亲被他气死，怀孕的老婆也被接回了娘家，只留下一个老母亲和小女儿。于是他从地主少爷变成了一个佃户，细皮嫩肉的他不得不下地种田，然而苦日子才刚刚开始，后面还有更大的苦难在等着他。从少爷成为一个佃户，再被抓取当壮丁，侥幸没死在战场上，回家和家人团聚后又经历了大跃进和文化大革命，他先后送走了自己的父母，儿子，老婆，女儿，女婿，外孙子，命运给他剩下来的就是一头和他一样被称作“老不死”的老黄牛。&lt;/p&gt;
&lt;p&gt;福贵的老婆家珍本来是米行的大小姐，嫁给了败家的福贵，然后陪着他过完了苦难的一生；福贵的儿子有庆年少但是懂事、勤劳，却不想被庸医抽血抽死了；福贵的女儿凤霞从小随父母吃苦，又聋又哑，之后好不容易遇到一个真正爱她的丈夫，没有享受多少好日子就死于难产；福贵的女婿勤快老实，却也在工地上死于意外；留下来的外孙苦根虽然年少，却也知道心疼福贵，为他分忧，但命运仍然没有放过他。&lt;/p&gt;
&lt;p&gt;面对苦难的命运，福贵他们选择默默忍受，忍耐是中国老百姓最擅长的，没有抗争命运的动人桥段，但却让人更加为之动容。因为我们是长在这样的环境，这样的文化中，它溶于我们的血液灵魂之中。&lt;/p&gt;
&lt;p&gt;故事虽然苦难，但是我们也能从中读出了一丝丝温情。&lt;/p&gt;
&lt;p&gt;首先，亲情。输掉家产，让福贵看到父母、老婆的真情所在，幡然悔悟，浪子回头金不换，重新做人。包括后来福贵、家珍对自己儿女简单粗暴的教育、生病的关心，受苦的心疼，儿女小小年纪却非常懂事，正是亲情让他们相互依赖，相互扶持，坚强地活下去。&lt;/p&gt;
&lt;p&gt;其次，爱情。作为大小姐家珍面对败家的丈夫毫无怨言，心干情愿地陪着他吃了一辈子的苦，在他输光所有家产后没有离开他，他被抓起当壮丁后仍然坚守着这个家，或许这是福贵一生最大的幸福吧。或许有人会说这是旧社会束缚女性的毒瘤，但是我更愿意称之为爱情。当福贵在村口毫无顾忌地背起家珍，我想家珍心里一定是充满温暖的。而凤霞和二喜的爱情虽然短暂，但仍让人羡慕。&lt;/p&gt;
&lt;p&gt;最后，人情。书里面没有大奸大恶之徒，除了那个让人痛恨的庸医，村民、队长、老全、春生他们都是尽最大努力好好地活在这个世界上，他们或许有让人不喜欢的地方，但是他们都算是朴实善良。相比于当前社会人们之间的丑恶，这份淳朴更加让人感动。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;活着，一句简单但是充满力量的话，包含着中国老百姓对生命的态度和理解：努力地活下去，去感受、忍受生命带给我们的苦难和幸福，我们每个人何尝不是福贵，生活给我们苦难，磨去我们的棱角，让我们成长，甚至让我们孤独一生，最后只有一头老黄牛相伴，我们也应该像福贵一样地活着，像老黄牛一样活着。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认识苦难，接受苦难，珍惜身边的每个人，更好地、更坚强地活下去&lt;/strong&gt;，我想这也许就是苦难文学最大的意义吧。&lt;/p&gt;</summary><category term="活着"></category><category term="余华"></category></entry><entry><title>在 Vim 中写 Markdown 文件</title><link href="http://guqian110.github.io/pages/2015/02/01/learning_vim_markdown.html" rel="alternate"></link><updated>2015-02-01T13:46:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-02-01:pages/2015/02/01/learning_vim_markdown.html</id><summary type="html">&lt;p&gt;&lt;code&gt;Vim&lt;/code&gt; 和 &lt;code&gt;Markdown&lt;/code&gt; 就不多罗嗦了，记录一下最近在 Vim 中摸索使用 Markdown 的经历。&lt;/p&gt;
&lt;h2&gt;Syntax Hightlight&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Vim 可以通过插件来提供对 Markdown 语法的支持，网上找到很多这类插件：&lt;/p&gt;
&lt;p&gt;官网上的插件：&lt;a href="http://www.vim.org/scripts/script.php?script_id=2882"&gt;Markdown&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我找到的是下面这个：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/plasticboy/vim-markdown"&gt;plasticboy/vim-markdown&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 管理插件，只需要在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;godlygeek&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tabular&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;plasticboy&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后打开 Vim，输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即可。&lt;/p&gt;
&lt;h3&gt;File extension&lt;/h3&gt;
&lt;p&gt;Markdown 文件的后缀名可以是 &lt;code&gt;.markdown&lt;/code&gt;，&lt;code&gt;mkd&lt;/code&gt;，&lt;code&gt;mkdn&lt;/code&gt;，&lt;code&gt;md&lt;/code&gt; 等，但是 plasticboy 的插件只识别 &lt;code&gt;mkd&lt;/code&gt; 和 &lt;code&gt;markdown&lt;/code&gt; 两种：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/10964681/enabling-markdown-highlighting-in-vim"&gt;Enabling markdown highlighting in Vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为我们已经按照 .md 格式写了很多文本了，这时候更好选择当然是修改设置，让 vim 可以识别这种类型的文件，而不是修改文件后缀名。所以我们需要在 vimrc 中设置一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;au&lt;/span&gt; &lt;span class="n"&gt;BufRead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;BufNewFile&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;md&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;filetype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，.md 文件就可以被识别了。&lt;/p&gt;
&lt;p&gt;经过上面两步，此时再打开 markdown 文件就可以看到语法高亮了，plasticboy/vim-markdown 还支持一些高级的主题：比如支持 LaTeX 数学公式的高亮，ToC 等，从 github 上可以看到相关设置的介绍说明。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Preview&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;一些专门的 Markdown 软件、网页编辑器都是提供实时预览，Vim 虽然不提供预览窗口，但是配合浏览器，我们也可以实现实时预览的功能，当然还是依靠万能的插件。&lt;/p&gt;
&lt;p&gt;我使用的是：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/suan/vim-instant-markdown"&gt;suan/vim-instant-markdown&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先要保证已经安装了 node.js&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;npm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有，安装 npm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;npm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;code&gt;instant-markdown-d&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;npm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;instant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确保系统安装了 &lt;code&gt;xdg-utils&lt;/code&gt;，否则 apt-get 安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 Vundle 管理插件&lt;/p&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;suan&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;instant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打开 vim，输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Config &amp;amp; Use&lt;/h3&gt;
&lt;p&gt;如果机器比较老，插件占用的资源过多的话，可以设置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;instant_markdown_slow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;来降低资源利用。&lt;/p&gt;
&lt;p&gt;默认情况下，当我们打开 markdown 文件时，插件会自动打开一个预览的浏览器标签页，如果不想，可以关闭自动打开功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;instant_markdown_autostart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在需要时手动输入命令 &lt;code&gt;:InstantMarkdownPreview&lt;/code&gt; 来预览。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Vim 窗口重叠在浏览器窗口之上时，会遮住部分内容；当两个窗口并排时，浏览器窗口无法完全显示全部内容，这在小尺寸屏幕上尤其明显。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开的预览网页无法实时跟随内容滚动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后放一张截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/learning-vim-markdown/screenshot.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/plasticboy/vim-markdown"&gt;plasticboy/vim-markdown&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/10964681/enabling-markdown-highlighting-in-vim"&gt;Enabling markdown highlighting in Vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/suan/vim-instant-markdown"&gt;suan/vim-instant-markdown&lt;/a&gt;&lt;/p&gt;</summary><category term="vim"></category><category term="markdown"></category></entry><entry><title>学习 Vim 之 Ctags/Cscope/Taglist</title><link href="http://guqian110.github.io/pages/2015/01/25/learning_vim_ctags_cscope_taglist.html" rel="alternate"></link><updated>2015-01-25T21:32:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-01-25:pages/2015/01/25/learning_vim_ctags_cscope_taglist.html</id><summary type="html">&lt;h2&gt;Background&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;tags 文件是一种非常有用的文件，本文的内容都是基于 &lt;code&gt;tag&lt;/code&gt; 的，所以首先得了解什么是 tag？&lt;/p&gt;
&lt;p&gt;Vim Manual 里面的简单介绍就足够我们进行下面的内容了。查看 Manual：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;tagsrch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 tags 文件的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先使用 tag 工具（ctags、cscope等）生成 tags 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，将 tags 文件路径导入到 Vim 中，让 Vim 知道从哪个 tags 文件中查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，使用 Vim 的命令查找 tag。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ctags&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="ctags.sourceforge.net/"&gt;Ctags 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Ctags"&gt;wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ctags&lt;/strong&gt; is a programming tool that generates an index (or tag) file of names found in source and header files of various programming languages. Depending on the language, functions, variables, class members, macros and so on may be indexed. These tags allow definitions to be quickly and easily located by a text editor or other utility. Alternatively, there is also an output mode that generates a cross reference file, listing information about various names found in a set of language files in human-readable form.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;manpage: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;ctags&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;vim Manual：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="mf"&gt;29.1&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;ctags&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;简而言之，Ctags 是一个可以自动提取源文件和头文件中函数、变量、类成员、宏定义等元素的工具，然后它会建立一个 tags 文件，其他编辑器（比如我们使用的 Vim）可以读取这个 tags 文件，从而快速定位代码的位置。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ctags --list-language&lt;/code&gt; 可以查看 ctags 支持的语言，使用 &lt;code&gt;ctags --list-maps&lt;/code&gt; 可以查看哪些后缀名对应对应的语言。&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;p&gt;ctags 是 Unix 系统自带的一个工具，但是功能比较少，所以一般使用 Exuberant Ctags。在 Linux 上，Exuberant Ctags 是默认的 Ctags 程序。如果系统中没有安装的话，我们可以从官网上下载源码编译安装，或者直接 apt-get 安装。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;exuberant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ctags&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Config&lt;/h3&gt;
&lt;p&gt;我们要使用 tags，第一步就是生成 tags 文件。生成 tags 文件时，ex-ctags 提供了很多参数供我们控制生成结果，详细内容可以查看其 manpage，这里有 easwy 大神翻译的中文版：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/exuberant-ctags-chinese-manual/"&gt;Exuberant Ctags中文手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以将配置写在 .vimrc 中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="kt"&gt;map&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-F12&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nx"&gt;ctags&lt;/span&gt; &lt;span class="na"&gt;-R&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="o"&gt;++-&lt;/span&gt;&lt;span class="n"&gt;kinds&lt;/span&gt;&lt;span class="o"&gt;=+&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;fields&lt;/span&gt;&lt;span class="o"&gt;=+&lt;/span&gt;&lt;span class="nx"&gt;iaS&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;extra&lt;/span&gt;&lt;span class="o"&gt;=+&lt;/span&gt;&lt;span class="nx"&gt;q&lt;/span&gt; &lt;span class="nx"&gt;.&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，我们只需要按 Ctrl-F12 即可自动生成 C++ 项目的 tags 文件。&lt;/p&gt;
&lt;h3&gt;Usage&lt;/h3&gt;
&lt;p&gt;Vim 提供了接口可以调用 tags 文件，它使用一个栈来记录我们在文件中跳转的位置。ctags 其 manual page 中有说明如何在 Vi 中使用 ctags：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vi -t tags&lt;/code&gt; 打开 vi，并且将光标停留在 &lt;code&gt;tag&lt;/code&gt; 定义的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ta tag&lt;/code&gt; 寻找 &lt;code&gt;tag&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl-]&lt;/code&gt; 寻找光标处 tag 的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl-T&lt;/code&gt; 返回到 tag 的前一个位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tnext&lt;/code&gt; 如果某个 tag（比如函数）有多次定义，会匹配到多个结果，本命令跳到下一个结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tprevious&lt;/code&gt; 同上，跳转到前一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tfirst&lt;/code&gt; 跳转到第一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tlast&lt;/code&gt; 跳转到最后一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ts tag&lt;/code&gt; 同上，列出所有匹配到 tag 的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:tags&lt;/code&gt; 显示 tagstack 中的内容，即我们的跳转记录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Cscope&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://cscope.sourceforge.net/"&gt;Cscope 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cscope"&gt;cscope wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cscope is a console mode or text-based graphical interface that allows computer programmers or software developers to search C source code (there is limited support for other languages). It is often used on very large projects to find source code, functions, declarations, definitions and regular expressions given a text string. cscope is free and available under a BSD License. The original developer of cscope is Joe Steffen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;man page:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;cscope&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim help:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;if_cscop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The following text is taken from a version of the cscope man page:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cscope is an interactive screen-oriented tool that helps you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Learn how a C program works without endless flipping through a thick listing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Locate the section of code to change to fix a bug without having to learn the entire program.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examine the effect of a proposed change such as adding a value to an enum variable.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verify that a change has been made in all source files such as adding an argument to an existing function.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rename a global variable in all source files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change a constant to a preprocessor symbol in selected lines of files.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is designed to answer questions like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Where is this symbol used?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is it defined?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where did this variable get its value?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What is this global symbol's definition?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is this function in the source files?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What functions call this function?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What functions are called by this function?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where does the message "out of space" come from?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is this source file in the directory structure?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What files include this header file?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cscope answers these questions from a symbol database that it builds the
 first time it is used on the source files.  On a subsequent call, cscope
 rebuilds the database only if a source file has changed or the list of
 source files is different.  When the database is rebuilt the data for the
 unchanged files is copied from the old database, which makes rebuilding
 much faster than the initial build.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，就是 ctags 的加强版，ctags 只能让我们跳转到某个 tag 的定义之处，但是无法让我们知道这个 tag 还在哪里出现过，或者被哪个函数调用过，这时候就需要 cscope 来大显身手了～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cscope 对 C/C++ 支持比较好，当然我们也可以自己定制来支持其他语言，比如 Java，Python 等。&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;cscope&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Usage&lt;/h3&gt;
&lt;p&gt;联合使用 Cscope + Vim 的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 cscope 生成数据库文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cscope&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Rbkq&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中参数的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-R 递归，对子目录也建立数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-b 只生成数据库，不进入 scope 界面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-k 生成数据库时，不搜索 &lt;code&gt;/usr/include&lt;/code&gt; 目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-q 生成 &lt;code&gt;cscope.in.out&lt;/code&gt; 和 &lt;code&gt;cscope.po.out&lt;/code&gt; 文件，加快查找速度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更详细的参数见 man page。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将数据库导入 Vim 中&lt;/p&gt;
&lt;p&gt;cd 到源文件目录下，执行上一步操作，然后打开 vim 输入下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cscope&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Vim 中查找&lt;/p&gt;
&lt;p&gt;通用格式为 &lt;code&gt;:cs find -option label&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;option 可以有很多种模式，在 Vim 中使用 &lt;code&gt;:help cscope-find&lt;/code&gt; 来查看 option：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Find&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="nx"&gt;C&lt;/span&gt; &lt;span class="nx"&gt;symbol&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Find&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="nx"&gt;definition&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Find&lt;/span&gt; &lt;span class="nx"&gt;functions&lt;/span&gt; &lt;span class="nx"&gt;called&lt;/span&gt; &lt;span class="nx"&gt;by&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Find&lt;/span&gt; &lt;span class="nx"&gt;functions&lt;/span&gt; &lt;span class="nx"&gt;calling&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Find&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="nx"&gt;text&lt;/span&gt; &lt;span class="nx"&gt;string&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Find&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="nx"&gt;egrep&lt;/span&gt; &lt;span class="nx"&gt;pattern&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Find&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="nx"&gt;file&lt;/span&gt;
&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Find&lt;/span&gt; &lt;span class="nx"&gt;files&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;including&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="nx"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Config&lt;/h3&gt;
&lt;p&gt;Vim 的 cscope 接口提供了一些参数，可以让我们更加灵活地使用 cscope，可以用 &lt;code&gt;help if_cscop&lt;/code&gt; 来查看完整的说明，这里有一份前辈翻译的中文版&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/dengxiayehu/article/details/6330200"&gt;Cscope的使用（领略Vim + Cscope的强大魅力）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我找了几个常用的选项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;cscopequickfix&lt;/p&gt;
&lt;p&gt;vim 提供了 &lt;code&gt;cscopequickfix&lt;/code&gt; 选项，让查找结果在 quickfix 的窗口显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时使用 cscope ctags &lt;/p&gt;
&lt;p&gt;设置 &lt;code&gt;cst&lt;/code&gt; 选项，可以同时查找 cscope 和 ctags，查找顺序有 &lt;code&gt;csto&lt;/code&gt; 选项来决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ctags&lt;/code&gt; 等同于 &lt;code&gt;:cs find g&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了省事，我们可以将一些参数设置写在 .vimrc 文件中，Vim help 中有推荐设置，下面是我修改过的配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;cscope&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;csprg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;usr&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;bin&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;cscope&lt;/span&gt;
    &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;cscopequickfix&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;d&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;set cst &amp;quot;&lt;/span&gt;&lt;span class="nx"&gt;keep&lt;/span&gt; &lt;span class="nx"&gt;the&lt;/span&gt; &lt;span class="nx"&gt;regular&lt;/span&gt; &lt;span class="kt"&gt;tag&lt;/span&gt; &lt;span class="nx"&gt;behavior&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;set csto=0 &amp;quot;&lt;/span&gt;&lt;span class="nx"&gt;keep&lt;/span&gt; &lt;span class="nx"&gt;the&lt;/span&gt; &lt;span class="nx"&gt;regular&lt;/span&gt; &lt;span class="kt"&gt;tag&lt;/span&gt; &lt;span class="nx"&gt;behavior&lt;/span&gt;
    &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;nocsverb&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot; add any database in current directory&lt;/span&gt;
&lt;span class="s2"&gt;    if filereadable(&amp;quot;&lt;/span&gt;&lt;span class="nx"&gt;cscope.out&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&lt;/span&gt;
&lt;span class="s2"&gt;        cs add cscope.out&lt;/span&gt;
&lt;span class="s2"&gt;    &amp;quot;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nb"&gt;add&lt;/span&gt; &lt;span class="nx"&gt;database&lt;/span&gt; &lt;span class="nx"&gt;pointed&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="nx"&gt;environment&lt;/span&gt;
    &lt;span class="nx"&gt;elseif&lt;/span&gt; &lt;span class="nv"&gt;$CSCOPE_DB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;add&lt;/span&gt; &lt;span class="nv"&gt;$CSCOPE_DB&lt;/span&gt;
    &lt;span class="nx"&gt;endif&lt;/span&gt;
    &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;csverb&lt;/span&gt;
&lt;span class="nx"&gt;endif&lt;/span&gt;

&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;find&lt;/span&gt; &lt;span class="nb"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nx"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;g&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;find&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nx"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;find&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nx"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nb"&gt;t&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;find&lt;/span&gt; &lt;span class="nb"&gt;t&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nx"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;find&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nx"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nb"&gt;f&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;find&lt;/span&gt; &lt;span class="nb"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nx"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cfile&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;find&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;^&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nx"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cfile&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nb"&gt;d&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;cs&lt;/span&gt; &lt;span class="nb"&gt;find&lt;/span&gt; &lt;span class="nb"&gt;d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="na"&gt;-R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nx"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Using &amp;#39;CTRL-spacebar&amp;#39; then a search type makes the vim window&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nb"&gt;split&lt;/span&gt; &lt;span class="nx"&gt;horizontally&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;search&lt;/span&gt; &lt;span class="nb"&gt;result&lt;/span&gt; &lt;span class="n"&gt;displayed&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; the new window.&lt;/span&gt;

&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;s :scs find s &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;g :scs find g &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;c :scs find c &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;t :scs find t &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;e :scs find e &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;f :scs find f &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cfile&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;i :scs find i ^&amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cfile&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;$&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;d :scs find d &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Hitting&lt;/span&gt; &lt;span class="nx"&gt;CTRL&lt;/span&gt;&lt;span class="na"&gt;-space&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;twice&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;before&lt;/span&gt; &lt;span class="nx"&gt;the&lt;/span&gt; &lt;span class="nb"&gt;search&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;does&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="nx"&gt;vertical&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; split instead of a horizontal one&lt;/span&gt;

&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;&amp;lt;C-Space&amp;gt;s&lt;/span&gt;
&lt;span class="s2"&gt;    &lt;/span&gt;&lt;span class="se"&gt;\:vert scs find s &amp;lt;C-R&amp;gt;=expand(&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="se"&gt;nmap &amp;lt;C-Space&amp;gt;&amp;lt;C-Space&amp;gt;g&lt;/span&gt;
&lt;span class="se"&gt;    \:&lt;/span&gt;&lt;span class="s2"&gt;vert scs find g &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;&amp;lt;C-Space&amp;gt;c&lt;/span&gt;
&lt;span class="s2"&gt;    &lt;/span&gt;&lt;span class="se"&gt;\:vert scs find c &amp;lt;C-R&amp;gt;=expand(&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="se"&gt;nmap &amp;lt;C-Space&amp;gt;&amp;lt;C-Space&amp;gt;t&lt;/span&gt;
&lt;span class="se"&gt;    \:&lt;/span&gt;&lt;span class="s2"&gt;vert scs find t &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;&amp;lt;C-Space&amp;gt;e&lt;/span&gt;
&lt;span class="s2"&gt;    &lt;/span&gt;&lt;span class="se"&gt;\:vert scs find e &amp;lt;C-R&amp;gt;=expand(&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="se"&gt;nmap &amp;lt;C-Space&amp;gt;&amp;lt;C-Space&amp;gt;i&lt;/span&gt;
&lt;span class="se"&gt;    \:&lt;/span&gt;&lt;span class="s2"&gt;vert scs find i ^&amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cfile&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;$&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;C-Space&amp;gt;&amp;lt;C-Space&amp;gt;d&lt;/span&gt;
&lt;span class="s2"&gt;    \:vert scs find d &amp;lt;C-R&amp;gt;=expand(&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cword&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Taglist&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=273"&gt;Taglist 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用过 VS 的人都知道，在左侧有一个窗口专门显示当前代码文件中的宏、函数、变量定义，并且随着文件切换自动更新。我们这里介绍的 Taglist 完成的就是类似的功能，让我们可以高效地浏览代码。不过要使用 Taglist，首先要安装前面介绍的 Ctags。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The "Tag List" plugin is a source code browser plugin for Vim and provides an overview of the structure of source code files and allows 
you to efficiently browse through source code files for different programming languages. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;p&gt;与前面的 ctags、cscope 不同的是，taglist 是一款 Vim 插件。如果使用 Vundle 来管理、安装插件，在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;taglist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后打开 vi，然后输入命令 &lt;code&gt;:BundleInstall&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3&gt;Config&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;:help taglist&lt;/code&gt; 查看帮助。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;:TlistToggle&lt;/code&gt; 切换是否显示 Taglist 窗口。&lt;/p&gt;
&lt;p&gt;我们可以直接在 .vimrc 中添加以下设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;Tlist_Show_One_File&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;Tlist_Exit_OnlyWindow&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;Tlist_SHow_Menu&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;Tlist_File_Fold_Auto_Close&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Usage&lt;/h3&gt;
&lt;p&gt;在 taglist 窗口，我们可以使用下面的一些快捷键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt; 折叠所有 tag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-&lt;/code&gt; 折叠单个 tag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 打开一个折叠&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; taglist 窗口放大/缩小，方便查看 tag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; 更新 taglist&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sapce&lt;/code&gt; 显示光标处 tag 的原型定义&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配合另外一个窗口管理插件 winmanager，我们可以将我们的 Vim 打造成一个伪 IDE :D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/alexdboy/article/details/3871707"&gt;ctags的使用及相关参数介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/exuberant-ctags-chinese-manual/"&gt;Exuberant Ctags中文手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-use-ctags-tag-file/"&gt;vi/vim使用进阶: 使用标签(tag)文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cscope.sourceforge.net/"&gt;cscope 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cscope"&gt;cscope wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/dengxiayehu/article/details/6330200"&gt;Cscope的使用（领略Vim + Cscope的强大魅力）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=273"&gt;Taglist 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-taglist-plugin/"&gt;vi/vim使用进阶: 使用taglist插件&lt;/a&gt;&lt;/p&gt;</summary><category term="vim"></category><category term="ctags"></category><category term="cscope"></category><category term="taglist"></category></entry><entry><title>针对 Verilog 的 Doxygen</title><link href="http://guqian110.github.io/pages/2015/01/21/doxygen_for_verilog.html" rel="alternate"></link><updated>2015-01-21T10:25:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-01-21:pages/2015/01/21/doxygen_for_verilog.html</id><summary type="html">&lt;p&gt;最近学习了 Doxygen，它可以帮助我们生成美观的文档。Doxygen 支持的程序语言中包含 VHDL，但是不包含 Verilog。&lt;/p&gt;
&lt;p&gt;那么问题就又来了：&lt;strong&gt;有没有一个支持 Verilog 的类似 Doxygen 的程序？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案当然是：&lt;strong&gt;有， Doxverilog&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;机智的网友早就遇到了和我一样的问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.edaboard.co.uk/documentation-generator-for-verilog-t241923.html"&gt;Documentation generator for Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sndegroot.blogspot.com/2011/08/documenting-verilog-ams-using.html"&gt;Documenting Verilog (AMS) using Doxygen/Doxverilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sndegroot.blogspot.com/2014/04/doxverilog-has-been-updated.html"&gt;Doxverilog has been updated&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我搜到了两个工具：一个是 perl 脚本&lt;a href="http://www.burbleland.com/v2html/v2html.html"&gt;v2html&lt;/a&gt;，另一个就是 Doxverilog。前者生成的页面美观性实在不敢恭维，理想工具当然是 Doxverilog。&lt;/p&gt;
&lt;h2&gt;Doxverilog&lt;/h2&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Doxverilog  is a nativ verilog parser (Verilog 2001) for Doxygen. After installing this patch you can documentate your verilog project  similar to VHDL in Doxygen.
Patch against the doxygen-1.7.0 version. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Doxverilog基于 Doxygen ，只是额外添加了对 Verilog 语言的支持。它托管在 &lt;a href="http://sourceforge.net/projects/doxverilog.berlios/"&gt;sourceforge&lt;/a&gt; 上的压缩包貌似是损坏的，不能正常解压，幸好在 Github 上的还是好的：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ewa/doxverilog/tree/master/Doxverilog2.7"&gt;Doxverilog on Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于 Doxverilog 的安装使用方法，github 上已经说的很清楚了，下面只记录一下我遇到的问题。&lt;/p&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;安装步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;patch&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;patch&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F3&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p0&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;patch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compile&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写本文时，Doxverilog 的版本号是 2.7，对应的 Doxygen 的版本号是 1.8.1，而 Doxygen 官网上的版本已经更新到了 1.8.9，如果最新版本可能在编译的时候报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 patch 时，可能会遇到询问，一路 y 下去即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 compile 时，可能会报错，我遇到的报错是 vhdlparse.cpp 缺少行末分号的小问题，自己添加就行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译安装完成之后，我们应该可以使用一个文档来测试一下，如果生成的配置文件中包含 &lt;code&gt;OPTIMIZE_OUTPUT_VERILOG&lt;/code&gt; 这个选项，那么就说明破解安装成功了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Configuration&lt;/h3&gt;
&lt;p&gt;在修改配置文档时，除了常规的配置选项之外，对于 Verilog 我们还需要额外注意一下几个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OPTIMIZE_OUTPUT_VERILOG = YES&lt;/code&gt; 针对 Verilog 进行输出优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FILE_PATTERNS = *.v&lt;/code&gt; 标明选择 verilog 源文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Documenting Verilog/VHDL&lt;/h3&gt;
&lt;p&gt;注释规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于 Verilog 的注释规则，和 VHDL 类似，唯一的不同之处在于 VHDL 使用 &lt;code&gt;--!&lt;/code&gt; 来开始注释，Verilog 使用 &lt;code&gt;//%&lt;/code&gt; 作为注释的开头。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VHDL 中使用单行的 &lt;code&gt;--!&lt;/code&gt; 来开始 brief description，使用多行的 &lt;code&gt;--!&lt;/code&gt; 开始 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verilog 使用单行的 &lt;code&gt;//%&lt;/code&gt; 开始 brief description，使用多行的 &lt;code&gt;//%&lt;/code&gt; 开始 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的注释都在对应代码的前面，只有一个例外：端口的 brie description 可以写在代码后，而且不用像 C++ 中一样修改注释的头部&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是 Doxygen 官网是 VHDL 注释的例子：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;-------------------------------------------------------&lt;/span&gt;
&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="k"&gt;file&lt;/span&gt;
&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;brief&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;Mux&lt;/span&gt; &lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt;
&lt;span class="c1"&gt;-------------------------------------------------------&lt;/span&gt;

&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="k"&gt;Use&lt;/span&gt; &lt;span class="nn"&gt;standard&lt;/span&gt; &lt;span class="k"&gt;library&lt;/span&gt;
&lt;span class="nn"&gt;library&lt;/span&gt; &lt;span class="n"&gt;ieee&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="k"&gt;Use&lt;/span&gt; &lt;span class="nn"&gt;logic&lt;/span&gt; &lt;span class="n"&gt;elements&lt;/span&gt;
    &lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;ieee.std_logic_1164.all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="n"&gt;Mux&lt;/span&gt; &lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;brief&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt;

&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="n"&gt;Detailed&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; 
&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="n"&gt;mux&lt;/span&gt; &lt;span class="n"&gt;design&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;mux_using_with&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;din_0&lt;/span&gt;   &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="n"&gt;Mux&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;
        &lt;span class="n"&gt;din_1&lt;/span&gt;   &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="n"&gt;Mux&lt;/span&gt; &lt;span class="n"&gt;Second&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;
        &lt;span class="n"&gt;sel&lt;/span&gt;     &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="k"&gt;Select&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;
        &lt;span class="n"&gt;mux_out&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;out&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;  &lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="n"&gt;Mux&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;brief&lt;/span&gt; &lt;span class="k"&gt;Architecture&lt;/span&gt; &lt;span class="n"&gt;definition&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;MUX&lt;/span&gt;
&lt;span class="o"&gt;--!&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;details&lt;/span&gt; &lt;span class="n"&gt;More&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt; &lt;span class="n"&gt;about&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;mux&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="k"&gt;architecture&lt;/span&gt; &lt;span class="nc"&gt;behavior&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;mux_using_with&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;
    &lt;span class="n"&gt;mux_out&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din_0&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="n"&gt;din_1&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="k"&gt;others&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;architecture&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;生成的 &lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/examples/mux/html/index.html"&gt;结果&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我写的 Verilog 的注释：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//% @file mycounter.v&lt;/span&gt;
&lt;span class="c1"&gt;//% @brief Implementation file of module mycounter.&lt;/span&gt;
&lt;span class="c1"&gt;//% &lt;/span&gt;
&lt;span class="c1"&gt;//% @author Qian Gu&lt;/span&gt;
&lt;span class="c1"&gt;//% @version 1.0&lt;/span&gt;
&lt;span class="c1"&gt;//% @date 2015-01-20&lt;/span&gt;

&lt;span class="c1"&gt;//% This is a test project,&lt;/span&gt;
&lt;span class="c1"&gt;//% it&amp;#39;s a increase counter module 256.&lt;/span&gt;
&lt;span class="c1"&gt;//%&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;mycounter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;
 &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Port Declaratiosn&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//% clock signal&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//% reset siganl, active high&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//% count result&lt;/span&gt;

&lt;span class="c1"&gt;// Main Body of Code&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;8&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#vhdlblocks"&gt;doxygen manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ewa/doxverilog/tree/master/Doxverilog2.7"&gt;doxverilog&lt;/a&gt;&lt;/p&gt;</summary><category term="doxygen"></category><category term="doxverilog"></category><category term="verilog"></category></entry><entry><title>利用 Graphviz 画 FSM 状态图</title><link href="http://guqian110.github.io/pages/2015/01/20/drawing_fsm_state_diagram_using_graphviz.html" rel="alternate"></link><updated>2015-01-20T17:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-01-20:pages/2015/01/20/drawing_fsm_state_diagram_using_graphviz.html</id><summary type="html">&lt;h2&gt;Graphviz&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Graphviz 是一个由AT&amp;amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Graphviz"&gt;wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Graphviz (short for Graph Visualization Software) is a package of open-source tools initiated by AT&amp;amp;T Labs Research for drawing graphs specified in DOT language scripts. It also provides libraries for software applications to use the tools. Graphviz is free software licensed under the Eclipse Public License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据介绍，我们知道 Graphviz 基于一种叫做 DOT 的图形描述语言，Graphviz 由一组可以处理 DOT 文件的工具组成，最终生成图形。&lt;/p&gt;
&lt;p&gt;既然是画图，那么问题就来了：很多软件都可以画图，&lt;strong&gt;为什么偏偏要用 Graphviz 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不用鼠标绘制，也不用手动调整坐标。使用 Visio 或者其他的画图工具的人都体验过手动对齐的不便，而且很多时候手动调整根本就对不齐，强迫症患者心中永远的痛 T_T&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改更新方便。手绘的图修改起来很麻烦，而使用 DOT 语言的话，只需要修改脚本就 Ok 了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 的缺点：要想用好，需要投入时间和精力去学习使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Graphviz 可以帮助我们画数据结构图、模块图、流程图等，是程序猿的画图利器。这里我们只用它来画简单的 流程图 / 状态图 ，所以只要有基本的图论知识，不涉及高级主题，所以学习起来是很轻松的。&lt;/p&gt;
&lt;p&gt;因为在&lt;a href="http://guqian110.github.io/pages/2015/01/11/how_to_analyse_code_elegantly.html"&gt;前面一篇博客&lt;/a&gt;中我们已经简单介绍了 &lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt; 这个工具软件的安装方法，所以下面直接进入正题：&lt;strong&gt;如何使用 Graphviz 画 FSM 的状态转移图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;下面的内容是我精简出来了的最小学习方法，使用方法的详细攻略请看 Graphviz 官网上的 &lt;a href="http://www.graphviz.org/Documentation.php"&gt;Documentation&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;DOT&lt;/h3&gt;
&lt;p&gt;DOT 语法在 &lt;a href="http://www.graphviz.org/Documentation.php"&gt;Documentation&lt;/a&gt; 里面有介绍，它的定义方法和 C/C++ 中的 &lt;code&gt;struct&lt;/code&gt; 类似。由图论的基本知识，我们知道描述一个图，只要用节点（&lt;code&gt;node&lt;/code&gt;)、边（&lt;code&gt;edge&lt;/code&gt;） 这两个要素就能描述清楚，而 DOT 语言也就是利用这两个信息来描述一个图的。下面用几个基本的例子来说明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由 3 个节点组成的一个无向图。
脚本（example1.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;graph&lt;/span&gt; &lt;span class="n"&gt;example1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;node1&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;node2&lt;/span&gt;
    &lt;span class="n"&gt;node2&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;node3&lt;/span&gt;
    &lt;span class="n"&gt;node3&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;node4&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example1" src="/images/drawing-fsm-state-diagram-using-graphviz/example1.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是上面的例子，不过修改为有向图。&lt;/p&gt;
&lt;p&gt;脚本（example2.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;digraph&lt;/span&gt; &lt;span class="n"&gt;example2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;node1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node2&lt;/span&gt;
    &lt;span class="n"&gt;node2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node3&lt;/span&gt;
    &lt;span class="n"&gt;node3&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nod31&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example2" src="/images/drawing-fsm-state-diagram-using-graphviz/example2.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们还可以控制 node 的属性（节点形状、颜色、边箭头的形状等），来产生不同的结果。&lt;/p&gt;
&lt;p&gt;脚本（example3.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;digraph&lt;/span&gt; &lt;span class="n"&gt;example3&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;node1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node2&lt;/span&gt;
    &lt;span class="n"&gt;node2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node3&lt;/span&gt;
    &lt;span class="n"&gt;node3&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node1&lt;/span&gt;

    &lt;span class="n"&gt;node1&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;circle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;state1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fillcolor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;#123456&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;filled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;node2&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;triangle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;state2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fillcolor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;#345678&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;filled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;node3&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;state3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fillcolor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;#567890&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;unfilled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example3" src="/images/drawing-fsm-state-diagram-using-graphviz/example3.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的结果和我们的状态转移图相比，还差一点就是转移箭头边上的标注，我们可以在 edge 后面加上 &lt;code&gt;label&lt;/code&gt; 属性来标注信息。&lt;/p&gt;
&lt;p&gt;脚本（example4.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;digraph&lt;/span&gt; &lt;span class="n"&gt;example4&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;node1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node2&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;condition1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;node2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node3&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;condition2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;node3&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node1&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;condition3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example4" src="/images/drawing-fsm-state-diagram-using-graphviz/example4.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的 4 个例子就足够我们画 FSM 的状态转移图了。更加详细的说明参考官方文档和一篇文章：&lt;a href="http://www.openfoundry.org/en/foss-programs/8820-graphviz-"&gt;Graphviz - 用指令來畫關係圖吧！&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Command&lt;/h3&gt;
&lt;p&gt;Graphviz 的命令格式为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cmd&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，cmd 可以是它包含的几个工具 &lt;code&gt;dot&lt;/code&gt;、&lt;code&gt;neato&lt;/code&gt;、&lt;code&gt;circo&lt;/code&gt;、&lt;code&gt;fdp&lt;/code&gt;、&lt;code&gt;osage&lt;/code&gt;、&lt;code&gt;sfdp&lt;/code&gt;、&lt;code&gt;twopi&lt;/code&gt;，我们可以查看 man &lt;cmd&gt; 来看它们的区别，也可以直接运行看结果中的区别。&lt;/p&gt;
&lt;p&gt;其中，flags 可以设置相关属性，比如 &lt;code&gt;-Tformat&lt;/code&gt;，如果我们需要产生 PNG 图片，那么这里就应该是 &lt;code&gt;-Tpng&lt;/code&gt;；再比如 &lt;code&gt;-o&lt;/code&gt; 设置输出目的地。&lt;/p&gt;
&lt;p&gt;所以我们上面 example1 的命令格式为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dot&lt;/span&gt; &lt;span class="n"&gt;example1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Tpng&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;exampl1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;png&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;example2，example3，exampl4 同理。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;下面是实际程序中的一个例子：&lt;/p&gt;
&lt;p&gt;dot 脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;digraph&lt;/span&gt; &lt;span class="n"&gt;fsm&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                                                               
       &lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;d&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;d&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;d&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;e&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;d&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1/1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;e&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;e&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1/1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1/1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;g&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;g&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="s"&gt;&amp;quot;g&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1/1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 dot 生成的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fsm_dot" src="/images/drawing-fsm-state-diagram-using-graphviz/fsm_dot.png" /&gt;&lt;/p&gt;
&lt;p&gt;使用 circo 生成的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fsm_circo" src="/images/drawing-fsm-state-diagram-using-graphviz/fsm_circo.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/aix/library/au-aix-graphviz/"&gt;使用 Graphviz 生成自动化系统图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.openfoundry.org/en/foss-programs/8820-graphviz-"&gt;Graphviz - 用指令來畫關係圖吧！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.163.com/prevBlogPerma.do?host=lockriver&amp;amp;srl=487232242010101761749383&amp;amp;mode=prev"&gt;Graphviz使用简介(中文乱码的问题)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://gary-digital.blogspot.com/2006/08/dot.html"&gt;使用DOT來描述你的狀態機&lt;/a&gt;&lt;/p&gt;</summary><category term="fsm"></category><category term="graphviz"></category></entry><entry><title>基于 Doxygen 的 C++ 注释风格</title><link href="http://guqian110.github.io/pages/2015/01/13/doxygen_cpp_comment_style.html" rel="alternate"></link><updated>2015-01-13T18:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-01-13:pages/2015/01/13/doxygen_cpp_comment_style.html</id><summary type="html">&lt;p&gt;本文内容参考自网上博客内容&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/czyt1988/article/details/8901191"&gt;C++标准注释原则 - 基于doxygen的C++注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_6294abe701012pee.html"&gt;Doxygen C++注释规范及生成帮助文档配置步骤&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ticktick.blog.51cto.com/823160/188674"&gt;Doxygen详细介绍（三）（Doxygen注释风格）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重新整理排版了一下。写本文的主要目的是备忘，当作快速参考来查。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Doxygen&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;若想用 Doxygen 生成漂亮的文档，我们必须在以下几个地方添加 Doxygen 风格的注释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文件头（包括 头文件 .h 和 源文件 .cpp）&lt;/p&gt;
&lt;p&gt;主要用于版权声明，描述本文件的功能，以及作者、版本信息等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的定义&lt;/p&gt;
&lt;p&gt;主要用于描述类的功能，同时也可以包含使用方法、注意事项的 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的成员变量定义&lt;/p&gt;
&lt;p&gt;对该成员变量进行 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的成员函数定义&lt;/p&gt;
&lt;p&gt;对该成员函数的功能进行 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数实现&lt;/p&gt;
&lt;p&gt;对函数的功能、参数、返回值、需要注意的问题、相关说明等进行 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;C++ Comment Style&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Doxygen 支持多种注释风格，比如 JavaDoc-like 风格，Qt 风格等。在写 C++ 代码时，我们应该遵守 C++ 的行注释风格，所谓行注释风格，是指一般 C++ 程序员避免使用 C 风格的注释符号 &lt;code&gt;/* */&lt;/code&gt;，而是使用 3 个连续的 &lt;code&gt;/&lt;/code&gt; 作为注释的开头。除了这个区别之外，其他部分和 JavaDoc 风格类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个对象的 brief description 用单行的 &lt;code&gt;///&lt;/code&gt; 开始，并且写在代码前面。一般 brief 写在头文件中，对象的声明之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个对象的 detailed description 用多于两行的 &lt;code&gt;///&lt;/code&gt; 开始，并且写在代码前面。如果注释长度不足两行，第二行的开头仍要写出。一般 detailed 写在源文件中，对象的定义之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一段代码既是声明也是定义，则 brief 和 detailed 写在一起。使用 &lt;code&gt;\brief&lt;/code&gt; 命令，并且使用空行将两者分开。一般 brief 写在头文件中，对象的声明之前。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 line at least.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是代码模板：&lt;/p&gt;
&lt;h3&gt;License&lt;/h3&gt;
&lt;p&gt;使用 DoxygenToolKit 自动生成的 Lisence 即可。&lt;/p&gt;
&lt;h2&gt;File header&lt;/h2&gt;
&lt;hr /&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \file file_name.h&lt;/span&gt;
&lt;span class="c1"&gt;/// \brief Head file for class Ctest.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed file description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \author author_name&lt;/span&gt;
&lt;span class="c1"&gt;/// \version version_number&lt;/span&gt;
&lt;span class="c1"&gt;/// \date xxxx-xx-xx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Namespace&lt;/h3&gt;
&lt;p&gt;namespace 的注释方式：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \brief A brief namespace description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed namespace description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Class&lt;/h3&gt;
&lt;p&gt;class 的定义和声明都在头文件中，所以使用下面这种 brief 和 detailed 结合的方式：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \brief A brief class description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed calss description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h4&gt;member function&lt;/h4&gt;
&lt;p&gt;对于成员函数，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若是在头文件的声明处，使用 brief&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是在源文件的定义处，使用 detailed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是在头文件处，声明和定义重合，使用 brief + detailed&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;member variable&lt;/h4&gt;
&lt;p&gt;对于成员变量，在行末使用 &lt;code&gt;///&amp;lt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;Function&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;brief:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单行的 &lt;code&gt;///&lt;/code&gt; 注释：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// A brief function description.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;detailed:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至少两行 &lt;code&gt;///&lt;/code&gt; 的注释：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// This is the detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;在 detailed description 中还可以添加一些 &lt;code&gt;structural command&lt;/code&gt;，常用的有 &lt;code&gt;\param&lt;/code&gt;、&lt;code&gt;\return&lt;/code&gt;、&lt;code&gt;\see&lt;/code&gt;、&lt;code&gt;\note&lt;/code&gt;、&lt;code&gt;\warning&lt;/code&gt; 等：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// This is the detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p1 Brief description for p1&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p2 Brief description for p2&lt;/span&gt;
&lt;span class="c1"&gt;/// \return Brief description for return value&lt;/span&gt;
&lt;span class="c1"&gt;/// \note something to note.&lt;/span&gt;
&lt;span class="c1"&gt;/// \warning Warning.&lt;/span&gt;
&lt;span class="c1"&gt;/// \see See-also&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;brief + detailed:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果函数声明和定义重合，则 brief 和 detailed 合在一起，并且使用 &lt;code&gt;\brief&lt;/code&gt; 命令，格式如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \brief A brief function description.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p1 Description for p1.&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p2 Description for p2.&lt;/span&gt;
&lt;span class="c1"&gt;/// \return Description for return value.&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;在 Doxgyen 的 manual 里面有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike most other documentation systems, doxygen also allows you to put the documentation of members (including global functions) in front of the definition. This way the documentation can be placed in the source file instead of the header file. This keeps the header file compact, and allows the implementer of the members more direct access to the documentation. As a compromise the brief description could be placed before the declaration and the detailed description before the member definition.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Doxygen 允许注释出现在对象的定义之前，所以我们可以将注释写在源文件中，而不是头文件中。这样做的好处是使头文件更加紧凑、代码的实现者阅读起来也更加直观。所以我们采用的方案是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在函数声明前写 brief，在函数定义前写 detailed。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 inline 函数，使用 brief，尽量保持简洁，不要多于一行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Variable&lt;/h3&gt;
&lt;p&gt;变量一般使用 &lt;code&gt;///&amp;lt;&lt;/code&gt; 方式即可：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; brief description for variable m_a&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;m_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;///&amp;lt; brief description for variable m_b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;如果需要进行详细描述，则采用类似函数注释的方法（brief + detailed）：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;m_c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Enum &amp;amp; Struct&lt;/h3&gt;
&lt;p&gt;类似于 Variable 的注释方式：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Tenum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;em_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; enum value em_1&lt;/span&gt;
    &lt;span class="n"&gt;em_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; enum value em_2&lt;/span&gt;
    &lt;span class="n"&gt;em_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; enum value em_3&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;emVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; enum variable.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Others&lt;/h3&gt;
&lt;p&gt;TODO 命令：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \todo Task1 to do&lt;/span&gt;
&lt;span class="c1"&gt;/// \todo Task2 to do&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;BUG 命令：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// \bug Bug1 to be fixed&lt;/span&gt;
&lt;span class="c1"&gt;/// \bug Bug2 to be fixed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从网上找到一个Doxygen for C 的示例：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://fnch.users.sourceforge.net/doxygen_c.html"&gt;Doxygen usage example (for C)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有一些注释方法很有借鉴意义，可以当作模板来用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.P.S&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又找到一份注释规范的文档，写的挺好，值得一看。&lt;/p&gt;
&lt;p&gt;&lt;a href="/file/cpp_comment_standard.doc"&gt;C++注释规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;</summary><category term="C++"></category><category term="comment style"></category></entry><entry><title>学习 Vim 插件 DoxygenToolKit.vim</title><link href="http://guqian110.github.io/pages/2015/01/12/learning_vim_doxygentoolkit.html" rel="alternate"></link><updated>2015-01-12T15:21:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-01-12:pages/2015/01/12/learning_vim_doxygentoolkit.html</id><summary type="html">&lt;p&gt;&lt;a href="http://guqian110.github.io/pages/2015/01/11/how_to_analysize_code_elegantly.html"&gt;前面一篇博客&lt;/a&gt;已经介绍过 Doxygen 了，Doxygen 的确是一个非常给力的工具，但是为了生成文档，我们必须在注释上花费很大的时间和精力。&lt;/p&gt;
&lt;p&gt;那么问题又来了：&lt;strong&gt;如何才能既享受 Doxygen 的强大功能，同时又避免大量的重复性的注释内容？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决思路： 让编辑器来替我们写那些格式和内容固定的部分，我们只负责写真正的有效内容。&lt;/p&gt;
&lt;p&gt;所以，答案就是：&lt;strong&gt;Vim + DoxygenToolKit.vim 插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;DoxygenToolKit&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;DoxygenToolKit 是 Vim 的一款插件，用它可以很方便地添加 Doxygen 风格的注释，可以节省大量时间和精力，提高写代码的效率。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=987"&gt;DoxygenToolKit Official Website&lt;/a&gt; 官网上介绍，目前定义了 5 个功能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen license comment.  The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen author skeleton.  The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen comment skeleton for a C, C++ or Python function or class, including @brief, @param (for each named argument), and @return. The tag  text as well as a comment block header and footer are configurable. (Consequently, you can have \brief, etc. if you wish, with little effort.) &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ignore code fragment placed in a block defined by #ifdef ... #endif (C/C++).  The  block name must be given to the function. All of the corresponding blocks 
in all the file will be treated and placed in a new block DOX_SKIP_BLOCK (or any other name that you have configured).  Then you have to update PREDEFINED value in your doxygen configuration file with correct block name. You also have to set ENABLE_PREPROCESSING to YES. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generate a doxygen group (begining and ending). The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;如果我们使用 Vundle 管理插件，安装步骤就非常简单了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 Vundle 中加入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 Vim，输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vundle 会自动完成安装 :-D&lt;/p&gt;
&lt;h3&gt;Configuration for c++&lt;/h3&gt;
&lt;p&gt;我们有两种方法可以修改设置，方法一是直接在 DoxygenToolKit.vim 脚本文件中修改相关变量；方法二是在 ~/.vimrc 里面修改。显然方法二更加好一点，因为如果用方法一直接改原脚本，可能还得保存备份才能恢复默认值。&lt;/p&gt;
&lt;p&gt;因为平时写的 C++ 程序比较多，所以针对&lt;a href="http://blog.csdn.net/czyt1988/article/details/8901191"&gt;基于 Doxygen 的 C++ 注释风格&lt;/a&gt;，我们需要进行以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中我特别配置了以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_briefTag_funcName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;yes&amp;quot;&lt;/span&gt;

    &lt;span class="s"&gt;&amp;quot; for C++ style, change the &amp;#39;@&amp;#39; to &amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_commentType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C++&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_briefTag_pre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;brief &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_templateParamTag_pre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;tparam &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_paramTag_pre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;param &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_returnTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;return &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_throwTag_pre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;throw &amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; @exception is also valid&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_fileTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;file &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_dateTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;date &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_authorTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;author &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_versionTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;version &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_blockTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;name &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_classTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;class &amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_authorName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Qian Gu, guqian110@gmail.com&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;doxygen_enhanced_color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;let g:load_doxygen_syntax = 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使前一步中设置了 C++ 风格，但是生成的 Lisence 仍然是 &lt;code&gt;//&lt;/code&gt;，而不是我们想要的 &lt;code&gt;///&lt;/code&gt;，所以我们还需要修改原脚本（line 362~363）为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolKit_startCommentBlock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/// &amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolKit_interCommentBlock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/// &amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Usage&lt;/h3&gt;
&lt;p&gt;官网上也给出了使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;License&lt;/p&gt;
&lt;p&gt;将光标放在需要生成 License 的地方，然后输入命令 &lt;code&gt;:DoxLic&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Author&lt;/p&gt;
&lt;p&gt;将光标放在合适的地方，然后输入命令 &lt;code&gt;:DoxAuthor&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function / Class&lt;/p&gt;
&lt;p&gt;将光标放在 function 或者 class 的名字所在的一行，然后输入命令 &lt;code&gt;:Dox&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ignore code fragment (C/C++ Only)&lt;/p&gt;
&lt;p&gt;如果想忽略调试部分的代码，那么只需要执行命令 &lt;code&gt;:DoxUndoc(DEBUG)&lt;/code&gt; 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Group&lt;/p&gt;
&lt;p&gt;输入命令 &lt;code&gt;DoxBlock&lt;/code&gt; 来插入一个注释块&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了方便使用，我们可以自定义一些 map，省去输入命令的繁琐。&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;同样是官网上的例子：&lt;/p&gt;
&lt;p&gt;假设有个函数如下&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; 
&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;mychar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;myint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;myarray&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DEFAULT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//... &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;那么执行 &lt;code&gt;:Dox&lt;/code&gt; 命令之后会生成以下内容&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;* @brief &lt;/span&gt;
&lt;span class="cm"&gt;* &lt;/span&gt;
&lt;span class="cm"&gt;* @param mychar &lt;/span&gt;
&lt;span class="cm"&gt;* @param myint &lt;/span&gt;
&lt;span class="cm"&gt;* @param myarray &lt;/span&gt;
&lt;span class="cm"&gt;* @param mask &lt;/span&gt;
&lt;span class="cm"&gt;* &lt;/span&gt;
&lt;span class="cm"&gt;* @return &lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=987"&gt;DoxygenToolKit.vim&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="Vim"></category><category term="DoxygenToolKit"></category></entry><entry><title>如何优雅的分析代码</title><link href="http://guqian110.github.io/pages/2015/01/11/how_to_analyse_code_elegantly.html" rel="alternate"></link><updated>2015-01-11T18:49:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-01-11:pages/2015/01/11/how_to_analyse_code_elegantly.html</id><summary type="html">&lt;p&gt;当我们来接手一个别人的工程时，阅读别人的代码是一件很痛苦的事。成千上百的函数，糟糕的代码风格，不知所云的注释，这些都是让人抓狂。那么，问题就来了：&lt;strong&gt;如何优雅地分析别人的代码？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案就是：&lt;strong&gt;Doxygen + Graphviz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个工作流程很简单，我们在写程序时按照 Doxygen 约定的格式注释代码（不注释也可以），Doxygen 会对代码进行分析，然后列出程序中的变量、类定义、数据结构、函数表用关系等，然后调用 Graphviz 将结果用图形化的形式表现出来。&lt;/p&gt;
&lt;p&gt;这个功能在自动生成文档、代码分析时非常强大，下面分别简单介绍一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Linux 环境下，Vim 有插件 &lt;strong&gt;DoxygenToolKIt.vim&lt;/strong&gt; 可以帮助我们很方便地写出 Doxygen 风格的代码。这里只介绍 Doxygen + Graphviz，DoxygenToolKit.vim 在另外一篇中介绍。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Graphviz&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;What is Graphviz?&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.graphviz.org/"&gt;Graphviz official website&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Graphviz is open source graph visualization software. Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. It has important applications in networking, bioinformatics,  software engineering, database and web design, machine learning, and in visual interfaces for other technical domains. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;官方网站上有各个平台（Windows/Unix/Linnux/Mac）的安装文件和源码，在 Ubuntu 13.10 saucy 下，直接使用 apt-get 安装即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;graphviz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;More&lt;/h3&gt;
&lt;p&gt;更多详细的介绍见官网的 About、Documentation、Wiki、FAQ。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Doxygen&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;What is Doxygen&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen Official website&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Doxygen is the de facto standard tool for generating documentation from annotated C++ sources, but it also supports other popular programming languages such as C, Objective-C, C#, PHP, Java, Python, IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, VHDL, Tcl, and to some extent D.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。只要我们在写注释的时候按照它制定的规则写，那么它就可以为我们生成漂亮的文档。&lt;/p&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;官网上的 Manual 中有详细的介绍，对于不同平台，采用不同的安装方式（从源码编译安装、二进制文件安装），下面仅记录我在 Ubuntu 下使用源码编码的方式安装过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载源代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/doxygen/doxygen.git&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;doxygen&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装成功之后，在 &lt;code&gt;/usr/bin/&lt;/code&gt; 或者 &lt;code&gt;/usr/local/bin&lt;/code&gt; 目录下可以查看到二进制 &lt;code&gt;doxygen&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若 configure 出错，检查依赖关系，安装需要系统中有 GNU 工具（flex, bison, libiconv and GNU make, and strip）和 Perl 支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 Doxygen 要调用 Graphviz，所以先安装 Graphviz，然后编译安装 Doxygen&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Getting Started&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/starting.html"&gt;Getting Started&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查 Doxygen 是否支持你项目所使用的语言&lt;/p&gt;
&lt;p&gt;Doxygen 支持  C, C++, C#, Objective-C, IDL, Java, VHDL, PHP, Python, Tcl, Fortran, D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个配置文件&lt;/p&gt;
&lt;p&gt;Doxygen 使用一个配置文件来工作，，每个项目都应该有一个自己对应的配置文件。我们可以使用 &lt;code&gt;doxygen -g&lt;/code&gt; 来让 Doxygen 自动生成一个参考配置文件，然后修改其中个别配置即可.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;doxygen&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;常用配置：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PROJECT_NAME = "Test Project"&lt;/code&gt; 配置项目名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PROJECT_NUMBER = 1.0&lt;/code&gt; 配置项目版本号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUTPUT_DIRECTORY = ./doxygen-output&lt;/code&gt; 配置输出结果目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OPTIMIZE_OUTPUT_FOR_C = YES&lt;/code&gt; 设置针对哪种语言进行优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;EXTRACT_ALL = YES&lt;/code&gt; 默认是 &lt;code&gt;NO&lt;/code&gt;，即默认只对有标准注释的文件进行分析。如果我们希望对一个没有按照标准格式注释的项目进行分析，那么就要改为 &lt;code&gt;YES&lt;/code&gt;，这在接手一个旧项目，分析代码时尤其有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HAVE_DOT = YES&lt;/code&gt; 设置 Doxygen 调用 dot 工具（graphviz 的一部分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DOT_PATH = /usr/local/graphviz&lt;/code&gt; 指定 graphviz 的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 Doxygen&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;doxygen&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果前一步没有指定配置文件的名字的话，直接运行 &lt;code&gt;doxygen&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;运行完之后，就可以在指定的输出目录中看到结果，用浏览器可以看到 HTML 版本的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照 Doxygen 格式注释代码&lt;/p&gt;
&lt;p&gt;这一步应该在最前面，即先按照 Doxygen 风格格式注释好代码，然后再进行分析。官网上针对不同的编程语言，有详细的举例说明：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#specialblock"&gt;Documenting the code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Documenting the code&lt;/h3&gt;
&lt;p&gt;这部分虽然在最后，事实上应该是第一步，也就是说我们先按照规定添加 Doxygen 风格的注释，然后再配置、调用 Doxygen 来生成文档。&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen 官网&lt;/a&gt;上有详细的注释&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html"&gt;格式说明&lt;/a&gt;，下面是我搬运来学习，自己翻译的。&lt;/p&gt;
&lt;p&gt;我们在 C/C++ 风格注释块中加入一些特殊符号，这样 Doxygen 就知道需要把这段注释分析生成在文档中，这样的注释在官网中叫做 &lt;code&gt;Special comment blocks&lt;/code&gt;。下面详细介绍类 C/C++ 语言（C/C++/C#/Objective-C/PHP/Java）的注释，其他语言（Python, VHDL, Fortran, Tcl）见官网。&lt;/p&gt;
&lt;p&gt;对于代码中的任何实体（&lt;code&gt;entity&lt;/code&gt;），都有两种注释，它们一起工作，完成注释功能，但至少得有一个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a brief description&lt;/code&gt;：单行的简短注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a detailed description&lt;/code&gt;：多行的详细注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 方法 &lt;code&gt;methods&lt;/code&gt; 和 函数 &lt;code&gt;functions&lt;/code&gt;，还有额外的第三种注释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in body description&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于详细注释（detailed description），可以用以下的几种风格来进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JavaDoc Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即在 C 风格注释块开始使用两个星号 &lt;code&gt;*&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* ... text ...&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Qt Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即在 C 风格注释块开始处添加一个叹号 &lt;code&gt;!&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;* ... text ...&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C++ Comment Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用连续两个以上的 C++ 注释行组成注释块，并且每行要多写一个 &lt;code&gt;/&lt;/code&gt; 或者 &lt;code&gt;!&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// ... text ...&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;or&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//!&lt;/span&gt;
&lt;span class="c1"&gt;//! ... text ...&lt;/span&gt;
&lt;span class="c1"&gt;//!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四种格式，有的人喜欢让自己的注释更加醒目一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;/// ... text ...&lt;/span&gt;
&lt;span class="c1"&gt;/////////////////////////////////////////////////&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于简单注释（brief description），也有以下的几种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以选用以上其中一种风格，然后加入 &lt;code&gt;\brief&lt;/code&gt; 命令来标明 brief 的开始。这种方式以段落的结尾作为结束。所以在 brief 后要写 detailed 的话，需要空一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* \brief Brief description.&lt;/span&gt;
&lt;span class="cm"&gt;*         Brief description continued.&lt;/span&gt;
&lt;span class="cm"&gt;*&lt;/span&gt;
&lt;span class="cm"&gt;*  Detailed description starts here.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果选择 JavaDoc 的风格，并且在配置文件中设置 &lt;code&gt;JAVADOC_AUTOBRIEF = YES&lt;/code&gt; 的话，Doxygen 会自动将第一句话作为 brief description，这个句子以 &lt;code&gt;. + 空格/空行&lt;/code&gt; 结束。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** Brief description which ends at this dot. Details follow&lt;/span&gt;
&lt;span class="cm"&gt;*   here.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方式对多行的 C++ 特殊注释风格也有效：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// Brief description which ends at this dot. Details follow&lt;/span&gt;
&lt;span class="c1"&gt;/// here.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三种方法是使用不多于一行的特殊 C++ 风格注释，下面是两个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// Brief description.&lt;/span&gt;
&lt;span class="cm"&gt;/** Detailed description. */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者：（这种情况下，必须用空行把 brief 和 detailed 分开，同时 &lt;code&gt;JAVADOC_AUTOBRIEF = NO&lt;/code&gt;）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//! Brief description.&lt;/span&gt;

&lt;span class="c1"&gt;//! Detailed description &lt;/span&gt;
&lt;span class="c1"&gt;//! starts here.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Doxygen 和其他的文档系统的一个不同之处就是它允许把注释写在实体的定义（包括全局函数）之前。这样，就可以把注释直接写在源文件里面而不是头文件中，从而使头文件更加紧凑，而且功能的实现人员也更容易阅读注释。&lt;strong&gt;所以，一个折衷方案就是在声明前写 brief description，在定义前写 detailed description。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;Putting documentation after members&lt;/h4&gt;
&lt;p&gt;在注释结构体、类、枚举类型等时，有时习惯将注释写在代码的后面，而不是前面。因为 Doxygen 默认注释是解释后面的代码，所以这时候就需要在注释中添加一个额外的 &lt;code&gt;&amp;lt;&lt;/code&gt; 来标明是注释前面的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Qt 风格的注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/*!&amp;lt; Detailed description after the member */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/**&amp;lt; Detailed description after the member */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//!&amp;lt; Detailed description after the member&lt;/span&gt;
         &lt;span class="c1"&gt;//!&amp;lt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一般来说，我们通常在后面添加的注释都是 brief description 而不是 detailed description，所以更常见的格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//!&amp;lt; Brief description after the member&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; Brief description after the member&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种添加 &lt;code&gt;&amp;lt;&lt;/code&gt; 的方法只能用在 成员（&lt;code&gt;member&lt;/code&gt;）和 参数（&lt;code&gt;parameter&lt;/code&gt;）中，不能用在描述文件、类、联合体、名字空间和枚举本身。此外, 在后面提到的结构化命令（如&lt;code&gt;\class&lt;/code&gt;）在这种注释段中是无效的。&lt;/p&gt;
&lt;h4&gt;Examples&lt;/h4&gt;
&lt;p&gt;官网上提供了一个例子，分别用 Qt 和 JavaDoc 的风格注释一段相同的 C++ 代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Qt style:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//!  A test class. &lt;/span&gt;
&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;  A more elaborate class description.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="c1"&gt;//! An enum.&lt;/span&gt;
    &lt;span class="cm"&gt;/*! More detailed enum description. */&lt;/span&gt;
    &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;TEnum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
                 &lt;span class="n"&gt;TVal1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal1. */&lt;/span&gt;  
                 &lt;span class="n"&gt;TVal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal2. */&lt;/span&gt;  
                 &lt;span class="n"&gt;TVal3&lt;/span&gt;  &lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal3. */&lt;/span&gt;  
               &lt;span class="p"&gt;}&lt;/span&gt; 
         &lt;span class="c1"&gt;//! Enum pointer.&lt;/span&gt;
         &lt;span class="cm"&gt;/*! Details. */&lt;/span&gt;
         &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;enumPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
         &lt;span class="c1"&gt;//! Enum variable.&lt;/span&gt;
         &lt;span class="cm"&gt;/*! Details. */&lt;/span&gt;
         &lt;span class="n"&gt;enumVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//! A constructor.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      A more elaborate description of the constructor.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//! A destructor.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      A more elaborate description of the destructor.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
   &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//! A normal member taking two arguments and returning an integer value.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      \param a an integer argument.&lt;/span&gt;
&lt;span class="cm"&gt;      \param s a constant character pointer.&lt;/span&gt;
&lt;span class="cm"&gt;      \return The test results&lt;/span&gt;
&lt;span class="cm"&gt;      \sa Test(), ~Test(), testMeToo() and publicVar()&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;testMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//! A pure virtual member.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      \sa testMe()&lt;/span&gt;
&lt;span class="cm"&gt;      \param c1 the first argument.&lt;/span&gt;
&lt;span class="cm"&gt;      \param c2 the second argument.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;testMeToo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//! A public variable.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      Details.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;publicVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//! A function variable.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      Details.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;生成的 HTML 网页：http://www.stack.nl/~dimitri/doxygen/manual/examples/qtstyle/html/class_test.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaDoc style:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  A test class. A more elaborate class description.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;     * An enum.&lt;/span&gt;
&lt;span class="cm"&gt;     * More detailed enum description.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;TEnum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
          &lt;span class="n"&gt;TVal1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/**&amp;lt; enum value TVal1. */&lt;/span&gt;  
          &lt;span class="n"&gt;TVal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/**&amp;lt; enum value TVal2. */&lt;/span&gt;  
          &lt;span class="n"&gt;TVal3&lt;/span&gt;  &lt;span class="cm"&gt;/**&amp;lt; enum value TVal3. */&lt;/span&gt;  
         &lt;span class="p"&gt;}&lt;/span&gt; 
       &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;enumPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/**&amp;lt; enum pointer. Details. */&lt;/span&gt;
       &lt;span class="n"&gt;enumVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/**&amp;lt; enum variable. Details. */&lt;/span&gt;

      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A constructor.&lt;/span&gt;
&lt;span class="cm"&gt;       * A more elaborate description of the constructor.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
      &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A destructor.&lt;/span&gt;
&lt;span class="cm"&gt;       * A more elaborate description of the destructor.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
     &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * a normal member taking two arguments and returning an integer value.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param a an integer argument.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param s a constant character pointer.&lt;/span&gt;
&lt;span class="cm"&gt;       * @see Test()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see ~Test()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see testMeToo()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see publicVar()&lt;/span&gt;
&lt;span class="cm"&gt;       * @return The test results&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
       &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;testMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A pure virtual member.&lt;/span&gt;
&lt;span class="cm"&gt;       * @see testMe()&lt;/span&gt;
&lt;span class="cm"&gt;       * @param c1 the first argument.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param c2 the second argument.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
       &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;testMeToo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;       * a public variable.&lt;/span&gt;
&lt;span class="cm"&gt;       * Details.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
       &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;publicVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * a function variable.&lt;/span&gt;
&lt;span class="cm"&gt;       * Details.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
       &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;生成的 HTML 网页：http://www.stack.nl/~dimitri/doxygen/manual/examples/jdstyle/html/class_test.html&lt;/p&gt;
&lt;h4&gt;Documentation at other places&lt;/h4&gt;
&lt;p&gt;我们之前的例子中注释都是在文件、命名空间、类的声明或者定义之前，或者在它们的成员的前/后。虽然一般来说这是很正常的，但是有时候我们需要把代码写在在文档的其他地方。对于文件的注释更是如此，因为对于文件来说，根本就不存在在它之前的地方（"in front of a file"）。&lt;/p&gt;
&lt;p&gt;Doxygen 允许你把注释写在任何地方（例外情况是在函数体内 or 在 C 风格注释块内）。你需要付出的代价就是要在注释块内部多写一些结构化命令（&lt;code&gt;structural command&lt;/code&gt;）来标明。所以，&lt;strong&gt;一般来说，我们应该尽量避免使用结构化命令，除非是有其他的特殊要求这样做。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结构化命令以一个 &lt;code&gt;\&lt;/code&gt; 或者 &lt;code&gt;@&lt;/code&gt;（JavaDoc 风格）开始，后面接一个命令名字 + 一个（多个）参数。举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*! \class Test&lt;/span&gt;
&lt;span class="cm"&gt;    \brief A test class.&lt;/span&gt;

&lt;span class="cm"&gt;    A more detailed class description.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子中的 &lt;code&gt;\class&lt;/code&gt; 指示这个注释块中包含一个 Test 类的文档。其他常用的命名如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\structure&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\union&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;emun&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fn&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;def&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\typedef&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\file&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\namespace&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\package&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\interface&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的命令和说明在这里：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/commands.html"&gt;special commands&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对 C++ 类成员进行注释的时候，必须先注释这个类，对于命名空间来说也是如此。对 C 的全局函数、 typedef、enum、 preprocessor definition 进行注释，必须先注释包含它们的文件（通常是头文件）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Attention:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在重复一下容易出错的地方：&lt;strong&gt;在注释全局对象时，必须先注释它们所在的文件。&lt;/strong&gt;也就是说，必须包含以下两者之一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* \file */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* @file */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面是官网上的一个 C 头文件的例子：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*! \file structcmd.h&lt;/span&gt;
&lt;span class="cm"&gt;\brief A Documented file.&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \def MAX(a,b)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief A macro that returns the maximum of \a a and \a b.&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \var typedef unsigned int UINT32&lt;/span&gt;
&lt;span class="cm"&gt;    \brief A type definition for a .&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \var int errno&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Contains the last error code.&lt;/span&gt;
&lt;span class="cm"&gt;    \warning Not thread safe!&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int open(const char *pathname,int flags)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Opens a file descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param pathname The name of the descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param flags Opening flags.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int close(int fd)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Closes the file descriptor \a fd.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to close.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn size_t write(int fd,const char *buf, size_t count)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Writes \a count bytes from \a buf to the filedescriptor \a fd.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to write to.&lt;/span&gt;
&lt;span class="cm"&gt;    \param buf The data buffer to write.&lt;/span&gt;
&lt;span class="cm"&gt;    \param count The number of bytes to write.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int read(int fd,char *buf,size_t count)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Read bytes from a file descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to read from.&lt;/span&gt;
&lt;span class="cm"&gt;    \param buf The buffer to read into.&lt;/span&gt;
&lt;span class="cm"&gt;    \param count The number of bytes to read.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cp"&gt;#define MAX(a,b) (((a)&amp;gt;(b))?(a):(b))&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;UINT32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="nf"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;上面这个例子中的每个注释块都包含了一条结构化命令，所以这些注释可以放在文件的其他位置或者放在其他文件中，不会影响到最终生成的文档。这种方法的坏处在于我们实际上写了两遍原型，当做修改时我们必须同时修改代码和注释。因此，我们在使用前应该仔细考虑是否真的需要结构化命令，并且尽可能避免使用它。一个常见的现象就是在函数前的注释块中包含了 &lt;code&gt;\fn&lt;/code&gt; 命令，显然这是冗余的，除了导致错误，这个命令毫无作用。&lt;/p&gt;
&lt;p&gt;如果我们对以 .dox, .txt, .doc 结尾的文件注释，那么 Doxygen 会自动忽略这些文件。&lt;/p&gt;
&lt;p&gt;如果我们有一个 Doxygen 无法解析的文件，但是仍然像注释它，那么就使用 &lt;code&gt;\verbinclude&lt;/code&gt; 这个命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*! \file myscript.sh&lt;/span&gt;
&lt;span class="cm"&gt;*   Look at this nice srcipt.&lt;/span&gt;
&lt;span class="cm"&gt;*  \verbinlcude mycript.sh&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还要确定在配置文件中 &lt;code&gt;INPUT&lt;/code&gt; 变量显式地说明这个脚本文件，或者 &lt;code&gt;FILE_PATTERNS&lt;/code&gt; 变量必须包含&lt;code&gt;.sh&lt;/code&gt; 文件扩展名并且可以通过 &lt;code&gt;EXAMPLE_PATH&lt;/code&gt; 变量寻找到这个文件。&lt;/p&gt;
&lt;h4&gt;Anatomy of a comment block&lt;/h4&gt;
&lt;p&gt;前面介绍了如何对代码进行注释，并且讨论了两种不同的注释：brief 和 detailed，还讨论了如何使用结构化命令。&lt;/p&gt;
&lt;p&gt;下面我们分析注释块本身。&lt;/p&gt;
&lt;p&gt;Doxygen 支持很多种格式的注释，最简单的就是文本文件，适用于比较短的注释。对于比较长的注释，我们需要清单、表格等更加结构化的元素，对于这种情况，Doxygen 支持 Markdown 语法，可以直接读取 Markdown 文件，详细内容看这里：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/markdown.html"&gt;Markdown Support&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;(Markdown 源自邮件的文本格式，语法非常简洁，并且功能很强大，这篇文章本书就是用 Markdown 语法写的，语法细节见官网，这里不再赘述。)&lt;/p&gt;
&lt;p&gt;P.S.&lt;/p&gt;
&lt;p&gt;找到一篇博客，详细介绍了基于 Doxygen 的 C++ 注释风格：&lt;a href="http://blog.csdn.net/czyt1988/article/details/8901191"&gt;C++标准注释原则 - 基于doxygen的C++注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;最后展示一张我的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/how-to-analyse-code-elegantly/result.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Ref.&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/blood008/article/details/6567169"&gt;linux doxygen 的安装和使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/wishma/archive/2008/07/24/1250339.html"&gt;doxygen 使用简介（C,C++为代码作注释）&lt;/a&gt;&lt;/p&gt;</summary><category term="doxygen"></category><category term="code"></category></entry><entry><title>LTE 咬尾卷积编码器的 Matlab 、C 语言及 FPGA 实现</title><link href="http://guqian110.github.io/pages/2015/01/07/tail_bitting_convolutional_code_implementation_in_matlab_and_c_and_fpga.html" rel="alternate"></link><updated>2015-01-07T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-01-07:pages/2015/01/07/tail_bitting_convolutional_code_implementation_in_matlab_and_c_and_fpga.html</id><summary type="html">&lt;h2&gt;Tail Bitting&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;咬尾卷积编码是一种特殊的卷积编码，它通过将编码器的移位寄存器的初始值设置为输入流的尾比特值，使得移位寄存器的初始和最终状态相同。和普通的卷积编码相比，咬尾的方案最大的优点是克服了编码时的码率损失，并且适合迭代译码，不过付出的代价是译码复杂度的增加。在 LTE 的标准中，咬尾卷积编码是一种备选的信道编码方案。&lt;/p&gt;
&lt;p&gt;通常以 (n, k, K) 来描述卷积编码，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 表示编码器的 &lt;em&gt;输入码元数&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 表示编码器的 &lt;em&gt;输出码元数&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;K&lt;/code&gt; 表示编码器的 &lt;em&gt;约束长度&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由输入的 k 个信息比特，得到 n 个编码结果，所以 &lt;em&gt;编码效率&lt;/em&gt; = k/n&lt;/p&gt;
&lt;p&gt;约束长度 &lt;code&gt;K&lt;/code&gt; 的意思是，编码结果不仅取决于当前输入的 k 比特信息，还取决于前 (K-1) 段时间内的信息位。在 k = 1 的条件下，编码器需要的 &lt;em&gt;移位寄存器级数&lt;/em&gt; m = K - 1。&lt;/p&gt;
&lt;p&gt;LTE 标准中编码器的结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="coder" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/coder.jpg" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设输入的比特流为 c1, c2, c3, ... 得到的编码结果为 d1, d2, d3, ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中移位寄存器 D 从左到右一次是 S0, S1, ... S5。对其初始化时，S0 = Ck-1, S1 = Ck-2, ... S5 = Ck-6。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行编码时，有抽头的寄存器之间进行模 2 加法（即异或）运算。每次对一个输入信息完成编码之后，移位寄存器右移一位，抛弃最右端的移位结果，采用前一个输入作为最左端的信息位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当最后的比特进行编码完之后，寄存器又回到了设定的初始状态，就像一条蛇咬住了自己的尾巴，所以称为 咬尾 Tail Bitting。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图中的 G1，G2, G3 是 &lt;em&gt;生成式&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的内容已经提供了足够的信息供我们实现，关于更多的卷积编码、LTE 标准等请查阅 wiki 和专业书籍。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Matlab Implementation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Matlab 的 &lt;code&gt;Communications System Toolbox&lt;/code&gt; 中提供了大量的常用函数，其中就有卷积编码函数 &lt;code&gt;convenc&lt;/code&gt;。我们就是基于这个函数实现LTE中的咬尾卷积编码。&lt;/p&gt;
&lt;p&gt;通过&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和 hlep browser，可以查到这个函数的用法，简单解释如下:&lt;/p&gt;
&lt;p&gt;convenc 函数有几种方式来调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;CODE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MSG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRELLIS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;CODE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MSG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRELLIS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PUNCPAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;CODE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(...,&lt;/span&gt; &lt;span class="n"&gt;INIT_STATE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个参数 &lt;code&gt;MSG&lt;/code&gt; 是待编码的信息比特&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数 &lt;code&gt;TRELLIS&lt;/code&gt; 是编码器的栅格描述&lt;/p&gt;
&lt;p&gt;TRELLIS 是 Matlab 内部定义的一种数据结构，它的值可以按照语法定义，更方便的方法是通过 &lt;code&gt;poly2trellis&lt;/code&gt; 这个函数，由多项式描述方式转化得到。&lt;/p&gt;
&lt;p&gt;查阅 poly2trellis 的 help 就可以看到它的用法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;trellis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;poly2trellis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ConstraintLength&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CodeGenerator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，&lt;code&gt;ConstraintLength&lt;/code&gt; 是个 1×k 维的向量，表示编码器的约束长度；&lt;code&gt;CodeGenerator&lt;/code&gt; 是个 k×n 维的向量，表示编码器中各个寄存器的抽头。&lt;/p&gt;
&lt;p&gt;help 中以一个 2/3 码率的编码器为例，其结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="exmaple" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/example.png" /&gt;&lt;/p&gt;
&lt;p&gt;两组寄存器的长度分别为 4 和 3，所以 constraintlength 的取值为 [5, 4]；将每路输出的抽头用 8 进制来表示，即可得到 codegenerator 的取值 [27, 33, 0; 0, 5, 13]，表示第一路输出由第一组寄存器的 27 组合方式 + 第二组寄存器的 0 组合方式得到，第二路输出由第一组寄存器的 33 组合方式 + 第二组寄存器的 5 组合方式得到，第三路同理。&lt;/p&gt;
&lt;p&gt;应用到我们的编码器中，很容易写出其栅格描述&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;poly2trellis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;133&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;171&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;165&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个参数 INIT_STATE 是移位寄存器的初始值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INIT_STATE&lt;/code&gt; 用来设定寄存器的初始状态，其取值就是寄存器的值。&lt;/p&gt;
&lt;p&gt;在下面的程序中，我们的测试向量的最后 6 bit 为 010110，所以对应的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，可以写出 matlab 程序来实现咬尾卷积编码，如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c"&gt;% using a to test coder&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c"&gt;% describe the coder&lt;/span&gt;
&lt;span class="n"&gt;tre&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;poly2trellis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;133&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;171&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;165&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="c"&gt;% init state is depend on a&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;% encode&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tre&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;得到的编码结果是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;数据的格式是将 3 位并行结果串行输出： d00, d01, d02, d10, d11, d12, ...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;C Implementation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;C 的实现很简单:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;encode_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;coded_bits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;origin_bits_len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// initialize the LSR&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;origin_bits_len&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;origin_bits_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;coded_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;coded_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;coded_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="c1"&gt;// shift the regs&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;Verlog Implementation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;用 verilog 来实现编码器就相对简单直观的多，毕竟只有一组移位寄存器和一些抽头的异或运算。&lt;/p&gt;
&lt;h3&gt;module &amp;amp; testbench&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tbce.v"&gt;module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tb_tbce.v"&gt;testbench&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;simulation&lt;/h3&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim1" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/sim1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim2" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/sim2.png" /&gt;&lt;/p&gt;
&lt;p&gt;和 matlab 中结果对比，结果是一致的。&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;一个简单的咬尾卷积编码花费了一上午的时间才搞定，最大的收获就是：心态很重要，欲速则不达。没有认真看 help 就写程序，本来想节省时间，结果却相反 =.=&lt;/p&gt;
&lt;p&gt;戒骄戒躁！！！&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/24784764/"&gt;无线通信新协议与新算法&lt;/a&gt;&lt;/p&gt;</summary><category term="tail bitting convolution"></category></entry><entry><title>FPGA 中的延时</title><link href="http://guqian110.github.io/pages/2014/11/23/delay_in_fpgas.html" rel="alternate"></link><updated>2014-11-23T14:03:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-11-23:pages/2014/11/23/delay_in_fpgas.html</id><summary type="html">&lt;h2&gt;Delay in circuits&lt;/h2&gt;
&lt;p&gt;从模拟电路的知识，我们可以知道 &lt;strong&gt;电路中存在很多类型不同的延时。&lt;/strong&gt; 比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;propagation delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们通常假设信号在电平之间变化时瞬间完成的，但是实际情况并不是瞬间完成，电路需要花费一段时间才能完成电平的转化。晶体管的开关特性对于不同的变化有不同的表现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上升延时 (&lt;code&gt;rising delay&lt;/code&gt;)，输出变为 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下降延时 (&lt;code&gt;falling delay&lt;/code&gt;)，输出变为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭延时 (&lt;code&gt;turn-off delay&lt;/code&gt;)，输出变为高阻 Z&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出变为 X 的时延&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因就是（&lt;a href="http://www.amazon.cn/Digital-Design-An-Embedded-Systems-Approach-Using-Verilog-Ashenden-Peter-J/dp/0123695279"&gt;Digital Design (Verilog): An Embedded Systems Approach Using Verilog&lt;/a&gt;）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One factor that causes signal changes to occur over a nonzero time
interval is the fact that the switches in the output stage of a digital component, illustrated in Figure 1.15, do not open or close instantaneously. Rather, their resistance changes between near zero and a very large value over some time interval. However, a more significant factor, especially in CMOS circuits, is the fact that logic gates have a significant amount of capacitance at each input.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个答案也解释了为什么在设计中要避免大扇出信号：因为大扇出意味着输出端并联着很多电容，电容负载较大时造成连接信号转换相对较慢的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The total capacitive load is thus the sum of the individual capacitive loads. The effect is to make transitions on the connecting signal correspondingly slower. For CMOS components, this effect is much more significant than the static load of component inputs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以把对晶体管的讨论推广到其他的数字元件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A similar argument regarding time taken to switch transistors on and off and to charge and discharge capacitance also applies within a digital component. Without going into the details of a component’s circuit, we can summarize the argument by saying that, due to the switching time of the internal transistors, it takes some time for a change of logic level at an input to cause a corresponding change at the output. We call that time the &lt;code&gt;propagation delay&lt;/code&gt;, denoted by &lt;code&gt;tpd&lt;/code&gt;, of the component.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;wire delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外一种延时是信号在导线上传播时产生的延时，一般我们都把这种延时假设也 0，也就是说导线时理想的导体，信号经由导线的传输没有任何延迟。如果导线很短，或者芯片上不超过 1mm 的导线来说，这种假设是合理的。但是当设计高速电路时，不能忽略这种导线存在的寄生电容和电感，这时候导线应该被视为传输线，必须精心设计。&lt;/p&gt;
&lt;p&gt;至于如何设计应该属于模拟电路的部分，这里不讨论。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于上面的两种延时，&lt;a href="http://www.amazon.com/FPGA-Based-System-paperback-Prentice-Semiconductor/dp/0137033486"&gt;FPGA-Based System Design&lt;/a&gt; 里面有详细讨论如何建模、如何计算具体时延的值。&lt;/p&gt;
&lt;p&gt;即使对于同一种信号跳变，延时也分为不同的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最小值 (&lt;code&gt;minimum&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型值 (&lt;code&gt;typical&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大值 (&lt;code&gt;maximum&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Models in Verilog HDL&lt;/h2&gt;
&lt;p&gt;为了对电路中的时延现象进行建模，Verilog HDL 定义了延时语法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于上升、下降、关闭时延，可以使用逗号按照顺序将三者分开：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;A_xor_wire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eq0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;A_xor_wire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eq0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;第一句表示一个异或门上升时延为 1，下降时延为 2，关闭和X时延为两者中的最小值，即 1；&lt;/p&gt;
&lt;p&gt;第二句表示一个异或门的上升、下降、关闭时延分别是 1，2，3，X时延为 3 者中的最小值，即 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于最小值、典型值、最大值可以使用分号按照 min:typ:max 的顺序，将 3 者分开：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;assgin&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;A_xor_wire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eq0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;表示上升时延的 min:typ:max = 2:3:4，下降时延的 min:typ:max = 3:4:5。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意到一点是，&lt;strong&gt;当延时出现在 wire 信号的定义处时，会和普通的赋值语句中的延时稍有不同。&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt; &lt;span class="n"&gt;wireA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这个叫做 &lt;code&gt;net delay&lt;/code&gt;，它是和 wireA 绑定的，对 wireA 进行的任何赋值必须延迟 10 个时间单位之后才有效。当在连续赋值语句中，延时是属于连续赋值语句的一部分，而不属于 net，所以只在这一句中有效，对其他赋值语句没有影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般来说，assign 语句中的延时特性会被综合工具忽略。&lt;/strong&gt;因为综合工具需要完成的功能就是将代码描述映射为逻辑电路，而逻辑电路中的延时是由最基本的单元库和走线延时决定的，用户是无法对逻辑单元指定延时长度的，只能在综合、实现时添加时序约束条件，使工具尽量满足要求。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Implement&lt;/h2&gt;
&lt;p&gt;Verilog HDL 中的延时语法不可综合并不代表就不能在实际电路中实现延时。&lt;/p&gt;
&lt;p&gt;在实际电路中，不同的情况下需要采用不同的方法来实现延时：一般来说，异步电路的时延通过门延时来完成，比较难预测，而同步电路的时延通过触发器或者计数器来实现。&lt;/p&gt;
&lt;h3&gt;in ASICs&lt;/h3&gt;
&lt;p&gt;在早期的逻辑电路图设计阶段，有且设计者养成了手工加入 Buffer 或者非门调整数据
延时的习惯，以保证本级模块的时钟对上级模块数据的建立及保持时间的要求。这些做法目
前主要应用于两种场合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分离电路&lt;/p&gt;
&lt;p&gt;使用分立逻辑单元（如 74 系列）搭建数字电路一般为复杂度比较低、系统灵活性比较低的场合。使用分立元件时，由于可以使用的元件比较少，而且一般设计频率比较低，时序裕量比较大，所以采用 Buffer、非门等单元来调整时延时可以接受的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ASIC 领域&lt;/p&gt;
&lt;p&gt;在 ASIC 中采用这种方法，是以严格的仿真和时序约束为前提的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;in FPGAs&lt;/h3&gt;
&lt;p&gt;在 ASIC 中采用的添加 Buffer、非门的设计方法并不适合 FPGA/CPLD 等可编程逻辑，在 FPGA 中应该尽量避免这种设计。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Delay chains occur when two or more consecutive nodes with a single fan-in and a single fan-out are used to cause delay. Often inverters are chained together to add delay. Delay chains generally result from asynchronous design practices, and are sometimes used to resolve race conditions created by other combinational logic. In both FPGA and ASIC, delays can change with each place-and-route. Delay
chains can cause various design problems, including an increase in a design’s sensitivity to operating conditions, a decrease in a design’s reliability, and difficulties when migrating to different device architecture. &lt;strong&gt;Avoid using delay chains in a design, rely on synchronous practices instead.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结下来主要就是 3 个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计的可靠度低&lt;/p&gt;
&lt;p&gt;Buffer、非门都是组合逻辑，组合逻辑最大的问题就是容易出现毛刺，电路可靠度不高，这种方法的时序裕量小，对环境敏感（特别是温度），一旦外界环境发生变化，时序可能就会完全紊乱、导致电路瘫痪。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计的移植难度大&lt;/p&gt;
&lt;p&gt;一旦芯片换代，或者需要将设计移植到不同的器件上时，就必须对延时进行重新调整，电路的可维护性和扩展性差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号通过多级非门时，综合器可能会将其优化掉。&lt;/p&gt;
&lt;p&gt;虽然可以在代码中添加约束，防止综合器将其优化掉，但是不推荐这种方法，理由见前两条。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Xilinx-FPGA%E9%AB%98%E7%BA%A7%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%B1%A4%E7%90%A6/dp/B007TLVUT8"&gt;Xilinx FPGA高级设计及应用&lt;/a&gt; 介绍了 FPGA 中应该采用的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;专门的延时器件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 FPGA/CPLD 内部延时电路结构由一种标准的宏单元描述。虽然各家芯片的宏单元描述不同，但总的来说都是 &lt;strong&gt;一些逻辑 + 一个/两个触发器构成&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Altera FPGA 中可以对信号加一个或多个 LCELL 来产生一个延时。（Xilinx 的没有查到...）&lt;/p&gt;
&lt;p&gt;虽然厂家提供了延时单元，但是这种延时并不稳定，会随着外界环境（比如温度）的变化而变化，所以并不提倡这种方法。&lt;/p&gt;
&lt;p&gt;网上有人讨论这种方法的应用：&lt;a href="http://bbs.eccn.com/viewthread.php?tid=181856"&gt;fpga内部的延时单元&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;触发器 or 计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果延时相对较小，可以使用高频时钟来驱动一个移位寄存器，将待延时的信号当作输入，按照需要的延时来设置移位寄存器的级数，最后的输出即延时的结果。&lt;/p&gt;
&lt;p&gt;如果延时相对较大，可以使用计数器来延时输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;====================== Update 01/31/2015 ========================&lt;/p&gt;
&lt;h2&gt;Simulation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;我们知道，仿真器使用 “ 事件” (&lt;code&gt;event&lt;/code&gt;) 来模拟实际的电路行为，但是毕竟软件和硬件还是不同的，而 Verilog 语言又是很灵活的，如果不加注意，很可能不能对电路进行正确的建模。Clifford E. Cummings 大神写了一篇 paper 介绍了 Verilog HDL 中应该如何正确使用延时，才能保证建模的正确性：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsHDLCON1999_BehavioralDelays_Rev1_1.pdf"&gt;Correct Methods For Adding Delays To Verilog Behavioral Models&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我的笔记，摘录一部分内容和结论：&lt;/p&gt;
&lt;p&gt;要讨论正确的延时的代码风格，首先要了解仿真器在对延时进行建模时，通常使用的两种不同类型的 Delay 模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Inertial delay&lt;/code&gt; 模型 
    惯性时延，专门描述一些特殊信号传播到输出端口所耗费的时延，这部分信号特殊在于：输入信号必须保持稳定一段时间（等于或大于传播时延）。如果输入信号的变化时间间隔小于过程赋值延时 / 连续赋值延时 / 门延时（也就是说在计算出一个结果并且还没有来得及输出，输入信号又发生了变化），那么前一时刻值的旧事件会被新值的事件代替，重新触发计算，并输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Transport delay&lt;/code&gt; 模型&lt;/p&gt;
&lt;p&gt;传播时延，用来描述当任何一个输入信号一旦发生变化后，所有信号到输出的延时。所有的输出变化值会按照顺序排队输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;有了上面两个延时的概念之后，我们就可以分类讨论下面三种情况下应该如何添加延时了。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Blocking assignment&lt;/h3&gt;
&lt;p&gt;在阻塞赋值中，通常添加延时的方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;left-hand-side&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right-hand-side&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是这两种方法都有可能存在问题：&lt;/p&gt;
&lt;p&gt;以描述一个输出延迟为 12ns 的加法器，如果我们在左边添加延时，&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;在下图时序中可以看到，当 t = 15 时，a 发生变化，触发 always 块，模块计算新的求和结果。但是，在接下来的 t = 15 ~ 24 内，a、b、ci 分别发生了变化，所以当从触发开始，到 12ns 过后该输出结果时，计算结果的值使用的是当前最新的值（可以看到，ci 的变化和输出之间仅仅有 3ns &amp;lt; 12ns），而非触发时刻的值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing1" src="/images/delay-in-fpgas/timing1.png" /&gt;&lt;/p&gt;
&lt;p&gt;事实上，在任何阻塞赋值的左边添加延时都会存在类似的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the LHS of blocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; placing delays on the LHS of blocking assignments in a testbench is reasonable since the delay is just being used to time-space sequential input stimuls events.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们在右边添加延时，同样也会有问题。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;假设在 t = 15 时刻，a 发生变化，触发 always 块，模块会对当前的值进行采样，并且在 12ns 之后将采样结果输出，而在这 12ns 期间，输入端的任何变化都会被忽略，这意味着错误的旧值会一直保持下去，直到有新的变化重新触发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the RHS of blocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; do not place delays on the RHS of blocking assignments in a testbench.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;General Guideline:&lt;/strong&gt; placing a delay on the RHS of any blocking assignment is both confusing and a poor coding style. This Verilog coding practice should be avoided.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Non-blocking assignment&lt;/h3&gt;
&lt;p&gt;在非阻塞赋值中，同样有两种方法来添加延时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;left-hand-side&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right-hand-side&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;仍然使用上面加法器的例子，如果我们在左边添加延时，会和阻塞赋值存在一样的问题：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;当 t = 15 时，触发 always 块，但是输出时结果时，使用的是最新时刻的值。&lt;/p&gt;
&lt;p&gt;事实上，在任何非阻塞赋值的左边添加延时都会存在类似的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the LHS of nonblocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; nonblocking assignments are less efficient to simulate than blocking assignments; therefore, in general, placing delays on the LHS of nonblocking assignments for either modeling or testbench generation is discouraged.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在非阻塞赋值的右边添加延时，会准确地描述前面介绍的 &lt;code&gt;transport delays&lt;/code&gt;：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;当 t = 15 时刻，a 发生变化触发 always 块，此时会立刻对输入进行采样，然后等待 12ns 之后输出；在将这一时间存放在时间队列之后，always 块会被下一个变化时间重新触发，这意味着输出会随着输入的变化在 12ns 之后变化，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing2" src="/images/delay-in-fpgas/timing2.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recommended Application:&lt;/strong&gt; Use this coding style to model behavioral delay-line logic.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; place delays on the RHS of nonblocking assignments only when trying to model transport output-prapagation behavior. This coding style will accurately model delay lines and combinational logic with pure &lt;code&gt;transport delays&lt;/code&gt;; however, this coding style generally causes slower simulations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; This coding style is ofen used in testbenches when stimulus must be scheduled on future clock edges or after a set delay, while not blocking the assignment of subsequent stimulus events in the same procedural blocks,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; in general, do not place delays on the RHS of nonblocking assignments to model &lt;em&gt;combinational logic&lt;/em&gt;. This coding style can be confusing and is not very simulation efficient. It is a common and sometimes useful practice to palce delays n the RHS of nonblocking assignments to model clock-to-output behavior on &lt;em&gt;sequential logic&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; there are some multi-clock design verification suites that benefit from using multiple nonblocking assignments with RHS delays; however, this coding style can be confusing, therefore placing delays on the RHS of nonblocking assignments in testbenches is not generally recommended.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Continuous assignment&lt;/h3&gt;
&lt;p&gt;连续赋值语句中，只能在左侧添加延时，在右边添加延时是非法的：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;在连续赋值语句的左边添加延时，会准确描述惯性延时（&lt;code&gt;inertial delay&lt;/code&gt;），一般推荐使用这种方式。&lt;/p&gt;
&lt;p&gt;以上面的加法器为例：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;如下图，在 t = 15 时刻，a 发生变化触发 assign 语句，应该在 t = 27 时刻输出结果，但是在 t = 17, 19, 21 时刻，a，b 分别发生了变化，这会导致有 3 个新的值，最终会只输出最后一个值（在 t = 21 + 12 = 33 时刻）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing3" src="/images/delay-in-fpgas/timing3.png" /&gt;&lt;/p&gt;
&lt;p&gt;因为连续赋值语句不会排队输出这个概念，它只会跟踪输出结果，所以，连续赋值语句中的延时是对惯性延时（&lt;code&gt;inertial delay&lt;/code&gt;）的建模。&lt;/p&gt;
&lt;p&gt;混合方式：无延时的 always 块 + 连续赋值语句&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;仍然会准确描述组合逻辑中的 inertial delay。在每个输入变化时，tmp 的值都会改变，在 tmp 改变的 12ns 之后，连续赋值的输出发生变化。tmp 一旦发生变化，assign 会重新赋值，重新延时，所以这种方式会准确描述组合逻辑的 inertial delay。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guide:&lt;/strong&gt; Use continuous assignments with delays to model simple combinational logic. This coding style will accurately model combinational logic with inertial delays.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guide:&lt;/strong&gt; Use always blocks with no delays to model complex combinational logic that are more easily rendered sing Verilog behavroral constructs such as "case-casez-casex", "if-else", etc. The outputs from the no-delay always blocks can be driven into continuous assignments to apply behavioral delays to the models. This coding style will accurately model complex combinational logic with inertial delays.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; Continuous assignments can be used anywhere in a testbench to drive stimulus values onto input port and bi-directional port and bi-directional ports of instantiated models.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;always 块中的任何延时都无法准确对真实硬件的行为进行准确建模，应该避免这种延时建模。有一个例外：在非阻塞复制的右边添加延时，来描述 transport delay，但是这种方式是以仿真性能的下降为代价的。&lt;/p&gt;
&lt;p&gt;在 连续赋值语句 / 无延时的always + 连续赋值语句 中添加延时，这两种方式都会对 inertial delays 建模，推荐使用这种方式来对组合逻辑建模。&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Digital-Design-An-Embedded-Systems-Approach-Using-Verilog-Ashenden-Peter-J/dp/0123695279"&gt;Digital Design (Verilog): An Embedded Systems Approach Using Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Based-System-paperback-Prentice-Semiconductor/dp/0137033486"&gt;FPGA-Based System Design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1882474/"&gt;设计与验证Verilog HDL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Xilinx-FPGA%E9%AB%98%E7%BA%A7%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%B1%A4%E7%90%A6/dp/B007TLVUT8"&gt;Xilinx FPGA高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture: Design Methods and Techniques for Digital Circuits&lt;/a&gt;&lt;/p&gt;</summary><category term="delay"></category></entry><entry><title>计数器设计小结</title><link href="http://guqian110.github.io/pages/2014/11/04/counter_design_summary.html" rel="alternate"></link><updated>2014-11-04T20:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-11-04:pages/2014/11/04/counter_design_summary.html</id><summary type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;计数器 在数字电路设计 和 计算机程序设计 中都应用非常广泛，其功能顾名思义，就是用来计数。这里只讨论数字电路设计中的计数器。&lt;/p&gt;
&lt;p&gt;通常，将包含触发器 flip-flop 的电路（即使含有组合电路部分）认为是时序电路。时序电路通常不以电路命名，而是以功能进行分类，分别是 &lt;strong&gt;寄存器&lt;/strong&gt; 和 &lt;strong&gt;计数器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;计数器 &lt;a href="http://en.wikipedia.org/wiki/Counter"&gt;counter&lt;/a&gt; 从本质上来说也是寄存器，不过它是在预先设定好的状态序列中转移，尽管计数器是寄存器的一种特殊形式，通常还是以不同的名称来加以区分。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Type&lt;/h2&gt;
&lt;p&gt;按照不同的标准来划分，计数器可以有不同的划分方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;触发方式&lt;/p&gt;
&lt;p&gt;同步 / 异步 计数器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数增减&lt;/p&gt;
&lt;p&gt;加法 / 减法 / 可逆计数器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为第二种方法没有明确显示计数器的计数方式，所以一般使用第一种方法。&lt;/p&gt;
&lt;p&gt;这里总结了一些常见的计数器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Basic Binary Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BCD Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ring Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Johnson Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ripple Counter&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;计数器在数字电路中的用途非常广，可以作为定时器、实用计数器、状态机等。在具体实现时，有前面总结的不同的计数器类型可供选择，每种计数器由其特点决定了适用场合，我们要做到就是在不同计数器类型和配置之间进行权衡，选择正确的设计，以节省大量逻辑资源，并提高性能。&lt;/p&gt;
&lt;p&gt;下面分别讨论各种计数器的特点和 HDL 实现。&lt;/p&gt;
&lt;h2&gt;Implement&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Binary Counter&lt;/h3&gt;
&lt;p&gt;最简单、最基本的计数器就是 二进制计数器 Binary Counter。它的计数方式就是从 0 开始每个脉冲进行 “+1” 操作，直到最大值，然后重新从 0 开始。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Prototyping-Verilog-Examples-Spartan-3/dp/0470185325"&gt;FPGA Prototyping By Verilog Examples: Xilinx Spartan-3 Version&lt;/a&gt; 里面有个例子，这里稍作修改就可以当作通用模块，供其他模块调用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;free_run_bin_counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;                     &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;                     &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;               &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// count&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;  &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;// max_tick&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mh"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;}})&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;BCD Counter (mod-m counter)&lt;/h3&gt;
&lt;p&gt;人类更习惯使用十进制进行计数，十进制一共有 10 个符号，我们只需要从 4 bit 的二进制计数器中选取 10 个数字，只使用这 10 个数字进行计数即可，通常去掉 1010 ~ 1111 这 6 个数字，即使用 8421BCD码 来对十进制数进行编码、计数，即 BCD Counter。&lt;/p&gt;
&lt;p&gt;将十进制进行推广，我们就可以写出任意的 模 m 的计数器，在下面的例子中，M 表示计数器的模值（默认为 10），N 表示计数器需要的位数（默认为 4）。在例化时如果要修改，则需要手动计算这两个参数进行赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;bcd_counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// number of bits in counter&lt;/span&gt;
                &lt;span class="no"&gt;M&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// mod-M&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;                 &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;M&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;M&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Ring Counter&lt;/h3&gt;
&lt;p&gt;基于线性移位寄存器 &lt;a href="http://en.wikipedia.org/wiki/Linear_feedback_shift_register"&gt;&lt;code&gt;LFSR&lt;/code&gt; (Linear feedback shift register) &lt;/a&gt; 可以衍生出两种计数器：&lt;a href="http://en.wikipedia.org/wiki/Ring_counter"&gt;环形计数器 (ring counter)&lt;/a&gt; 和 扭环计数器（约翰逊计数器）。&lt;/p&gt;
&lt;p&gt;将 LFSR 中存储的数字设置为独热码的形式，即只有一位为 1，其他位为 0。然后把最后一级的输出直接反馈到第一级的输入，这样，输入和输出组成了一个环形，所以称为 环形计数器。4 bit 的环形计数器电路图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ring counter" src="/images/counter-design-summary/ring_counter.png" /&gt;&lt;/p&gt;
&lt;p&gt;(ref: http://electronics-course.com/ring-counter)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;相比于 binary counter，ring counter 不需要后者必需的加法器来实现计数，所以它在电路上占用的资源要更少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为没有额外的加法器，所以 ring counter 也不存在加法器带来的进位时延，它的最大时延是固定值，和计数器的模值无关。所以它的时序性能也比 binary counter 好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 ring counter 的汉明距离为 2，所以它可以检查单比特翻转的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Disadv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ring counter 最大的缺点就是它的低密度码，同样适用 N 个寄存器，binary counter 可以计数到 2^N，而 ring counter 只能计数到 N，经过改良后的 Johnson counter 也才能到 2N。所以，如果寄存器比组合逻辑更加珍贵的情况下，不适合使用 ring counter。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;ring_counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;                 &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]};&lt;/span&gt;    &lt;span class="c1"&gt;// right shift&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Johnson Counter&lt;/h3&gt;
&lt;p&gt;在 ring counter 的反馈链路中加入一个反相器，就好象把一个环扭了一下，所以称为 扭环计数器 (Johnson Counter)&lt;/p&gt;
&lt;p&gt;4 bit 的 Johnson Counter 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="johnson counter" src="http://upload.wikimedia.org/wikipedia/commons/e/e8/JohnsonCounter2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大的优点就是它可以计数的范围和 ring counter 相比，扩大了一倍，达到了 2N。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大的缺点就是一旦它进入了错误状态，则永远无法返回到正确状态，除非外界干预。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，将前面例子第 行的反馈语句修改一下，&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]};&lt;/span&gt;    &lt;span class="c1"&gt;// right shift&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;同时，计数器的终点也要进行相应的修改，&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Ripple Counter&lt;/h3&gt;
&lt;p&gt;前面总结的这些计数器都是同步计数器，组成它们的 flip-flop 是由同一个脉冲信号触发的。还有一种计数器是异步计数器，它内部的 flip-flop 不是由同一个脉冲信号触发的。由于 FPGA 特殊的结构原因，在 FPGA 中应该使用同步设计，所以一般 FPGA 不会使用这种计数器。&lt;/p&gt;
&lt;p&gt;ripple counter 的每个 flip-flop 使用前一级的 flip-flop 的输出信号作为触发信号，所以后一级的触发器必须等到前一级的触发器输出之后才能工作，所以对于一个长度为 N 的触发器链，从输入时间开始，要等 N 个触发器依次工作完之后才能输出有效结果。&lt;/p&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ripple counter" src="/images/counter-design-summary/ripple_counter.png" /&gt;&lt;/p&gt;
&lt;p&gt;(ref: http://www.eecs.tufts.edu/~dsculley/tutorial/flopsandcounters/flops6.html)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面积小（不需要电路来实现 “+1” 功能）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功率少（因为面积小）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以在一些对面积、成本、功率敏感的应用中，ripple counter 很有用。比如：一个电子时钟，因为秒 s 对于纳秒 ns 来说是很缓慢的，所以可以忍受这种累积误差的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的 flip-flop 不是同时触发的，每个 flip-flop 的时延会累积到输出，当所有的时延累积到一起，有时候（很长的 flip-flop 级联在一起）相对于时钟信号而言，就不能忽略这种时延了，严重时会导致系统出错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码在&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Hdl-Chip-Design-Synthesizing-Simulating/dp/0965193438"&gt;Hdl Chip Design: A Practical Guide for Designing, Synthesizing &amp;amp; Simulating Asics &amp;amp; Fpgas Using Vhdl or Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有介绍。&lt;/p&gt;
&lt;h3&gt;Gray Code Counter&lt;/h3&gt;
&lt;p&gt;Gray 码和普通的二进制编码相比，优势就是它相邻数字之间只有一位不同，这样在计数时，就避免的多位不是同时变化导致的毛刺。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Gray_code"&gt;Gray Code wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A typical use of Gray code counters is building a FIFO (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.[10] The updated read and write pointers need to be passed between clock domains when they change, to be able to track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a "wrong" binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大神 Clifford E. Cummings 的论文 &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;synthesis and scripting techniques for designing multi-asynchronous clock designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中有详细介绍如何设计一个 Gray Code Counter 的过程，其基本思想就是利用一个 binary counter 来实现目的，计数器的计数功能由内部的 binary counter 实现，将 binary 的计数结果通过一个 binary2gray 的转换电路转化为 gray code 后再输出；输出的 gray code 反馈回计数器之前，再通过一个 gray2bianry 的电路转化回 binary 形式，以供内部的 binary counter 使用。模块示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gray code counter" src="/images/counter-design-summary/gray_code_counter.png" /&gt;&lt;/p&gt;
&lt;p&gt;代码略...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Prototyping-Verilog-Examples-Spartan-3/dp/0470185325"&gt;FPGA Prototyping By Verilog Examples: Xilinx Spartan-3 Version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Hdl-Chip-Design-Synthesizing-Simulating/dp/0965193438"&gt;Hdl Chip Design: A Practical Guide for Designing, Synthesizing &amp;amp; Simulating Asics &amp;amp; Fpgas Using Vhdl or Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;synthesis and scripting techniques for designing multi-asynchronous clock designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Design-Recipes-FPGAs-Embedded-Technology/dp/0750668458/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1415197345&amp;amp;sr=1-1&amp;amp;keywords=design+recipes+for+fpgas"&gt;Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology) &lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>番茄工作法 总结 + 实践</title><link href="http://guqian110.github.io/pages/2014/11/02/the_pomodoro_technique_practices.html" rel="alternate"></link><updated>2014-11-02T21:46:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-11-02:pages/2014/11/02/the_pomodoro_technique_practices.html</id><summary type="html">&lt;p&gt;忙里偷闲，学习一下大名鼎鼎的 &lt;strong&gt;番茄工作法&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;番茄工作法 (&lt;a href="http://en.wikipedia.org/wiki/Pomodoro_Technique"&gt;Pomodoro Technique&lt;/a&gt;) 是由 Francesco Cirillo 创建的一种时间管理方法。他自己上大学时为了克服无法集中精力认真学习这个问题而发明了这种方法，后来他整理完成了一本书来介绍这种方法：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pomodorotechnique.com/book/"&gt;The Pomodoro Technique&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;"Pomodoro Technique" 这个名字起源于一种厨房用的、番茄形状的计时器，其中 &lt;code&gt;Pomodoro&lt;/code&gt; 是意大利语，意思是番茄。&lt;/p&gt;
&lt;p&gt;至于为什么是番茄工作法，而不是白菜工作法呢？这是因为 Francesco Cirillo 当时在厨房找到的那个计时器是番茄形状的 :P&lt;/p&gt;
&lt;p&gt;还有另外一本书，是另外一个人自己实践番茄工作法总结出来的经验，而且自己画了一些生动的插图和脑图在里面，很有帮助：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.pomodoro-book.com/"&gt;Pomodoro Technique Illustrated&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;首先，网上贴张别人总结好的 Mind Map (出处见水印)：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mm" src="/images/the-pomodoro-technique-practices/mind_map.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;番茄工作法非常简单，具有非常强的可操作性，这也是它能风靡世界的原因吧。&lt;/p&gt;
&lt;p&gt;番茄工作法一共包含 5 个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img alt="five stage" src="/images/the-pomodoro-technique-practices/five_stages.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中有一些必须遵守的法则：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rules" src="/images/the-pomodoro-technique-practices/rules.png" /&gt;&lt;/p&gt;
&lt;p&gt;也可以用一张图总结出什么是番茄工作法：&lt;/p&gt;
&lt;p&gt;&lt;img alt="flow" src="/images/the-pomodoro-technique-practices/workflow.png" /&gt;&lt;/p&gt;
&lt;p&gt;综上，找一只笔和几张纸，列出要完成的工作，然后设定计时器，开始工作！就这么简单。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;My Practice&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;GTD 和 pomodoro 可以相互补充，达到最好的效果：&lt;/p&gt;
&lt;p&gt;GTD 侧重项目之间的管理，通过收集、处理、组织，使我们胸有成竹，做到 mind like water；Pomodoro 则侧重时间管理，每天到底应该如何提高效率，通过和自己约定的倒计时，把一个个行动落实，把握生命中的每一分钟，全力以赴我们心中的梦，不经历风雨怎么能见彩虹（不对...）&lt;/p&gt;
&lt;h3&gt;Tools&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;番茄法的工具（5 个）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A pen&lt;/li&gt;
&lt;li&gt;A Kitchen Timer&lt;/li&gt;
&lt;li&gt;Activity Inventory Sheet&lt;/li&gt;
&lt;li&gt;Todo Today Sheet&lt;/li&gt;
&lt;li&gt;Record&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;GTD 的工具：（6 个）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Project List&lt;/li&gt;
&lt;li&gt;Next Action List&lt;/li&gt;
&lt;li&gt;Waiting For List&lt;/li&gt;
&lt;li&gt;Someday / Maybe List&lt;/li&gt;
&lt;li&gt;Calendar&lt;/li&gt;
&lt;li&gt;Reminder / Memo&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，综合一下两者的优势，就有了下面的组合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Project List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运用 GTD 的收集、整理的优势，把我们的长期目标放在这里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Someday / Maybe List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里放目前不紧急，将来某个时候会做的事。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Activity Inventory List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;短期目标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Todo Today List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计划每天做的事，一定要尽力完成（因为这是我们作出的承诺）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Calendar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有日历帮助，我们可以更好地计划、实现一件复杂的事。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reminder / Memo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记录生活中的小事、杂事，某时的突发奇想。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;A Pomodoro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置一个番茄时间，开始做！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Tips&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;番茄的大小，根据我们自己的实际情况而定，不过一开始可以用默认的 25 mins，过一段时间后如果真的不适合自己再进行修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Todo Today List 内容一定要实际可行，根据自己平时完成的番茄总量、预估计任务量来安排，尽最大努力完成清单，因为这是我们对自己的承诺。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按时休息。有时候我们可能正在起劲的时候，番茄钟响了，这时候最好停下手头的工作（即使你正在编程的紧要关头，文思如泉涌，有个新想法正想试试），原因很简单，避免长时间的工作，现在的休息是为了之后更长时间、更有效率地工作。即使有个好点子，先把它写下来，等休息好了再来评估、实现这个想法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一定要严格遵守约定。类似 “破窗效应”，一旦我们有某次打破了番茄的规定，那么就很容易打破第二次、第三次。失去了约束力，这个方法也就没有作用了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考研的苦逼日子最大的收获就是学会了用 calendar + checklist 来规划自己的学习生活。计划好一个长期目标，精确到每天的任务，这样每天结束时，如果完成了心情真是不要太开心，如果没有完成则对第二天也是一个激励，要提高效率把前一天的补上。我的这个 “土” 方法现在看来就是 GTD + Pomodoro 的简化版，是时候好好改进一下了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;TODO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Self Observation 非常重要！每天坚持完，留一个番茄来回顾自己这一天的收获和效率情况，这样我们会对自己有个清楚的认识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回顾收获&lt;/li&gt;
&lt;li&gt;制定第二天的计划&lt;/li&gt;
&lt;li&gt;分析、提高自己的效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>GTD 书评 + 总结</title><link href="http://guqian110.github.io/pages/2014/10/30/getting_things_done_review.html" rel="alternate"></link><updated>2014-10-30T12:51:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-10-30:pages/2014/10/30/getting_things_done_review.html</id><summary type="html">&lt;p&gt;最近了解学习了 GTD，总结一下。&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;所谓 GTD 就是 &lt;a href="http://en.wikipedia.org/wiki/Getting_Things_Done"&gt;Getting Things Done&lt;/a&gt; 的缩写。最早有一个叫做 David Allen 的美国人写的一本书，名字就是:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Getting-Things-Done-The-Art-of-Stress-Free-Productivity-%E6%88%B4%E7%BB%B4%C2%B7%E8%89%BE%E4%BC%A6/dp/0142000280/ref=sr_1_2?ie=UTF8&amp;amp;qid=1414465590&amp;amp;sr=8-2&amp;amp;keywords=getting+things+done"&gt;Getting Things Done: The Art of Stress-Free Productivity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他是 GTD 系统的发明人，主要介绍了时间和任务管理的相关方法，后来这套系统越来越流行，于是大家就把相关的方法、工具统称为 GTD。&lt;/p&gt;
&lt;p&gt;网上有很多介绍 GTD 方法论的博客：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.gtdlife.com/"&gt;小强的时间管理博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.gtdstudy.com/"&gt;学无止境@一点一滴&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mifengtd.cn/"&gt;褪墨・时间管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些大多是专业的培训师之类的人写的博客，里面的内容很全面也很详细（总共可能有 100+ 的文章），但是阅读体验却不好。我想主要原因是他们作为培训师、讲师身份，只有复杂、系统地介绍才能衬托出他们的专业。而作为一个普通人，我相信很多人都体验都是：好大一碗成功学鸡汤 =.=&lt;/p&gt;
&lt;p&gt;所以，作为一个普通的学生、总结一下我在一周的空余时间内学习 GTD 的心得，保证简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;阅读 &lt;a href="http://www.amazon.cn/Getting-Things-Done-The-Art-of-Stress-Free-Productivity-%E6%88%B4%E7%BB%B4%C2%B7%E8%89%BE%E4%BC%A6/dp/0142000280/ref=sr_1_2?ie=UTF8&amp;amp;qid=1414465590&amp;amp;sr=8-2&amp;amp;keywords=getting+things+done"&gt;Getting Things Done: The Art of Stress-Free Productivity&lt;/a&gt;，还是英文版靠谱，网上的翻译质量实在无法恭维。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阅读几篇博客即可，主要是吸收、了解别人和自己的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结（形式随意，如写 blog、画 mind map），实践应用！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;GTD&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Reason&lt;/h3&gt;
&lt;p&gt;现在的人的生活、工作压力都很大，如果没有一个有效的方法来组织管理自己的事物，会越忙越乱。&lt;/p&gt;
&lt;p&gt;比如作为一个学生，一想到自己的论文还没有头绪，项目也看不到希望，还有码农的编程技能没有完全 get，眼看就要毕业了，找工作的压力也逐渐越来越大，着急却越忙越乱，总有一些事盘旋在脑袋里，不经意间提醒你 “还有没有做好的事！”&lt;/p&gt;
&lt;p&gt;这时候，各种管理的方法就出现了，而 GTD 就是其中一种。&lt;/p&gt;
&lt;h3&gt;Aim&lt;/h3&gt;
&lt;p&gt;GTD 书里面最终目的就是帮助我们达到所谓的 “黑带” &lt;code&gt;black belt&lt;/code&gt; 级别，标志就是做到 “心静如水”  &lt;code&gt;Mind Like Water&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓心静如水，是从武学中借鉴过来的词（也就是功夫熊猫里面浣熊师父教给胖纸的武术家的追求—— &lt;code&gt;inner peace&lt;/code&gt;），GTD 的目的就是通过这一套系统方法让我们达到这种境界：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌控一切，不慌不忙，全身心投入到每一件事中。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Workflow&lt;/h3&gt;
&lt;p&gt;&lt;img alt="workflow" src="/images/getting-things-done-review/workflow.png" /&gt;&lt;/p&gt;
&lt;h3&gt;Methodology&lt;/h3&gt;
&lt;p&gt;GTD 的方法其实并不高深，它实际上主要就是解决了两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;很多事之间该如何处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;某一件事该如何进行下去&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Horizontal Focus&lt;/h4&gt;
&lt;p&gt;为了解决第一个问题，GTD 提出了 5 个横向管理方法 &lt;code&gt;horizontal five-stage method&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Collect&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把所有的 “原始材料”（&lt;code&gt;stuff&lt;/code&gt;）都收集（&lt;code&gt;collcet&lt;/code&gt;）到一个地方，比如一个货真价实的篮子，或者是文件夹、电脑上的某个文件夹中（或者它们的组合），这个地方就称为 &lt;code&gt;in-basket&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;关键：一定要保证把所有的事全部收集起来，不能漏掉一个，这样我们就可以只专注于这个 in-basket，而不用考虑其他乱七八糟的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Process&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收集到 in-basket 之后，按照前面的 workflow 对其中的内容进行处理（&lt;code&gt;process&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;关键：按照顺序，一次一件事地进行分类处理，处理完之后不要放回 in-basket 中，有条理地进行可以避免重复工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Organize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前一步只是将 in-basket 中的内容进行了分类，但结果仍然是一堆事情的集合，这时候就需要我们将其组织管理（&lt;code&gt;organize&lt;/code&gt;）成各种有序的清单（&lt;code&gt;list&lt;/code&gt;），比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;项目清单（&lt;code&gt;project list&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日历（&lt;code&gt;calendar&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一步行动清单（&lt;code&gt;next action list&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待清单（&lt;code&gt;waiting for list&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将来某时清单（&lt;code&gt;someday/may list&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键：建立一个 完备正交的分类集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Review&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在建立起各种清单之后，我们需要对其进行跟踪维护。根据事件的重要程度，每天、每周、每月、每年地不断坚持更新我们的清单。虽然简单，但也是最难做到的地方。或许 3 分钟热情可以持续一段时间，但是大多数人都没有恒心将一件事坚持下去。&lt;/p&gt;
&lt;p&gt;关键：恒心！！！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Do&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们清单都列好了，但是当我们每天在确切的某个时间做什么确切的事呢？GTD 并没有给出答案，毕竟某件事重不重要只有我们自己才知道。但是它给出了 3 个模型来对一件事情的重要、紧急情况进行评估，以便我们安排工作顺序。安排工作顺序可以按照不同的属性进行排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地点：宿舍、实验室、教室&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间：早中晚、工作日、周末&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;花费的精力：看书、编程、发邮件、整理文档&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重要程度：人生目标、工作计划、当前工作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，我觉得在 do 这个方面，或许其他的方法更有效，比如 “番茄工作法” 等可以帮助我们有效地安排工作时间，提高注意力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上。&lt;/p&gt;
&lt;p&gt;就是这么简单，和我们平时自己琢磨出来的方法没有太大差别，这几个步骤的目的就是管理我们的工作，让我们不再是乱糟糟一团的感觉，而是 “清单在手，天下我有” 的掌控全局的感觉，这也是我们能进入 mind like water 状态的前提。&lt;/p&gt;
&lt;h4&gt;Vertical Focus&lt;/h4&gt;
&lt;p&gt;为了解决第二个问题，GTD 提出了 5 个纵向管理方法 &lt;code&gt;vertical five-phase method&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Defining purpose &amp;amp; principles&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Outcoming &amp;amp; visioning&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Brainstorming&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Organizing&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Identifying next actions&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这几个步骤其实就是很自然而然的从上到下（&lt;code&gt;top to down&lt;/code&gt;）的方法：&lt;/p&gt;
&lt;p&gt;首先确定目标（&lt;code&gt;purpse &amp;amp; principles&lt;/code&gt;），避免盲目努力，然后再展望做完时的美好景象（&lt;code&gt;outcoming &amp;amp; visioning&lt;/code&gt;），这时候我们干劲十足，通过头脑风暴（&lt;code&gt;brainstorming&lt;/code&gt;）找到合适的工作方法，之后就是确切地组织（&lt;code&gt;organizing&lt;/code&gt;）人员，确认如何下手（&lt;code&gt;identifying next action&lt;/code&gt;），开始干活了了。&lt;/p&gt;
&lt;p&gt;步骤说起来空洞无味，但是在实际中面对不知如何下手的事情，可以参考这个步骤。关于如何做好一件事，涉及到不同的人和不同的工作类型，所以我认为这里的方法只能作为一个参考吧。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
&lt;h3&gt;Tools&lt;/h3&gt;
&lt;p&gt;书里面还介绍了一些小技巧，就不再重复了。不过根据我的实践来看，工具其实也是一个至关重要的因素。&lt;/p&gt;
&lt;p&gt;选择标准：&lt;strong&gt;选择合适的而不是功能最全的工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在有很多 GTD 类的软件，比如 thinkrock、remember the milk、any.do 等等，功能很全很强大，但是我最终还是选择了简单的 &lt;em&gt;Google xxx + Evernote&lt;/em&gt; 的组合。&lt;/p&gt;
&lt;p&gt;什么是合适的工具呢，我认为只要满足&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;够用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个条件就好。&lt;/p&gt;
&lt;p&gt;简单的功能可以帮助我们集中注意力，Google 的很多产品都遵循这个原则，比如 Calendar、Task、Keep、Translate 等，而 Evernote 虽然功能强大，但是有时候让我无从下手，不想打开；当然关键功能必须要有，比如最近很火的一款应用 Todist，作为一款 todo list 类型的软件，免费版本却没有提醒功能，他们是有多想挣钱啊 =.=&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Review&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这年头不可避免地看了一些成功学的书，喝了不少鸡汤，这本久负盛名，最近越来越火的书，从我的体验来说，比其他同类的书要好很多，还是有干货的。虽然没有给我非常的大的质的改变，但是也解决了不少我的疑惑。书里没有提出多么惊天动地的方法，很多都是我们日常生活中在使用的技巧，这本书把这些总结整理成一套系统方法，也算是一大成就吧。&lt;/p&gt;
&lt;p&gt;毕竟，实践才是检验真理的唯一标准，等过段时间再评价吧。&lt;/p&gt;
&lt;h2&gt;My GTD&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;作为学生党的 GTD 实践：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Tools&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Project List&lt;/td&gt;
&lt;td&gt;Evernote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Daily Plan&lt;/td&gt;
&lt;td&gt;Evernote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Waiting For List&lt;/td&gt;
&lt;td&gt;Evernote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Someday/Mayble List&lt;/td&gt;
&lt;td&gt;Evernote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calendar&lt;/td&gt;
&lt;td&gt;Google Calendar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reminder &amp;amp; Memo&lt;/td&gt;
&lt;td&gt;Google Keep&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;说明一下选择 EN 的最大的理由：它的跨平台性，Windows + *nix + Andriod，基本涵盖了我校园（宿舍 + 实验室）的生活，至于 Google 就不用说了，Gmail + Calendar + Keep + Drive 的组合别说有多舒服了～&lt;/p&gt;
&lt;p&gt;关于 “Next Action List”，我个人觉得并不是特别适合我，就平时的事（学习 + 项目 + 杂事）而言，学习和项目很难用 Next Action 来做计划，而杂事都是一些鸡毛蒜皮的小事，用不着分步骤来完成。我每天都活动基本上是固定的，哪个时间段干什么早就形成了一种模式，所以我将 “Next Action List” 改为 “Daily Plan”。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Mind Map&lt;/h2&gt;
&lt;p&gt;最后贴上一张我总结的 MM：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtd mm" src="/images/getting-things-done-review/gtd_mm.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://snownow.cn/?p=1838"&gt;GTD | snow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://picasaweb.google.com/gudaost/MindMapper#5073109143800914274"&gt;MindMapper&lt;/a&gt;&lt;/p&gt;</summary><category term="GTD"></category><category term="review"></category></entry><entry><title>时钟分频器</title><link href="http://guqian110.github.io/pages/2014/10/13/clock_dividers.html" rel="alternate"></link><updated>2014-10-13T22:26:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-10-13:pages/2014/10/13/clock_dividers.html</id><summary type="html">&lt;p&gt;在 &lt;a href="http://guqian110.github.io/pages/2014/09/12/the_clock_design_in_fpga_2_clock_design.html"&gt;时钟设计&lt;/a&gt; 中提到过：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline：&lt;/strong&gt; 尽量避免使用分频时钟&lt;/p&gt;
&lt;p&gt;如果要进行分频，可以使用 PLL/DLL 来实现，但是对于时钟要求不高的基本设计，通过语言进行时钟的分频相移仍然非常流行，首先这种方法可以节省芯片内部的锁相环资源，再者，消耗不多的逻辑单元就可以达到对时钟操作的目的。另一方面，通过语言设计进行时钟分频，可以看出设计者对设计语言的理解程度。&lt;/p&gt;
&lt;p&gt;如果一定要使用分频时钟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于资源比较丰富的 FPGA&lt;/p&gt;
&lt;p&gt;使用内部提供的 PLL/DLL，输出时钟信号可以配置成不同的频率（倍频/分频）和相位，这样的分频时钟是最稳定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于无法使用 PLL/DLL 的 FPGA&lt;/p&gt;
&lt;p&gt;对于这些情况，首先检查是否可以用 &lt;code&gt;CE&lt;/code&gt; (clock enable) 来代替分频时钟，如果不行，则使用下面讨论的分频方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Counter&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;时钟分频一般都是通过计数器 counter 来实现的，计数器是分频的基础。&lt;/p&gt;
&lt;p&gt;计数器可以分为很多种，&lt;a href="http://en.wikipedia.org/wiki/Counter"&gt;Counter on wiki&lt;/a&gt;，这里不再跑题展开了，关于计数器的讨论见：&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Counter in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Clock divider&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;even clock divider&lt;/h3&gt;
&lt;p&gt;偶数分频是最简单的情况，使用计数器就可以完成。比如，产生一个分频系数为 N（偶数）的 50% 占空比的分频器一般有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计数器计数到 (N/2-1) 时，将输出翻转，同时将计数器复位到 0，重新开始计数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数器从 0 计数到 (N/2-1) 时，输出 1/0，从 N/2 计数到 (N-1) 时，输出 0/1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方案一只能实现固定的 50% 占空比，方案二则可以实现可以有限调整占空比。&lt;/p&gt;
&lt;h3&gt;odd clock divider&lt;/h3&gt;
&lt;p&gt;如果对占空比没有要求，那么使用和偶数分频类似的方法，一个计数器就可以解决；如果要求占空比是 50%，则可以使用以下的方法：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conceptually, the easiest way to create an odd divider with a 50% duty cycle is to  generate two clocks at half the desired output frequency with a quadrature-phase relationship (constant 90° phase difference between the two clocks).&lt;/p&gt;
&lt;p&gt;The output frequency can then be generated by exclusive-ORing the two waveforms together.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Steps&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 ref_clk 上升沿触发的 0 ~ (N - 1) 的计数器 cnt（N 为奇数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用两个 T flip-flop，分别产生各自的 enable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tff1_en: 当 cnt = 0 时，使能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tff2_en: 当 cnt = (N + 1) / 2 时，使能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产生以下信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;div1：在 ref_clk &lt;em&gt;上升沿&lt;/em&gt; 触发 tff1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;div2：在 ref_clk &lt;em&gt;下降沿&lt;/em&gt; 触发 tff2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异或 div1 和 div2，得到输出 clk_out&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中，举例介绍了 3 分频的情况：&lt;/p&gt;
&lt;p&gt;Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="schematic" src="/images/clock-dividers/divide_3_sch.png" /&gt;&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing" src="/images/clock-dividers/divide_3_timing.png" /&gt;&lt;/p&gt;
&lt;h3&gt;half integer clock divider&lt;/h3&gt;
&lt;p&gt;这种分频系数为 (N+1/2)，应该归类到小数分频中，但是因为它的小数部分是特殊的 1/2，所以可以在前面的讨论的基础上得到。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中分类讨论了半整数分频：&lt;/p&gt;
&lt;h4&gt;50% Duty Cycle&lt;/h4&gt;
&lt;p&gt;以 1.5 分频为例，&lt;/p&gt;
&lt;p&gt;Schematic:&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/clock-dividers/divide_1_5_sch.png"&gt;1.5 sch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/clock-dividers/divide_1_5_timing.png"&gt;1.5 timing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这种方法在仿真的时候是没有问题的，但是综合时可能会产生致命的问题：在切换时钟时，如果两路时钟信号的时延不相等，那么切换的时候就会产生毛刺。&lt;/p&gt;
&lt;p&gt;(Xilinx 提供的原语 &lt;code&gt;BUFGMUX&lt;/code&gt; 有去除切换时钟时候的毛刺的功能，但是它只适用于全局时钟网络)&lt;/p&gt;
&lt;h4&gt;Non 50% Duty Cycle&lt;/h4&gt;
&lt;p&gt;如果占空比不是 50%，则可以通过以下的方法得到：&lt;/p&gt;
&lt;p&gt;从&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可知，N+1/2 分频也就是要求在 (2N+1) 个时钟周期内产生两个脉冲即可，这两个脉冲必须是等间隔分布的。&lt;/p&gt;
&lt;p&gt;首先，可以采用长度为 (2N+1) 的移位寄存器，这些寄存器中只有一个是 1，其他都是 0，然后在时钟的驱动下循环移位，则就有了 (2N+1) 个时钟周期的计数。&lt;/p&gt;
&lt;p&gt;其次，两个脉冲可以从这个移位寄存器中选取两个作为输出，但是不能简单地直接使用，因为无论怎样选择，这两个脉冲都不是等间隔分布的（一共 2N+1 个计数，抽取 2 个，剩余 2N-1 个计数，那么 2N-1 是个奇数，无法平分为两部分，所以不是等间隔的）。所以难点就在于如何得到两个等间隔的分布。The Art 的解决方法如下，以 4.5 分频为例：&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;img alt="4.5 timing" src="/images/clock-dividers/divide_4_5_timing.png" /&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，当选择了两个连续的寄存器 (A, B)相或作为第一个脉冲输出之后，再选取相隔 N 的两个连续的寄存器 (C, D)，把它们移动半个时钟周期后，和原始的 D 相或，作为第二个脉冲输出，容易分析，它们是等间隔的。&lt;/p&gt;
&lt;h3&gt;fraction divider&lt;/h3&gt;
&lt;p&gt;大概有两种方法吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数逼近法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多次分频&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小数分频，最普通的方法是采用整数分频逼近法，比如 50 MHz 的时钟分频为 880 Hz，那么分频计数器:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;50000000&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;880&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;56818.18182&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么就用 56818 来近似，但是这种方法只有在分频系数很大时才比较好，分频系数越小，则误差越大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考一篇博文：&lt;a href="http://blog.sina.com.cn/s/blog_6840802c0100izey.html"&gt;verilog 实现小数分频（小数分频器）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过可变分频和多次平均的方法，然后通过控制单位时间内两种分频比出现的不同次数来获得所需要的小数分频值。&lt;/p&gt;
&lt;p&gt;假设分频系数为 N+A/B，其中 N, A, B 都是整数，N 代表整数部分，A/B 表示小数部分。&lt;/p&gt;
&lt;p&gt;由&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NB&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可知，通过 (B-A) 次 N 分频 + A次 (N+1) 分频即可得到 N+A/B 分频。&lt;/p&gt;
&lt;p&gt;到此还没有结束，还需要对这两种分频方式进行均匀的放置。可以借助一个计数器到达这个目的：每进行一次分频，计数值为10减去分频系数的小数部分，各次计数值累加。若累加结果小于10，则进行 N +1 分频，若大于或等于10，则进行 Ｎ 分频。&lt;/p&gt;
&lt;p&gt;不同时钟分频组合时，“按照累积量和 10 比较” 原理： 当采用一种分频比，小数部分累积量大于 10，则表示小数部分累积达到了可以向整数部分进位的大小，这时候就应该插入另外一种分频比将小数部分积累的误差去掉，否则结果就不是均匀周期的时钟信号了。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;比如 8.7 分频&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;87&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以可以用 3 次 8 分频 + 7 次 9 分频得到 8.7 分频。因为 &lt;code&gt;10 -7 = 3&lt;/code&gt;，前 3 次累积之和都小于 10，所以前 3 次进行 9 分频，第四次累积值为 12，去除进位后余 2，待下次继续累积，第四次结果 12 &amp;gt; 10，所以进行 8 分频。分频方案如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="/images/clock-dividers/example.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;本文总结了一些常用的时钟分频技术，虽然不推荐使用逻辑来对时钟信号进行分频，但是在一些要求比较的的情况下，使用逻辑分频不仅可以满足要求，还能降低资源消耗，不失为一种好方法。而且时钟分频也可以训练我们的设计能力。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA高手设计实战真经100则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://read.pudn.com/downloads126/sourcecode/embed/533229/VHDL%E5%88%86%E9%A2%91%E5%99%A8%E8%AE%BE%E8%AE%A1.pdf"&gt;使用 VHDL 进行分频器设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_6840802c0100izey.html"&gt;verilog 实现小数分频（小数分频器）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetop.cn/blog/html/11/317611-13680.html"&gt;任意分频的verilog语言实现&lt;/a&gt;&lt;/p&gt;</summary><category term="clock design"></category><category term="clock dividers"></category></entry><entry><title>FPGA 时钟设计 3 —— 跨时钟域设计</title><link href="http://guqian110.github.io/pages/2014/10/09/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html" rel="alternate"></link><updated>2014-10-09T23:01:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-10-09:pages/2014/10/09/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html</id><summary type="html">&lt;h2&gt;Problem&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在前面一篇总结 &lt;a href="http://guqian110.github.io/pages/2014/09/23/latch_versus_flip_flop.html"&gt;Latch V.S. Flip-flop&lt;/a&gt; 的博文中，已经解释了 flip-flop 的一些参数：建立时间 &lt;code&gt;setup time&lt;/code&gt;、保持时间 &lt;code&gt;hold time&lt;/code&gt;、恢复时间 &lt;code&gt;recovery time&lt;/code&gt;、撤销时间 &lt;code&gt;removal time&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不满足这些参数的要求，则会发生所谓的 亚稳态 &lt;code&gt;Metastability&lt;/code&gt; 的问题。下面是 Altera 官方的一篇关于亚稳态的 white paper，详细介绍了亚稳态的产生原因、它是如何导致设计出现问题、以及描述它的参数 MTBF (Mean Time Between Failures) 如何计算。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf"&gt;Understanding Metastability in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们知道，一般只涉及单时钟域的设计并不多见，尤其是对于一些复杂的应用，FPGA 往往需要和多个时钟域的信号进行通信，而这些时钟之间的关系一般都是频率不同、相位也不同，也就是不同频不同相的多异步时钟域设计 &lt;code&gt;Mulit-Asynchronous Clock Design&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为这些时钟信号之间的关系一般既不同频也不同相，所以一个时钟域的信号对于另外一个时钟域来说是异步信号，那么就无法保证进入新时钟域的信号和新的时钟信号之间满足 setup/hold time 的要求，自然就会引起亚稳态的问题。&lt;/p&gt;
&lt;p&gt;在 Clifford E. Cummings 大神的 paper：&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt; 里面就举例说明了这种现象：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"When sampling a changing data signal with a clock ... the order of the events determines the outcome. The smaller the time difference between the events, the longer it takes to determine which came first. When two events occur very close together, the decision process can take longer than the time allotted, and a synchronization failure occurs."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Illustation 1: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="failure" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronization_failure.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Illustation 2: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不加处理，亚稳态产生的错误值将会传播到设计的其他部分，导致更加严重的问题&lt;/p&gt;
&lt;p&gt;&lt;img alt="propagatetion" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/propagation.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Synchronous Design&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;多时钟域导致的亚稳态的问题的根本原因就是：信号和时钟是异步的，也就是设计不是同步设计 &lt;code&gt;Synchronous Design&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步化设计思想&lt;/strong&gt; 是 FPGA 中非常重要的原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asynchronous Circuits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步电路的核心逻辑是用 组合逻辑 &lt;code&gt;combination logic&lt;/code&gt; 实现的，比如异步FIFO/RAM 读写信号、地址译码等电路。电路的主要信号、输出信号不依赖任何一个时钟信号，不是由时钟信号驱动 flip-flop 产生的。&lt;em&gt;异步电路最大的缺点就是容易产生毛刺。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous Circuits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步电路的核心逻辑是用 时序逻辑 &lt;code&gt;sequential logic&lt;/code&gt; 实现的。电路的主要信号、输出信号是由某个时钟沿驱动 flip-flop 产生的。&lt;em&gt;同步电路可以很好的避免毛刺。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous V.S. Asynchronous&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA高手设计实战真经100则&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从 ASIC 设计的角度来看，大约需要 7 个门来实现一个 D 触发器，而一个门即可实现一个2输入与非门，所以一般来说，在 ASIC 设计中，同步时序电路比异步电路占用更大的面积。但是，由于 FPGA 是定制好的底层单元，对于 Xilinx 器件，一个底层可编程单元 Slice 包含两个触发器（FF）和一个查找表（LUT）。其中触发器用以实现同步电路，查找表用以实现组合电路。FPGA 最终使用率用 Slice 来衡量。所以对于某个选定器件，其可实现的同步电路和异步电路的资源数量和比例是固定的，这点造成了过度使用查找表会浪费触发器资源，反之亦然。因而对于 FPGA，同步时序设计不一定比异步设计多消耗资源。单从节约资源的角度考虑，应该按照芯片配置的资源比例实现设计，但是设计者还要时刻权衡同步设计没有毛刺、信号稳定等优点，&lt;strong&gt;所以对于 FPGA 设计推荐采用同步设计。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是用离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字逻辑，为了成功操作，可靠的时钟是非常关键的。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为，FPGA 同步设计中最好的时钟解决方案是由专用全局时钟输入引脚驱动单个主时钟去控制设计项目中的每一个触发器。系统中各个功能模块使用同一同步复位信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FPGA 同步设计中，时序电路应尽量采用同步电路，尽可能使用同步器件，尽量减小或不使用门控时钟（为了降低系统功耗以外）。设计中不用系统主时钟经过逻辑运算得到控制信号，避免使用非时钟信号作为触发器的时钟输入。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面提到的所有方法，就是同步化思想的应用，其核心目的就是将本时钟域外的 &lt;strong&gt;异步信号同步化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Solution 1: Daul Rank Synchronizer&lt;/h3&gt;
&lt;p&gt;通常使用 &lt;code&gt;MTBF (Mean Time Between Failures)&lt;/code&gt; 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。&lt;/p&gt;
&lt;p&gt;以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57×109 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。&lt;/p&gt;
&lt;p&gt;理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronizer" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer.png" /&gt;&lt;/p&gt;
&lt;p&gt;通常，同步器 synchronizer 由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。&lt;/p&gt;
&lt;p&gt;为了让 synchronizer 正常工作，从某个 时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入 synchronizer。之所以这样要求，是因为 synchronizer 的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过 synchronizer，给新时钟域后续逻辑一个虚假的信号。&lt;/p&gt;
&lt;p&gt;synchronizer 有很多设计方法，因为一种方法不能满足所有的应用需求。synchronizer 的类型基本上分为 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;level synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;edge-detecting synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pulse synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面分别讨论：&lt;/p&gt;
&lt;h4&gt;level synchronizer&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;paper&lt;/a&gt; 中有更详细的图解说明：&lt;/p&gt;
&lt;p&gt;&lt;img alt="level" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/level.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;LVLSYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// input&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// output&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// output attribute&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;din_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;dout_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// reg the din using orign clock&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;din_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;din_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;// using two level DFF to synchronize the din_q&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="level rtl" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/level_rtl.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 level synchronizer 的要求是：跨域时钟域的这个信号持续时间 &amp;gt;= 2 个新时钟域时钟周期。&lt;/p&gt;
&lt;p&gt;之所以这样要求是因为：synchronizer 要花费两个时钟周期来同步这个异步信号，如果这个信号长度短于两个时钟周期，则不能正常工作。&lt;/p&gt;
&lt;p&gt;level synchronizer 是其他两种同步器的核心。&lt;/p&gt;
&lt;h4&gt;edge-detecting synchronizer&lt;/h4&gt;
&lt;p&gt;边沿检测同步器 是在 level synchronizer 的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="edge-detecting" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/edge-detecting.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;EDGESYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// input&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// output&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;din_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;dout_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;dout_qr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;dout_qrr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// reg the din using orign clock&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;din_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;din_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;// using two level DFF to synchronize the din_q&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout_qr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout_qrr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout_qr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout_qrr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout_qr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dout_qrr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;dout_qr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="edge rtl" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/edge_rtl.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 edge-detecting synchronizer 的要求是：输入信号的宽度 &amp;gt;= 同步时钟周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。&lt;/p&gt;
&lt;p&gt;edge-detecting synchronizer 在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用 pusle synchronizer。&lt;/p&gt;
&lt;h4&gt;pulse synchronizer&lt;/h4&gt;
&lt;p&gt;脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="pusle" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/pulse.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 pusle synchronizer 的要求是：输入脉冲之间的最小间隔 &amp;gt;= 2 个同步时钟周期。&lt;/p&gt;
&lt;p&gt;如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻。&lt;/p&gt;
&lt;h4&gt;Summary&lt;/h4&gt;
&lt;p&gt;总结 3 种同步器的特点，有下表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronizer sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer_sum.png" /&gt;&lt;/p&gt;
&lt;p&gt;经过 synchronizer 的信号在两个时钟之后变为有效，一般延时为 1～2 新时钟周期，可以粗略估计延时为 2 个时钟周期，设计者需要仔细考虑同步延迟对于跨时钟域的信号时序造成的影响。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在许多应用中，跨时钟域传送的不只是简单的信号，数据总线、地址总线、控制总线都会同时跨域传输，这时候就不再适合用 synchronizer 来同步这些信号了，通常采用其他的方法，比如握手协议和 FIFO 等。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Solution 2: Handshaking&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Handshaking allows digital circuits to effectively communicate with each other when the response time of one or both circuits is unpredictable. For example, an arbitrated bus allows more than one circuit to request access to a single bus, such as PCI or AMBA (Advanced Microcontroller Bus Architecture), using arbitration to determine which circuit gains access to the bus. Each circuit signals a request, and the arbitration logic determines which request “wins.” This winning circuit receives an acknowledgment indicating that it has access to the bus. It then discontinues its request and begins the bus transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有两种基本握手协议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Full-handshaking&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Partial-handshaking&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种握手协议都要用到 synchronizer，每种都有各自的优缺点，下面分别讨论：&lt;/p&gt;
&lt;h4&gt;full handshaking&lt;/h4&gt;
&lt;p&gt;&lt;img alt="full" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/full.png" /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，全握手协议中，双方电路在声明或中止各自的握手信号前都要等待对方的相应。首先，发送方电路A声明它的请求信号，然后接收方电路B检测到该请求有效后，声明它的效应信号；当电路A检测到响应信号有效之后，中止自己的请求信号；最后，当电路B检测到请求无效之后，中止自己的相应信号。这样，算是完成了一次通信。除非A检测到无效的响应信号，否则它不会再声明新的请求信号。这种机制要求请求电路A必须延迟它的下一个请求，直到它检测到无效的响应信号（意味着上次请求已完成）。&lt;/p&gt;
&lt;p&gt;这种类型的握手使用了 level synchronizer。可以根据两点来粗略估计这个协议的时序：信号跨域一个时钟域需要花费 2 个时钟周期，信号在跨域时钟域之前被电路寄存花费 1 个时钟周期。所以，发送端A需要 5 个周期，接收端B需要 6 个周期。&lt;/p&gt;
&lt;p&gt;全握手鲁棒性很好，因为通过检测请求和响应信号，每个电路都清楚地知道对方的状态，这种方式的不足之处是完成整个过程要花费很多时钟周期。&lt;/p&gt;
&lt;h4&gt;partial handshaking&lt;/h4&gt;
&lt;p&gt;另一中类型是部分握手。部分握手的双方不用等对方的响应就中止各自的信号，并继续执行握手命令序列。&lt;/p&gt;
&lt;p&gt;部分握手比全握手在健壮性方面稍弱，因为握手信号并不指示各自电路的状态，每一电路都必须保存状态信息（在全握手里这个信息被送出去），但是，由于无需等待对方的响应，完整的时间序列花费较少的时间。&lt;/p&gt;
&lt;p&gt;有两种类型的部分握手：&lt;/p&gt;
&lt;p&gt;第一种握手方法中，电路A以有效电平声明其请求信号，电路B以一个单时钟宽度脉冲作为响应。此时，电路B并不关心电路A何时中止它的请求。&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial-1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;但是为了这种方法成立，电路A中止请求信号至少要 1 个时钟周期长度，否则，电路B就不能区别前一个和后一个新的请求。&lt;/p&gt;
&lt;p&gt;在这种握手方式下，电路B为请求信号使用一个 level synchronizer；电路A为响应信号使用一个 pusle synchronizer。只有当电路B检测到请求信号时才发出响应脉冲，这样电路A控制请求信号的时序，就能控制自己synchronizer接收到的脉冲间隔。&lt;/p&gt;
&lt;p&gt;同样，使用前面的方法可以估算出这种握手协议的时序：发送端电路A需要花费 3 个时钟周期，接收端B需要花费 5 个时钟周期。&lt;/p&gt;
&lt;p&gt;第二种握手方法中，电路A使用一个单时钟宽度脉冲发出它的请求，电路B也以一个单时钟宽度脉冲响应这个请求。这种情况下，两个电路都需要保存状态，以指示请求正待处理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial-2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;这种握手使用的是 pusle synchronizer。完整的时序是：电路A需要花费 2 个时钟周期，电路B需要花费 3 个时钟周期。&lt;/p&gt;
&lt;h4&gt;summary&lt;/h4&gt;
&lt;p&gt;&lt;img alt="handshaing sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/handshaking_sum.png" /&gt;&lt;/p&gt;
&lt;p&gt;因为 handshaking 内部采用了 synchronizer，所以可以解决异步信号导致的亚稳态现象。根据实际要求，选择不同的 synchronizer 和握手信号，就有了前面介绍的 3 种不同的 handshaking：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;full handshaking
是最健壮的，因为在这种机制下，两部分电路都在等待收到对方的确认信号之后才发送新的握手信号，两部分电路是相互都知道对方目前所处于的状态，而且用了两组握手信号（request/acknowledge，de-request/de-acknowledge），相当于完成了两次握手。但是，最健壮的代价就是花费的时间最长，而且要求信号在收到对方的回复之前要保持不变，这就限制了发送信号的速率和节奏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial handshaking 是对 full 的精简，动机就是减少握手所花费的时间，从减少花费时间的方法上，就有了两种不同的 partial shandshaking。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial I 精简了 1 个握手信号 de-acknowledge，剩下了 3 个握手信号，相当于完成了1次半的握手。而且修改了 full 中 level synchronizer 的方式，接收电路 B 发送的不再是电平信号，而是一个单时钟宽度的脉冲，所以电路A则必须使用 pusle synchronizer 来检测来自 B 的握手信号。通过减少一个握手信号和改进一方的 synchronizer，partial I 就比 full 方式节约了很多时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial II 则更进一步，在 partial I 的基础上又精简掉一个握手信号，只剩下 2 个握手信号，只完成1次握手。而且两部分电路的 synchronizer 同时修改为 pusle 方式。这样子进一步减少了握手花费的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial 和 full 的本质区别不在于synchronizer 的类型和握手信号的多少，而在于握手的方式。 partial 不用再等待对方的回答，就继续进行自己的下一步操作，而 full 必须等到对方的回复才进行下一步的操作，所以从某种意义上，full 方式才是真正的“握手”，而 partial 并不符合 “握手” 的意思，毕竟根本不管对方的反应，自顾自地挥手叫哪门子的握手 =.=&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;这些握手协议针对的都是跨时钟域的单一信号，但当几组信号要跨越时钟域时，设计者就需要更加复杂的信号传递方法。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Solution 3: Datapath Design&lt;/h3&gt;
&lt;p&gt;在进行信号同步时，有一个重要的原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不应该在设计中的多个地方对同一信号进行同步，即禁止单个信号扇出至多个同步器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为synchronizer要花 1~2 个时钟周期，设计者不能确切预测到每个信号何时跨越时钟域，此外，在新时钟域中一组经过同步后的信号其时序是不定的，因为synchronier的延迟可以是 1～2 个时钟周期，这种情况下各个同步信号间形成一种“竞争状况”，这种竞争状况在需要跨域时钟域传输的多组信号间也会发生，例如数据总线、地址总线、控制总线等。因此，&lt;strong&gt;不能对组中的每个信号单独使用synchronizer，也不能对数据/地址总线的每一位单独使用同步器&lt;/strong&gt;，因为在新的时钟域中，要求每个信号同时有效。&lt;/p&gt;
&lt;h4&gt;problem&lt;/h4&gt;
&lt;p&gt;Clifford E. Cummings 在他的文章中举例说明了几种常见的错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. &lt;strong&gt;Simply using synchronizers on all control signals is not always good enough&lt;/strong&gt; as will be shown in the following examples. &lt;/p&gt;
&lt;p&gt;If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem - Two simultaneously required control signals&lt;/strong&gt;
 a register in the new clock domain requires both a load signal and an
enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded.&lt;/p&gt;
&lt;p&gt;&lt;img alt="problem 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Solution - Consolidating control signals before passing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem - Two phase-shifted sequencing control signals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop.&lt;/p&gt;
&lt;p&gt;&lt;img alt="problem 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Solution - Logic to generate the proper sequencing signals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution_2.png" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;solution&lt;/h4&gt;
&lt;p&gt;有一种解决这个问题的方法是：&lt;strong&gt;使用一个保持寄存器 + 一个握手信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath.png" /&gt;&lt;/p&gt;
&lt;p&gt;保持寄存器保持信号总线的数据，握手信号指示目标时钟域何时可以对总线进行采样，源时钟域何时可以更换当前寄存器中保存的内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In this design, the transmitting circuit stores the data (signal bus) in the holding register as it asserts the request signal. These two actions can happen at once because the request signal takes at least one clock cycle before the receiving circuit detects it (the minimum handshake-synchronization delay). When the receiving circuit samples the data (signal bus), it asserts the acknowledgment signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细分析一下，其实这里采用的原理类似于握手协议。&lt;/p&gt;
&lt;p&gt;当有一组新的数据出现在数据总线上需要跨时钟域时，额外添加一对握手信号 request/acknowledge，这对信号对于两个时钟域来说分别是异步信号（接收电路不知道何时会收到request，发送电路也不知道何时会获得acknowledge），可能会产生亚稳态的问题，所以在两个时钟域对它们分别用 synchronizer 进行同步。&lt;/p&gt;
&lt;p&gt;和request一起送过来的还有数据总线 上的数据信号，但是对于数据信号，不能简单地对每一位使用 synchronizer 来同步（原因前面已经说过了）。虽然对于接收电路来说，数据总线上的数据也是异步的，但是我们可以强制要求在握手过程中，数据保持不变，这样虽然数据是异步的，只要发送端满足保持寄存器数据在握手过程中不变化这一条件，那么即使数据总线上的数据到达接收时钟域有一些小的偏差 skew，但是不会超出 1 个时钟周期，在 synchronizer 最好的状态下，只花费了 1 个时钟周期就同步到了握手请求request，这时候数据总线上的数据已经是稳定不变的有效数据了，所以可以采样到正确的有效数据，不会存在亚稳态的问题。&lt;/p&gt;
&lt;p&gt;采用这种方法可以避免亚稳态的出现的原因就是它规定了异步信号（保持寄存器）什么时候可以变化，虽然是异步信号，但是在采样的时候人为地确保了它保持稳定，满足 setup/hold time 的要求，所以不会有亚稳态的问题。&lt;/p&gt;
&lt;p&gt;这里的握手机制可以采用 full handshaking，也可以采用 partial handshaking，设计者应该根据实际需求来选择。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt; 这本书中，有详细的时序图来说明了一种握手机制下，这种机制采用了 full handshaking 中等待对方的方法，但是对握手信号进行了精简（partial II 类型）。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="datapath timing" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath_timing.png" /&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;如果发送端的数据速率很快/无法控制发送端发送数据的速度，那么就有可能无法满足握手机制中要求数据保持稳定这一要求，这时候这种方法就不再适用，而应该采用其他的方法，比如 FIFO。&lt;/p&gt;
&lt;h3&gt;Solution 4: Advanced Datapath Design&lt;/h3&gt;
&lt;p&gt;有时候，数据在跨时钟域时需要“堆积”起来，这时候只使用单个的寄存器就无法完成工作。比如某个传输电路突发式地发送数据，接收电路来不及采样，为了保持数据不丢失，就必须先把数据存储起来；还有一种情况是接收电路的采样速率比发送速度快，但是位宽却不够，仍然需要将没有采样的数据先暂存起来，这时候就需要使用 FIFO。&lt;/p&gt;
&lt;p&gt;基本上，使用 FIFO 的目的有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;速度匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宽度匹配&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FIFO 的实现可以直接使用 IP core，也可以自己写代码实现。&lt;/p&gt;
&lt;p&gt;如果是自己写代码实现，那么异步信号的问题还是需要我们在实现 FIFO 是仔细考虑的；如果是采用 IP core 的方式，那么可以很大程度地缓解我们的压力，因为事实上我们是把异步信号的问题交给了设计 IP core 的人来处理...这些 IP core 在内部针对异步数据读写的问题作了非常严谨复杂的设计，对外提供了非常简单的接口。采用这种方式虽然轻松，但是相应的地也有缺点：耗费更多的资源。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt; 和 &lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt; 两篇 paper 和 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中都有一些实现 FIFO 使用的相关技术的介绍，比如指针逻辑的处理，内部 gray code 计数器的实现等。这里就偷懒不细说了（以后再补） :P&lt;/p&gt;
&lt;p&gt;----------------Update March/12/2015------------------------&lt;/p&gt;
&lt;p&gt;FIFO 的目的在于解决数据跨时钟域传输的问题，但是在实现FIFO本身时，一些内部的握手信号也需要跨时钟域，这时候需要用到之前讨论过的dual rank synchronizer等技术。&lt;/p&gt;
&lt;p&gt;比如FIFO内部的地址计数器，如果使用dual rank synchronizer来同步，计数器的不同的bit可能会在不同的时钟周期内传递过去，这时接收到的数据就是错误的，对导致致命性的问题。&lt;/p&gt;
&lt;p&gt;而对应这个问题的解决方法就是使用 gray code。&lt;/p&gt;
&lt;p&gt;--------------end of update---------------------------------&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于跨时钟域 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;papaer1&lt;/a&gt; 中还有一些其他方面的技巧，可以帮助我们更好的实现设计。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Design Partitioning&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Only allow one clock per module.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Static timing analysis and creating synthesis scripts is more easily accomplished on single-clock modules or groups of single-clock modules.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Create a synchronizer module for each set of signals that pass from just one clock domain into another clock domain.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It is given that any signal passing from one clock domain to another clock domain is going to have setup and hold time problems. No worst-case (max time) timing analysis is required for synchronizer modules. Only best case (min time) timing analysis is required between first and second stage flip-flops to ensure that all hold times are met. Also, gate-level simulations can more easily be configured to ignore setup and hold time violations on the first stage of each synchronizer.&lt;/p&gt;
&lt;p&gt;采用这种设计方式的原因如上所示，可以减少不必要的时序验证，而且脚本也更容易写，总之可以使时序验证工作更容易。&lt;/p&gt;
&lt;p&gt;举例如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="partitioning" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partitioning.png" /&gt;&lt;/p&gt;
&lt;h3&gt;Clock Name Conventions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use a clock naming convention to identify the clock source of every signal in a design.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A naming convention helps all team members to identify the clock domain for every signal in a design and also makes grouping of signals for timing analysis easier to do using regular expression "wild-carding" from within a synthesis script.&lt;/p&gt;
&lt;p&gt;作者还举例说明了一个这样的例子：1995 年为 In Focus projectors 设计 video ASIC 时，他们就采用了这样的方法，对于 mircroprocessor 的时钟命名为 uClk，对于 video 的时钟则命名为 vClk。对应的时钟域中的信号的名字也添加了对应的前缀，比如udata，uwrite，uadder等。&lt;/p&gt;
&lt;p&gt;使用了这样的策略后，整个设计团队的攻城狮们都可以很方便地确定某个信号是否为异步信号，如何处理。当时有个攻城狮没有按照这种策略，使用了自己的命名方式，在一次会议之后，大家墙裂建议他修改命名，结果也证明修改之后遇到的问题、出错的概率都小了很多。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;in ASIC&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;虽然 FPGA 可以用来为 ASIC 搭建原型，但是一些 ASIC 中的技术并不适用于 FPGA，比如 gated clock。一般也没有必要在 FPGA 中模拟 ASIC 的低功耗优化。事实上，由于 FPGA 时钟资源的的粗颗粒度性，并不是总能模拟成功。&lt;/p&gt;
&lt;p&gt;下面简单讨论一下 ASIC 中 gated clock 的问题。（更详细的内容见 gated clock 文章，未写）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;dedicated clock module&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;guideline&lt;/strong&gt;: 将全部的 gated clock 时钟放在一个专门的时钟模块中，并将其从功能模块中分离出来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reason&lt;/strong&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;约束更加容易处理&lt;/li&gt;
&lt;li&gt;FPGA 设计修改起来更容易（比如通过 #define 来选择编译 ASIC 还是 FPGA 设计，选择两者各自的实现代码）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gating removal&lt;/p&gt;
&lt;p&gt;在 FPGA 上建立模型时，有很多巧妙的方法去除 gated clock。比如下面这个例子就是最直观，但也是最繁琐的方法：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;`define FPGA&lt;/span&gt;
&lt;span class="c1"&gt;// `define ASIC&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;clock_blocks&lt;/span&gt; &lt;span class="p"&gt;(...)&lt;/span&gt;

    &lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="no"&gt;ASIC&lt;/span&gt;
        &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;clock_domain_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;system_clock_1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;clock_enable_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="no"&gt;`else&lt;/span&gt;
        &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;clock_domain_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;system_clock_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这种方法的缺点是当做出改动时，需要对 FPGA 和 ASIC 代码都作出修改。很多人对这种方式很不爽，因为他们必须写两种不同的 RTL 代码。&lt;/p&gt;
&lt;p&gt;一种更加高级的方法是依靠工具，现代的很多综合工具都可以通过适当的约束，通过将条件并到数据通路，来自动消除 gated clock。&lt;/p&gt;
&lt;p&gt;比如下面的这段代码：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;clockstest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;  &lt;span class="n"&gt;oDat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;        &lt;span class="n"&gt;iClk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;        &lt;span class="n"&gt;iEnable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;        &lt;span class="n"&gt;iDat&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;wire&lt;/span&gt;  &lt;span class="n"&gt;gated_clock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;iClk&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iEnable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;gated_clock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;oDat&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;iDat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;如果不打开自动消除的开关，产生的 gated clock 电路如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="circuit1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/circuit1.png" /&gt;&lt;/p&gt;
&lt;p&gt;如果打开自动消除的开关，产生的没有 gated clock 电路如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="circuit2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/circuit2.png" /&gt;&lt;/p&gt;
&lt;p&gt;现在大多数器件都提供了一个时钟使能（clock enable）端口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果器件提供了这种接口，那么就没有必要使用上述方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件没有提供这种端口，那么使用这种技术虽然可以消除 gated clock，但是付出的代价是增加了 data path 的 delay。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;以上，就是一些在多时钟域设计中处理异步数据的常用方法，总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于普通的单比特的数据，根据实际情况选择对应的 synchronizer 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于其他的信号，比如数据总线、地址总线、控制总线等数据，可以使用握手协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总线上的数据要求同时到达新的时钟域，所以不要对总线上的信号分别进行同步，而要采用一个保持寄存器 + 握手信号的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还可以采用 FIFO 来处理异步数据的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分块设计，尽可能保证一个模块只有一个时钟域，对于跨时钟域信号，写独立的同步模块，这样可以减轻时序验证的工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用良好的命名习惯，如前缀的方式，可以帮助设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意 ASIC 和 FPGA 中对时钟信号的不同处理方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA高手设计实战真经100则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_174906.HTM"&gt;ASIC中的异步时序设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_175526.HTM"&gt;跨越鸿沟：同步世界中的异步信号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf"&gt;Understanding Metastability in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2878096/"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt;&lt;/p&gt;</summary><category term="clock design"></category></entry><entry><title>锁存器 Latch v.s. 触发器 Flip-Flop</title><link href="http://guqian110.github.io/pages/2014/09/23/latch_versus_flip_flop.html" rel="alternate"></link><updated>2014-09-23T23:02:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-09-23:pages/2014/09/23/latch_versus_flip_flop.html</id><summary type="html">&lt;p&gt;根据 &lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;Wiki: Flip-flop (electronics)&lt;/a&gt; 上的介绍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In electronics, a &lt;code&gt;flip-flop&lt;/code&gt; or &lt;code&gt;latch&lt;/code&gt; is a circuit that has two stable states and can be used to store state information. A flip-flop is a &lt;code&gt;bistable multivibrator&lt;/code&gt;. The circuit can be made to change state by signals applied to one or more control inputs and will have one or two outputs. It is the basic storage element in sequential logic. Flip-flops and latches are a fundamental building block of digital electronics systems used in computers, communications, and many other types of systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区别一下名字：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flip-flops can be either simple (transparent or opaque) or clocked (synchronous or edge-triggered). Although the term flip-flop has historically referred generically to both simple and clocked circuits, in modern usage it is common to reserve the term flip-flop exclusively for discussing clocked circuits; the simple ones are commonly called latches.&lt;/p&gt;
&lt;p&gt;Using this terminology, a latch is level-sensitive, whereas a flip-flop is edge-sensitive. That is, when a latch is enabled it becomes transparent, while a flip flop's output only changes on a single type (positive going or negative going) of clock edge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以按照现在的约定习惯区分，latch 指的是电平触发的触发器，翻译为 “锁存器”；flip-flop 指边沿触发的触发器，就叫 “触发器”。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2&gt;History&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;翻译自 &lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;wiki&lt;/a&gt;:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;第一个电子触发器(electronic flip-flop) 由  William Eccles 和 F. W. Jordan 于 1918 年发明的。它最早被称为 ：  &lt;code&gt;Eccles–Jordan trigger circuit&lt;/code&gt;，由两个真空管组成。虽然现在由逻辑门 (logic gates)组成的触发器很常见，但是在集成电路(intergrated circuits)中，这种元件及它的晶体管版本仍然也很常见。早期的触发器常用来构成触发电路或者多谐振荡器(multivibrators)。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flip-flop" src="http://upload.wikimedia.org/wikipedia/commons/9/98/Eccles-Jordan_trigger_circuit_flip-flip_drawings.png" /&gt;&lt;/p&gt;
&lt;p&gt;根据一个 JPL 的工程师，P. L. Lindley介绍，Montgomery Phister 于 1954 年在 UCLA 的 computer design 的课程上第一次对触发器进行了分类的讨论（RS、D、T、JK），然后在他的书 Logical Design of Digital Computers 中也进行了讨论。Lindley 当时在 Hughes Aircraft 的 Eldred Nelson 手下工作，而Nelson 命名了 JK 触发器。其他的名字则是 Phister 命名的。Lindley 解释说他是从 Nelson 口中得知 JK 触发器的故事的，当时 Hughes Aircraft 使用的触发器都是 JK 触发器。在设计逻辑系统时，Nelson 给触发器的输入命名为 A&amp;amp;B、C&amp;amp;D、E&amp;amp;F、G&amp;amp;H、J&amp;amp;K。在 1953 年 Nelson 申请专利时，采用了 J&amp;amp;K 的命名方案。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Flip-flops can be either simple (transparent or asynchronous) or clocked (synchronous); the transparent ones are commonly called latches. The word latch is mainly used for storage elements, while clocked devices are described as flip-flops.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不会翻译了...大意就是说 flip-flop 可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;simple&lt;/p&gt;
&lt;p&gt;也可以说是 透明的(transparent) 或者是 异步的(asynchronous)，通常称为 &lt;code&gt;锁存器Latch&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;clocked&lt;/p&gt;
&lt;p&gt;也可以说是 同步的(synchronous)，称为 &lt;code&gt;触发器flip-flop&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分类讨论：&lt;/p&gt;
&lt;h3&gt;Latch&lt;/h3&gt;
&lt;p&gt;Latch 可以由一对真空管、三极管、场效应管组成，在实际应用中也可以用逻辑门组成 latch。&lt;/p&gt;
&lt;h4&gt;SR Latch&lt;/h4&gt;
&lt;p&gt;当使用逻辑门搭建模块时，最基本的 latch 就是 &lt;code&gt;SR latch&lt;/code&gt; (set-reset latch)，所有的 latch 和 flip-flop 都是建立在它的基础之上。&lt;/p&gt;
&lt;p&gt;SR latch 的实现可以有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SR NOR Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用或非门搭建：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor" src="http://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif" /&gt;&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor" src="/images/latch_versus_flip_flop/nor.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;S'R' NAND Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用与非门搭建：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand" src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/92/SR_Flip-flop_Diagram.svg/500px-SR_Flip-flop_Diagram.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand" src="/images/latch_versus_flip_flop/nand.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;D Latch&lt;/h4&gt;
&lt;p&gt;Latch 是 &lt;code&gt;透明的(transparent)&lt;/code&gt;，就是说输入的变换立即就能传递到输出端口，当几个透明的 latch 级联时，输入端的信号也能立即传递到输出端。当给 latch 添加额外的逻辑电路（比如使能信号 enable 无效时），就会使它变为 &lt;code&gt;不透明的(non-transparent)&lt;/code&gt;。下面的 D latch 就是这样的例子。&lt;/p&gt;
&lt;p&gt;仔细观察 SR latch 的功能表，就可以发现，R 的取值为 S 的补。D latch 利用了这一特点，而且避免了 SR latch 中的禁止状态的出现。&lt;/p&gt;
&lt;p&gt;因为 SR latch 的实现有两种，所以 &lt;code&gt;D latch&lt;/code&gt; 的实现也对应有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NOR D Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/D-type_Transparent_Latch_%28NOR%29.svg/500px-D-type_Transparent_Latch_%28NOR%29.svg.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NAND D Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/D-Type_Transparent_Latch.svg/500px-D-Type_Transparent_Latch.svg.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;D latch 的功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="d latch" src="/images/latch_versus_flip_flop/d_latch.png" /&gt;&lt;/p&gt;
&lt;p&gt;D latch 也称为  non-transparent、data latch、gated latch。它有一个数据输入端和一个使能端 enable(clock、control)。之所以叫透明，是因为当它使能时，输入端口的信号立刻就能传递到输出端口。&lt;/p&gt;
&lt;h3&gt;Flip-Flop&lt;/h3&gt;
&lt;p&gt;如果 D latch 的控制端口加入时钟信号，就得到了基本触发器，只要时钟信号 CP = 1，则触发器就会受到触发，当 CP 保持为 1 时，数据输入端口的任何变化都将影响到 latch 的状态。&lt;/p&gt;
&lt;p&gt;latch 的这个特点应用到 时序电路中，就会出现比较严重的问题：&lt;/p&gt;
&lt;p&gt;一般时序逻辑的输出会经过组合电路的反馈通道，返回到时序逻辑的输入。当时钟信号有效时，latch 的输出通过组合电路反馈到 latch 的输入端，如果经过组合逻辑后，反馈的信号和之前的信号不同，则反馈信号会导致 latch 的输出变为新的值。在时钟信号有效的期间内，latch 的输出一直在变化，出现了不可预测的结果，这是不可靠的工作。&lt;/p&gt;
&lt;p&gt;latch 的&lt;strong&gt;问题&lt;/strong&gt;就在于：&lt;em&gt;它在时钟有效期间内一直在被触发，这种触发时间过长。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个问题的&lt;strong&gt;解决方法&lt;/strong&gt;就是：&lt;em&gt;将触发条件变为时钟沿触发，这样就得到了触发器 &lt;code&gt;flip-flop&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;D flip-flop&lt;/h4&gt;
&lt;p&gt;将 latch 改造为边沿敏感的触发器，最简单的就是 &lt;code&gt;D flip-flop&lt;/code&gt; (data or delay)，搭建电路最经济有效的方法就是使用 DFF，因为它需要的门电路最少，其他类型的触发器都是在 DFF 的基础上得到的。&lt;/p&gt;
&lt;p&gt;实现 DFF 可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Classical positive-edge-triggered D flip-flop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="classical" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/99/Edge_triggered_D_flip_flop.svg/500px-Edge_triggered_D_flip_flop.svg.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Master–slave edge-triggered D flip-flop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="master-slave" src="http://upload.wikimedia.org/wikipedia/en/thumb/5/52/Negative-edge_triggered_master_slave_D_flip-flop.svg/500px-Negative-edge_triggered_master_slave_D_flip-flop.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;clk = 1 时，master D-latch 使能，D 传递到输出端 Q；&lt;/p&gt;
&lt;p&gt;clk = 0 时，slave D-latch 使能，输入 D (master D-latch 的输出 Q) 传递到输出 Q；&lt;/p&gt;
&lt;p&gt;可以看到，当 clk 从 1 变为 0 时，输入端的 D 才传递到输出端 Q，也就是说在时钟的下降沿才触发，其他时刻都保持输出不变。（如果需要上升沿触发，只需要在 clk 输入端键入一个反相器）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFF 的特点就是在时钟信号的特定点触发（上升沿 or 下降沿），功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/latch_versus_flip_flop/dff.png" /&gt;&lt;/p&gt;
&lt;h4&gt;JK flip-flop&lt;/h4&gt;
&lt;p&gt;在 DFF 的基础上，可以得到 JK FF。&lt;/p&gt;
&lt;p&gt;JK FF 的特点和 SR latch 类似，可以将 J 看作是 S，K 看作是 R，它和 SR latch 的区别在于它是边沿触发，并且将 S = R = 1 状态设置为 &lt;code&gt;翻转 (toggle)&lt;/code&gt;，也就是在下一个时钟边沿，输出取反。当 J = K = 0 时，得到的并不是 DFF，而是保持输出不变。&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="jk" src="/images/latch_versus_flip_flop/jk.png" /&gt;&lt;/p&gt;
&lt;h4&gt;T flip-flop&lt;/h4&gt;
&lt;p&gt;将 JK FF 的输入端 J 和 K 连接到一起，就可以得到 &lt;code&gt;T FF&lt;/code&gt; (toggle flip-flop)。&lt;/p&gt;
&lt;p&gt;当 T = 0 (J = K = 0) 时，输出保持不变，时钟边沿不影响状态；当 T = 1 (J = K = 1) 时，在时钟边沿输出反相，也就是翻转。&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="tff" src="/images/latch_versus_flip_flop/tff.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到 TFF 有 1/2 分频的作用，这一特点在很多电路中得到了应用。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Timing considerations&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Metastability&lt;/h3&gt;
&lt;p&gt;伴随着 flip-flop 的一个问题是 &lt;code&gt;亚稳态 Metastability&lt;/code&gt;。当两个输入端口 (比如 data 和 clk，或者 reset 和 clk)同时变化时，就会发生亚稳态的问题，需要消耗更长的时间来使输出达到稳定状态，而且这个稳定状态是不可预测的，有可能是 1，也有可能是 0。&lt;/p&gt;
&lt;p&gt;在计算机系统中，如果发生亚稳态，如果在下一个时钟使用数据时，还没有达到稳定状态，会导致数据传输错误或者程序崩溃。如果有两条路径同时用到了这个数据，有可能一条将它当作 1，另一条把它当作 0，这样会导致系统进入不一致的状态。&lt;/p&gt;
&lt;h3&gt;Setup, hold, recovery, removal times&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Setup time&lt;/strong&gt; is the minimum amount of time the data signal should be held steady &lt;strong&gt;before&lt;/strong&gt; the clock event so that the data are reliably sampled by the clock. This applies to synchronous input signals to the flip-flop.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hold time&lt;/strong&gt; is the minimum amount of time the data signal should be held steady &lt;strong&gt;after&lt;/strong&gt; the clock event so that the data are reliably sampled. This applies to synchronous input signals to the flip-flop.&lt;/p&gt;
&lt;p&gt;Synchronous signals (like Data) should be held steady from the set-up time to the hold time, where both times are relative to the clock signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="meta" src="http://upload.wikimedia.org/wikipedia/en/thumb/d/d9/FF_Tsetup_Thold_Toutput.svg/500px-FF_Tsetup_Thold_Toutput.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，对于同步信号 (同步信号的意思是想对于时钟信号而言，它的变化和时钟是同步的，比如 data)，必须满足 &lt;code&gt;setup time&lt;/code&gt; 和 &lt;code&gt;hold time&lt;/code&gt; 要求。&lt;/p&gt;
&lt;p&gt;在有效时钟沿到来之前的 setup time 时间段内，同步信号必须保持稳定，在有效时钟沿到来之后的 hold time 时间段内，同步信号也必须保持稳定，也就是说从 setup time 到 hold time 之间，它必须保持稳定不变化，这样才能让时钟信号采样到正确的值。&lt;/p&gt;
&lt;p&gt;同理，对于异步信号，有类似的要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recovery time&lt;/strong&gt; is like setup time for asynchronous ports (set, reset). It is the time available between the asynchronous signals going inactive and the active clock edge.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Removal time&lt;/strong&gt; is like hold time for asynchronous ports (set, reset). It is the time between active clock edge and asynchronous signal going inactive.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找到一个更清晰的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recovery time&lt;/strong&gt; is the minimum length of time an asynchronous control signal, for example, and preset, must be stable &lt;strong&gt;before&lt;/strong&gt; the next active clock edge. The recovery slack time calculation is similar to the clock setup slack time calculation, but it applies asynchronous control signals.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Removal time&lt;/strong&gt; is the minimum length of time an asynchronous control signal must be stable &lt;strong&gt;after&lt;/strong&gt; the active clock edge. The TimeQuest analyzer removal time slack calculation is similar to the clock hold slack calculation, but it applies asynchronous control signals.&lt;/p&gt;
&lt;p&gt;recovery time specifies the time the inactive edge of the asynchronous signal has to arrive before the closing edge of the clock.&lt;/p&gt;
&lt;p&gt;Removal time specifies the length of time the active phase of the asynchronous signal has to be held after the closing edge of the clock.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 Recovery / Removal time 类似于 Setup / Hold Time，不过是用于异步信号，比如 set，reset 信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="recovery-removal" src="/images/latch_versus_flip_flop/recovery-removal.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，在时钟沿到来之前的 recovery time 之前，异步信号必须释放 (变无效)，在时钟沿到来之后的 removal time 之后，异步信号才能变有效，也就是说在从 recovery time 到 removal time 这段时间内，异步信号是不能有效的。&lt;/p&gt;
&lt;p&gt;如果使 flip-flop 的输入满足 setup time 和 hold time，那么就可以避免亚稳态的出现，一般器件的手册上都会标明这些参数，从几 ns 到几百 ps 之间。根据 flip-flop 内的组织情况而定，有时候可以将 setup time 或者 hold time 两者中的一个（只能是其中之一）变为 0 甚至是负数。&lt;/p&gt;
&lt;p&gt;但是，并不是总能满足这一标准，因为有可能 flip-flop 的输入端连到了外界的，设计者无法控制的一个不断变化的信号，这时候设计者所能做的事就是根据电路要求，将发生错误的概率降低到一个确定的水平。通常使用的方法就是将信号通过一条链在一起的 flip-flop 组，这样子可以将发生亚稳态的概率降低到一个可以忽略的程度，但是还是不等于 0。链中的 flip-flop 越多，这个概率就越趋近于 0，通常的情况是采用 1 个或者两个 flip-flop。&lt;/p&gt;
&lt;p&gt;即使现在出现了所谓的 &lt;code&gt;metastable-hardened flip-flops&lt;/code&gt;，它可以尽可能地减小 setup time 和 hold time，但是仍然无法完全避免问题的出现。&lt;strong&gt;这是因为亚稳态并不是简单的设计方法上的问题。&lt;/strong&gt;当时钟信号和其他信号在相隔很近的时间内变化，flip-flop 必须判断哪一个先发生变化，哪一个后发生变化，无论我们的器件速度有多快，仍然有可能出现两者相隔的太近，以至于无法判断。所以理论上是不可能造出一个完美避免亚稳态的 flip-flop。&lt;/p&gt;
&lt;h3&gt;Propagation delay&lt;/h3&gt;
&lt;p&gt;flip-flop 还有一个参数叫做 clock-to-output delay (common symbol in data sheets: &lt;code&gt;tco&lt;/code&gt;) 或者是 propagation delay (&lt;code&gt;tp&lt;/code&gt;)，表示的是 flip-flop 从有效时钟沿开始到输出发生变化所消耗的时间。有时候从高电平变为低电平的时间 (high-to-low transition, tPHL))和从低电平变为高电平的时间 (low-to-high transition, tPLH) 不相等。&lt;/p&gt;
&lt;p&gt;当用同一时钟来驱动级联的 flip-flop (比如移位寄存器 shift register)时，必须保证前一级的 tco 要大于后一级的 th。这是因为必须要保证前一级的数据能够正确移位到后一级中。当有效时钟沿到来时，前后两级的 ff 在同时变化，采样前一级的输出作为本级的输入，然后经过 tco 输出更新的值。当后一级 ff 在 tsu 到 th 段内采样时，必须保证前一级的输出保持不变，也就是说前一级 ff 的响应速度不能太快，至少要等后一级正确采样完成之后才能变化，即 &lt;code&gt;tco &amp;gt; th&lt;/code&gt;。如果采用物理构造完全相同的 ff，那么通常是可以保证这一条件的。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;in FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;latch 和 flip-flop 的特点决定了它们各自的应用场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;latch 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面积比 ff 小&lt;/p&gt;
&lt;p&gt;门电路是构建组合逻辑电路的基础，而锁存器和触发器是构建时序逻辑电路的基础。门电路是由晶体管构成的，锁存器是由门电路构成的，而触发器是由锁存器构成的。也就是 晶体管-&amp;gt;门电路-&amp;gt;锁存器-&amp;gt;触发器，前一级是后一级的基础。latch完成同一个功能所需要的门较触发器要少，所以在asic中用的较多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度比 ff 快&lt;/p&gt;
&lt;p&gt;用在地址锁存是很合适的，不过一定要保证所有的latch信号源的质量，锁存器在CPU设计中很常见，正是由于它的应用使得CPU的速度比外部IO部件逻辑快许多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;latch 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电平触发，非同步设计，受布线延迟影响较大，很难保证输出没有毛刺产生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;latch将静态时序分析变得极为复杂&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;flip-flop 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;边沿触发，同步设计，不容易受毛刺的印象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析简单&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;flip-flop 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面积比 latch 大，消耗的门电路比 latch 多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前 latch 只在极高端的电路中使用，如 intel 的 P4 等 CPU。而在 PLD / FPGA 中，基本单元 LE 是查找表 LUT 和触发器 FF 组成的，如果要实现 latch，反而需要更多的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般的设计规则是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在绝大多数设计中避免产生 latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch 最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用 DFF 的地方，就不用 latch。&lt;/p&gt;
&lt;h3&gt;Reason &amp;amp; Solution to unexpected latch&lt;/h3&gt;
&lt;p&gt;在电路设计中，要对Latch特别谨慎，如果综合出和设计意图不一致的 Latch，会导致设计错误，包括仿真和综合。因此，要避免产生意外的 Latch。&lt;/p&gt;
&lt;h4&gt;Reason&lt;/h4&gt;
&lt;p&gt;如果组合逻辑完全不使用 always 语句，那么就不会产生 latch，比如&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;电路不需要保存 dout 的前一个值，所以不会产生 latch。&lt;/p&gt;
&lt;p&gt;如果组合逻辑使用了 always 语句，那么就有可能产生 Latch ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不完整的 if-else&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="if_latch" src="/images/latch_versus_flip_flop/if_latch.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不完整的 case&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="mh"&gt;2&amp;#39;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="mh"&gt;2&amp;#39;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="case_latch" src="/images/latch_versus_flip_flop/case_latch.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Solution&lt;/h4&gt;
&lt;p&gt;知道了原因，那么解决方法也就显而易见了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用完整的 if-else&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-else" src="/images/latch_versus_flip_flop/if_else.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用完整的 case，添加 default 分支&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="mh"&gt;2&amp;#39;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="mh"&gt;2&amp;#39;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;2&amp;#39;b00&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;RTL Schemtatic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="case-default" src="/images/latch_versus_flip_flop/case_default.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Application&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;《Verilog HDL 程序设计与实践》&lt;/a&gt; 笔记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;latch 作为一种电路单元,必然有其存在的理由以及应用场景,并不像目前的很多书籍简单地将锁存器列为“头等敌人”。其实在实际中,有些设计是不可避免地要用到锁存器,特别是在总线应用上,锁存器能提高驱动能力、隔离前后级。例如,常见的应用包括地址锁存器、数据锁存器以及复位信号锁存器等。但在更多的情况下,很容易在代码中产生未预料到的锁存器,使得逻辑功能不满足要求,浪费了大量的调试时间,从而使得大多数设计人员“闻虎色变”。&lt;/p&gt;
&lt;p&gt;因此较好的应用规则是:&lt;strong&gt;要学会分析是否需要锁存器以及代码是否会产生意想不到的锁存器。只有这样才能灵活运用锁存器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面通过实例来给予说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example1&lt;/strong&gt;: 通过Verilog HDL实现序列最大值搜索程序，并保持检测到的最大值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;latch_demo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  
          &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;  
      &lt;span class="p"&gt;);&lt;/span&gt;  
      &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
      &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="n"&gt;reg&lt;/span&gt;      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
       &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="n"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码在ISE中的综合结果会给出设计中包含Latch的警告。但实际上，abmax_tmp锁存器正是我们需要的，所以，虽然有警告，但是代码设计是没有问题的。将上述代码的if语句补全：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;abmax_tmp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
      &lt;span class="n"&gt;abmax_tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="k"&gt;else&lt;/span&gt;  
      &lt;span class="n"&gt;abmax_tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;abmax_tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;经过综合后，仍然有Latch的警告。无论Latch是否是用户需要的，ISE都会给出警告，主要原因就是Latch对整个设计的时序性能影响较大。所以，在设计中要尽量避免Latch，但是确实需要使用的情况，也可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example2:&lt;/strong&gt; 用Verilog HDL实现一个锁存器，当输入数据大于127时，将输入数据输出，否则输出0&lt;/p&gt;
&lt;p&gt;不期望的 latch 指的是与设计意图不符，产生的 Latch。主要问题在于设计人员没有合理使用Verilog HDL语言，常见的原因是对条件语句（if、casse）的分支描述不完整，导致电路的功能不是预期的，发生了错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;latch_demo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  
      &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;  
  &lt;span class="p"&gt;);&lt;/span&gt;  
  &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="n"&gt;output&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;reg&lt;/span&gt;      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
       &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="n"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;综合后的结果，在比较器后面级联了锁存器，这是因为if语句缺少else分支造成的。查看仿真结果，当输入小于127时，输出保持了上次的127，不是0，没有达到设计要求。修改方法很简单，就是将if-else补全。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
   &lt;span class="k"&gt;else&lt;/span&gt;  
       &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在ISE中综合后的结果中，可以看到补全if-else后，在比较器后面级联了与门，代替原来的锁存器，仿真结果也正确。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;锁存器 latch 是一种基本电路单元,会影响到电路的时序性能,应该尽量避免使用,但出现锁存器造成设计和原始意图不符的情况,则是由于设计人员代码输入不正确造成的。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;Flip-flop (electronics) --wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2883561/"&gt;数字设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL 程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/surgeddd/article/details/4683657"&gt;锁存器、触发器、寄存器和缓冲器的区别&lt;/a&gt;&lt;/p&gt;</summary><category term="latch"></category><category term="flip-flop"></category></entry><entry><title>VHDL 笔记 2 —— 系统设计</title><link href="http://guqian110.github.io/pages/2014/09/16/vhdl_notes_2_system_design.html" rel="alternate"></link><updated>2014-09-16T20:18:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-09-16:pages/2014/09/16/vhdl_notes_2_system_design.html</id><summary type="html">&lt;p&gt;总结 &lt;code&gt;packege&lt;/code&gt;, &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 的相关知识。&lt;/p&gt;
&lt;p&gt;这些组成部分添加到代码主体部分，目的是为了实现常用代码共享。通常这些代码被放在 &lt;code&gt;library&lt;/code&gt; 中，我们可以将自己设计的一些常用代码添加到 &lt;code&gt;library&lt;/code&gt; 中，这有利于使一个复杂设计具有更清晰的结构。&lt;/p&gt;
&lt;p&gt;总之，经常使用的代码可以以 &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 的形式放到 &lt;code&gt;package&lt;/code&gt; 中，然后被编译到目标 &lt;code&gt;library&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Packages and Components&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Package&lt;/h3&gt;
&lt;p&gt;除了 &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 之外，package 中还可以包含 &lt;code&gt;TYPE&lt;/code&gt;, &lt;code&gt;CONSTANT&lt;/code&gt; 的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;PACKAGE&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;package_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;PACKAGE&lt;/span&gt; &lt;span class="k"&gt;BODY&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;FUNCTION&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;descriptions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;package_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;可以看到，语法包括两部分，&lt;code&gt;PACKAGE&lt;/code&gt; 和 &lt;code&gt;PACKAGE BODY&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PACKAGE&lt;/code&gt; 是必需的，包括所有的声明语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PACKAGE BODY&lt;/code&gt;：可选，当第一部分包含一个/多个  FUNCTION，PROCEDURE 声明时，这部分必须包含相应的描述代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;--------- package define-------------&lt;/span&gt;
&lt;span class="n"&gt;LIRRARY&lt;/span&gt; &lt;span class="n"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt; &lt;span class="nn"&gt;IDEE.STD_LOGIC_1164.ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;PACKAGE&lt;/span&gt; &lt;span class="n"&gt;my_package&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;CONSTANT&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;STD_LOGIC_VECTOR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;11111111&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;my_package&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;--------- main code ------------------&lt;/span&gt;

&lt;span class="k"&gt;LIBRARY&lt;/span&gt; &lt;span class="nn"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt; &lt;span class="nn"&gt;IEEE.STD_LOGIC_1164.ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt; &lt;span class="nn"&gt;work.my_package.all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;-- declaration&lt;/span&gt;

&lt;span class="k"&gt;ENTITY&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;ARCHITECTURE&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;--------------------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Componet&lt;/h3&gt;
&lt;p&gt;VHDL 中的 &lt;code&gt;component&lt;/code&gt; 和 Verilog HDL 中的 &lt;code&gt;module&lt;/code&gt; 类似：&lt;/p&gt;
&lt;p&gt;一个 component 是一段完整的代码（包括 library, entity, architecture 这些组成部分），如果将这些代码声明为一个 component，那么就可以被其他电路调用，从而使代码具有了层次化的结构。&lt;/p&gt;
&lt;p&gt;使用 component 必须先声明这个元件，然后再例化这个元件（类似 C++，变量先声明，在定义）。声明和例化都必须在 architecture 中进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;declaration syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;COMPONENT&lt;/span&gt; &lt;span class="nc"&gt;component_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;COMPONENT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;instantiation syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;component_name&lt;/span&gt; &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port_list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明时，component 和 entity 相似，必须声明端口的模式和类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化时，必须添加一个标号，就像 Verilog HDL 中例化 module 必须给个名字一样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;声明元件时，可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上面的方法，先声明再例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 package 进行声明，将 component 的声明放在 package 中，则可以避免每次元件例化都要重复声明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方法的区别类似于使用 C++ 中的 namespace 时的不同方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法一：每次使用 STL 都添加作用域&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法二：声明一次作用域&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;port map&lt;/h3&gt;
&lt;p&gt;同 Verilog HDL 一样，两种端口映射的方法：位置映射、名字映射。&lt;/p&gt;
&lt;p&gt;位置映射书写简单，但是容易出错；名字映射书写繁琐，但是不易出错，端口连接也更清晰，未连接的端口要使用关键词 &lt;code&gt;open&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;-- positional&lt;/span&gt;
&lt;span class="n"&gt;U1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;inverter&lt;/span&gt; &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;-- nominal&lt;/span&gt;
&lt;span class="n"&gt;U1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;inverter&lt;/span&gt; &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;generic map&lt;/h3&gt;
&lt;p&gt;generic 功能类似于 Veriog HDL 中的 parameter，所以在例化时 component 时，可以重载参数，使设计更方便灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;component_name&lt;/span&gt; &lt;span class="k"&gt;GENERIC&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;也就是说，在例化时，添加一段 &lt;code&gt;GENERIC MAP (param.list)&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Functions and Procedure&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;function 和 procedure 统称为 子程序，它们和 process 相似，内部包含的都是顺序描述的代码，通常使用相同的顺序描述语句。但是，function 和 procedure 的存在主要是为了建库，以达到代码重用和共享的目的，当然它们也可以直接建立在主代码中。&lt;/p&gt;
&lt;h3&gt;Function&lt;/h3&gt;
&lt;p&gt;一个 function 就是一段顺序描述的代码。&lt;/p&gt;
&lt;p&gt;在写代码的过程中，我们通常会遇到一些有共性的问题，我们希望实现这些功能的代码可以被共享和重用，从而使代码变得简洁，易于理解，function 的建立和使用就能达到这个目睹。
function 中可以使用 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; 等语句，但是不能有 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;component&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;function 的使用方法：先创建函数体本身，再调用函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function Body&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;FUNCTION&lt;/span&gt; &lt;span class="n"&gt;function_name&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;RETURN&lt;/span&gt; &lt;span class="n"&gt;data_type&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;function_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;其中，&lt;parameter list&gt; 指函数的输入参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CONSTANT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;constant_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;constant_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;signal_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数可以是 constant, signal，但是不能是 variable；参数的个数可以是任意个，类型也任意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function Call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数可以单独构成表达式，也可以作为表达式的一部分。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;--example&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;conv_integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;maximum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Function Location&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数可以存放在两个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Package 中，这时候，函数声明在 package 中，函数定义在 package body 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Main Code 中，既可以在 entity 中，也可以在 architecture 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Procedure&lt;/h3&gt;
&lt;p&gt;procedure 和 function 类似，目的也相同，不同之处在于 procedure 可以有多个返回值。&lt;/p&gt;
&lt;p&gt;与 function 类似，procedure 也需要定义和调用两个过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Procedure Body&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;procedure_name&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;procedure_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;其中，&lt;parameter list&gt; 指出了 procedure 的输入输出参数：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;CONSTANT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;constant_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;signal_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;variable_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;参数可以有任意多个，可以是 in, out, inout 模式的 signal, variable, constant。&lt;/p&gt;
&lt;p&gt;和 function 一样，procedure 内部的 wait 语句，signal 声明，component 调用都是不可综合的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Procedure Call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;procedure 的调用就是它自己。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;--example&lt;/span&gt;
&lt;span class="n"&gt;compute_min_max&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;in2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;in3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;divide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dividend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;divisor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;quotient&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;remainder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Procedure Location&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;procedure 的存放和 function 类似，通常放在 package 中，当然也可以放在主代码中。&lt;/p&gt;
&lt;h3&gt;FUNCTION versus PROCEDURE Summary&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;function 有任意个输入参数和一个返回值，输入参数只能是 constant, signal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;procedure 有任意个输入/输出/双向参数，可以是 signal, variable, constant&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 可以作为表达式的一部分，procedure 直接调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 和 procedure 内部，wait 和 component 都不可综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 和 procedure 的存放位置相同，经常位于 package 中，也可以在主代码中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Circuit-Design-VHDL-Volnei-Pedroni/dp/0262162245"&gt;Circuit Design with VHDL&lt;/a&gt;&lt;/p&gt;</summary><category term="VHDL"></category><category term="syntax"></category></entry><entry><title>VHDL 笔记 1 —— 电路设计</title><link href="http://guqian110.github.io/pages/2014/09/16/vhdl_notes_1_circuit_design.html" rel="alternate"></link><updated>2014-09-16T14:56:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-09-16:pages/2014/09/16/vhdl_notes_1_circuit_design.html</id><summary type="html">&lt;h2&gt;Code Structure&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一段独立的 VHDL 代码一般至少由 3 部分组成：&lt;code&gt;LIBRARY declarations&lt;/code&gt;、&lt;code&gt;ENTITY&lt;/code&gt;、&lt;code&gt;ARCHITECTURE&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Library 用来设计重用和代码共享，使代码结构更清晰&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;LIBRARY&lt;/span&gt; &lt;span class="nn"&gt;library_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt; &lt;span class="nn"&gt;library_name.package_name.package_parts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用的 3 个 Library：&lt;code&gt;ieee&lt;/code&gt;、&lt;code&gt;std&lt;/code&gt;、&lt;code&gt;work&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中 std 和 work 是默认可见的，不需声明，ieee 需要明确的声明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Entity 描述电路的输入/输出引脚&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;ENTITY&lt;/span&gt; &lt;span class="nc"&gt;entity_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;entity_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;singal_mode 可以是 4 种类型： &lt;code&gt;in&lt;/code&gt; &lt;code&gt;out&lt;/code&gt; &lt;code&gt;inout&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; 模式无法回读到电路内部，&lt;code&gt;Buffer&lt;/code&gt; 模式可以，但是 buffer 不能连接到其他类型的端口，即不能把该模块作为子模块例化，一般使用中间缓冲信号，解决回读问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Architecture 描述电路的行为和实现的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Architecture 包含两部分：声明部分和代码部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明部分（可选）用来声明信号、常量等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码部分（begin ... end）描述电路行为&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释行用 &lt;code&gt;--&lt;/code&gt; 开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VHDL 不区分大小写&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Data Types&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;前面的 Entity 中的端口定义：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;还有其它地方声明的信号 &lt;code&gt;signal&lt;/code&gt; :&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;还有 常量 &lt;code&gt;constant&lt;/code&gt; 声明：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;constant&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;还有 变量 &lt;code&gt;variable&lt;/code&gt; 声明：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这些声明中都包含了数据类型字段。一个信号/常量/变量的数据类型决定了它能取到什么样的值，还有可以进行什么样的操作。&lt;/p&gt;
&lt;h3&gt;Pre-defined Data Types&lt;/h3&gt;
&lt;p&gt;IEEE 1164 标准中包含了一些预先定义的数据类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std&lt;/code&gt; 库中的 &lt;code&gt;standard&lt;/code&gt; 包集(package) 定义了：&lt;code&gt;bit&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;、&lt;code&gt;real&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_1164&lt;/code&gt; 包集定义了：&lt;code&gt;std_logic&lt;/code&gt;、&lt;code&gt;std_ulogic&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包集定义了：&lt;code&gt;signed&lt;/code&gt;、&lt;code&gt;unsigned&lt;/code&gt; 类型，还有一些数据类型转换函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_signed&lt;/code&gt; 和 &lt;code&gt;std_logic_unsigned&lt;/code&gt; 包集：包含一些函数，可以使 &lt;code&gt;std_logic_vector&lt;/code&gt; 类型的数据可以像 &lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 一样进行运算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;bit&lt;/code&gt; &amp;amp; &lt;code&gt;bit_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用 '0' 和 '1' 赋值&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;bit_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0011&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;std_logic&lt;/code&gt; &amp;amp; &lt;code&gt;std_logic_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee 1164&lt;/code&gt; 标准中引入的 8 逻辑值系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同于 bit 类型，可以取 8 种不同的值，但只有 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt; 是可综合的，其他 5 种用来仿真&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;std_ulogic&lt;/code&gt; &amp;amp; &lt;code&gt;std_ulogic_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee 1164&lt;/code&gt; 标准中定义的具有 9 种逻辑值的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std_logic&lt;/code&gt; 是 &lt;code&gt;std_ulogic&lt;/code&gt; 的子集&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;只有两种取值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;32 位的整数 (-2 147 483 647 ~ +2 147 483 647)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;natural&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;非负整数 (0 ~ +2 147483 647)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;real&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;实数，不可综合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;physical literal&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;表示物理量，不可综合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;character&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单一/一串 ASCII 字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;signed&lt;/code&gt; &amp;amp; &lt;code&gt;unsigned&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包中定义的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和 &lt;code&gt;std_logic_vector&lt;/code&gt; 类似，但是可以支持与整数类似的算术运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;User-defined Data Types&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;-- integer&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;student_grade&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="k"&gt;RANGE&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;-- enumerated&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;idle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backward&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;white&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Subtypes&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;SUBTYPE&lt;/span&gt; &lt;span class="n"&gt;my_color&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="k"&gt;RANGE&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- my_color = (red, green, blue);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Arrays&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以认为 VHDL 预定义的数据类型只有 &lt;code&gt;scalar&lt;/code&gt;(single bit) 和 &lt;code&gt;vector&lt;/code&gt;(one-dimensional array of bits) 两种类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这两种类型中只有一下类型是可综合的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scalars: bit, std_logic, std_ulogic, boolean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vectors: bit_vector, std_logic_vector, std_ulogic_vector, integer, signed, unsigned&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;type_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="k"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;specification&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;data_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;--1D array&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="k"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="kt"&gt;STD_LOGIC_VECTOR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;--2D array&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;matrix2D&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="k"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="kt"&gt;STD_LOGIC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Port Array&lt;/h3&gt;
&lt;p&gt;有时在定义端口时，需要把端口定义为矢量阵列。但是在 &lt;code&gt;Entity&lt;/code&gt; 中不允许使用 &lt;code&gt;type&lt;/code&gt; 定义，所以我们必须自己定义包集 (package)，然后使用 &lt;code&gt;use&lt;/code&gt; 声明使用该用户自定义的包集，最后才能在 Entity 中使用这种新定义的类型。&lt;/p&gt;
&lt;h3&gt;Signed and Unsigned Data Types&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包中定义了有符号数 (&lt;code&gt;signed&lt;/code&gt;) 和无符号数 (&lt;code&gt;unsigned&lt;/code&gt;) 两种数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有先声明使用这个库下的包，才能在代码中使用 signed/unsigned&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;ieee.std_logic_arith.all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;signed&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;unsigned&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用它们主要是为了进行算术运算，但是它们不支持逻辑运算。( std_logic_vector 不支持算术运算，但是支持逻辑运算)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果信号的类型只能是 std_logic_vector，那么通过其他方法也是可以进行算术运算的，解决方案就是声明使用 &lt;code&gt;ieee&lt;/code&gt; 的 &lt;code&gt;std_logic_unsigned&lt;/code&gt; 和 &lt;code&gt;std_logic_signed&lt;/code&gt; 两个包集，声明之后，std_logic_vector 就可以像 signed/unsigned 一样进行算术运算了。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;ieee.std_logic_signed.all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- use ieee.std_logic_unsigned.all;&lt;/span&gt;

&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="kt"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="kt"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;out&lt;/span&gt; &lt;span class="kt"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;--legal, arithmetic&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;--legal, logiccal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;需要注意的是，这两个包不能同时存在于同一份代码中，因为这样会引入二义性。比如上面例子中的 “+” 运算，如果我们同时包含了这两个包集，那么编译器不知道我们定义的运算到底应该重载哪一个，综合时会报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Data Conversion&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 VHDL 中，不同类型的数据是不能直接进行算术/逻辑运算的，所以必要时必须进行类型转换操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有两种方法实现类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用包中预定义的数据类型转换函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动写一段专门用于数据类型转换的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std_logic_arith&lt;/code&gt; 中包含了很多数据类型转换函数，可以实现不同数据之间的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Operators and Attributes&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;VHDL 语法虽然枯燥无味，但是只有对数据类型、运算操作符及其属性有了深刻认识，才能写出高质量和高效率的代码。&lt;/p&gt;
&lt;h3&gt;Opreators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VHDL 提供了 6 种预定义的预算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;赋值 assignment&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑 logical&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算术 arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系 relational&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移位 shift&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并置 concatenation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;assignment&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一共 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; 用于给 &lt;code&gt;signal&lt;/code&gt; 对象赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:=&lt;/code&gt; 用于给 &lt;code&gt;variable&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, &lt;code&gt;generic&lt;/code&gt; 赋值，还可用于赋初值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt; 用于给矢量(vector)对象的某些位赋值，常和 &lt;code&gt;others&lt;/code&gt; 一起使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;logical&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;进行逻辑运算，操作数必须是 &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;std_logic&lt;/code&gt;, &lt;code&gt;std_ulogic&lt;/code&gt; 类型或者它们的扩展，即&lt;code&gt;bit_vector&lt;/code&gt;, &lt;code&gt;std_logic_vector&lt;/code&gt;, &lt;code&gt;std_ulogic&lt;/code&gt; 类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NOT&lt;/code&gt;, &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;NAND&lt;/code&gt;, &lt;code&gt;NOR&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;arithmetic&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作数是 &lt;code&gt;signed&lt;/code&gt;, &lt;code&gt;unsigned&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;，其中 &lt;code&gt;real&lt;/code&gt; 类型是不可综合的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果声明了 &lt;code&gt;std_logic_signed&lt;/code&gt; 或者 &lt;code&gt;std_logic_unsigned&lt;/code&gt;，则 &lt;code&gt;std_logic_vector&lt;/code&gt; 类型也可以进行加减运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;MOD&lt;/code&gt;, &lt;code&gt;REM&lt;/code&gt;, &lt;code&gt;ABS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;comparison&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一共有 6 种：&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;VHDL93 中引入的操作，语法：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="n"&gt;operand&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;shift&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="n"&gt;operand&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;left operand 必须是 &lt;code&gt;bit_vector&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right operand 必须是 &lt;code&gt;integer&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shift operator 有：&lt;code&gt;sll&lt;/code&gt;, &lt;code&gt;srl&lt;/code&gt;, &lt;code&gt;sla&lt;/code&gt;, &lt;code&gt;sra&lt;/code&gt;, &lt;code&gt;rol&lt;/code&gt;, &lt;code&gt;ror&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;concatenation&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;用于位的拼接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作数：任何支持逻辑运算的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作符：&lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;(, , ,)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Attributes&lt;/h3&gt;
&lt;p&gt;VHDL 中的属性语句可以获得相关数据/对象 的信息，使代码更加灵活。&lt;/p&gt;
&lt;h4&gt;Pre-defined&lt;/h4&gt;
&lt;p&gt;内置的预定义属性可以分为两大类：数值类属性 和 信号类属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;data attributes&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;signal attributes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数信号类属性都是不可综合的，只有 &lt;code&gt;s'event&lt;/code&gt; 和 &lt;code&gt;s'stable&lt;/code&gt; 是可综合的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;User-defined&lt;/h4&gt;
&lt;p&gt;也可以用户自己定义一个新的属性，并描述某个对象的这个属性的值是多少，之后就可以使用这个属性了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;attribute_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;attribute_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;-- declaration&lt;/span&gt;
&lt;span class="n"&gt;ATTIRBUTE&lt;/span&gt; &lt;span class="n"&gt;attribute_name&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;target_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;-- specification&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;example：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;number_of_inputs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;INTEGER&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;number_of_inputs&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;nand3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;SIGNAL&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;nand3&lt;/span&gt;&lt;span class="na"&gt;&amp;#39;number_of_inputs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;首先定义了一个新的属性，名字叫 &lt;code&gt;number_of_inputs&lt;/code&gt;，表示输入端口的个数，然后针对对象 nand3 (3输入的与非门) 这个对象，描述它的这个属性的类型为 signal 类型，取值为 3；最后，使用这个属性，将 nand3 的这个属性的值赋值给 input 对象。&lt;/p&gt;
&lt;h3&gt;Operator Overloading&lt;/h3&gt;
&lt;p&gt;用户不仅可以自定义属性，还可以自定义操作符。预定义的操作符的操作数必须是特定的类型，对于某些类型，我们可以自定义操作符对应的操作。&lt;/p&gt;
&lt;p&gt;VHDL 中的自定义操作符作用和 C++ 中的操作符重载 方法、目的都很类似。首先构造一个函数，然后调用这个函数即可。&lt;/p&gt;
&lt;h3&gt;GENERIC&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;generic&lt;/code&gt; 必须在 ENTITY 中声明，它可以指定常规参数，所指定的参数是&lt;strong&gt;静态的&lt;/strong&gt;，&lt;strong&gt;全局的&lt;/strong&gt;。感觉类似于 Verilog 中的 &lt;code&gt;define&lt;/code&gt; 吧，但是显然 Verilog 中的 &lt;code&gt;parameter&lt;/code&gt; 是更好的设计，因为全局变量/常量很不安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;GENERIC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameter_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;parameter_type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;parameter_value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;ENTITY&lt;/span&gt; &lt;span class="nc"&gt;my_entity&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;GENERIC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;INTEGER&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;my_entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Concurrent Code&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;从本质上讲，HDL 是 描述 (Description) 语言，对应的是硬件电路，而硬件电路是时刻工作的，所以，它的代码是并发执行的。只有 &lt;code&gt;process&lt;/code&gt;，&lt;code&gt;function&lt;/code&gt;，&lt;code&gt;procedure&lt;/code&gt; 中的代码是顺序执行的，而且当这些模块作为一个共同的整体时，它们之间也是并行的。&lt;/p&gt;
&lt;p&gt;在并发代码中可以使用下列各项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运算操作符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;when&lt;/code&gt; 语句（when/else 和 with/select/when）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;generate&lt;/code&gt; 语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;block&lt;/code&gt; 语句&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仔细观察可以发现，其实 when, generate, block 语句和运算语句相比，只是添加了一些条件判断，它们主要的核心还是运算操作符组成的运算，所以，并行代码的核心就是这些并行的运算语句。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;when&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;When/else syntax:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="k"&gt;ELSE&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="k"&gt;ELSE&lt;/span&gt;
&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;with/select/when syntax:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;&lt;code&gt;generate&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;功能类似于 Verilog HDL 中的 generate，它常和 for/if 一起使用。
因为描述的对象是电路，最终的电路是固定的，功能也是静态的，所以，对于 generate，它的循环操作的上下界必须是静态的，否则代码是不可综合的。&lt;/p&gt;
&lt;p&gt;实际上，引入 generate 的主要目的是为了写出更加通用的代码，达到修改最少代码，实现不同设计的目的，也就是动态编译。而引入 for 循环，只是为了减少代码量。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;block&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;VHDL 中存在两种类型的块 block：简单块 (simple block) 和 卫式块 (guarded block):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;simple block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;simple block 只是对原有代码进行了区域分割，目的也仅仅是为了增强代码的可读性和可维护性。&lt;/p&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;BLOCK&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarative&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concurrent&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;BLOCK&lt;/span&gt; &lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;guarded block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;guarder block 是一种特殊的 block，它比 simple block 多了一个表达式，叫做 &lt;code&gt;guard expression&lt;/code&gt;，只有当这个表达式为 True 时，这个 block 才会执行。&lt;/p&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;BLOCK&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarative&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concurrent&lt;/span&gt; &lt;span class="k"&gt;guarded&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;unguarded&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;BLOCK&lt;/span&gt; &lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Sequential Code&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;VHDL 本质是并发执行的代码，但是在 &lt;code&gt;process&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 内部的代码是顺序执行的，当它们作为一个整体时，相互之间也是并发执行的。&lt;/p&gt;
&lt;p&gt;顺序代码并非只能与时序逻辑 (&lt;code&gt;sequential logic&lt;/code&gt;) 对应，同样也可以用它们来实现组合逻辑 (&lt;code&gt;combinational logic&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;顺序代码也称为描述代码 (&lt;code&gt;behavioral code&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;这里主要讨论顺序代码，也就是这 3 个块中的代码，包括 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; 语句。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;process&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;作用类似于 Verilog HDL 中的 always 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lable&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;PROCESS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sensitivity&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;;]]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;PROCESS&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;&lt;code&gt;if&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;IF&lt;/span&gt; &lt;span class="n"&gt;conditions&lt;/span&gt; &lt;span class="k"&gt;THEN&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;ELSIF&lt;/span&gt; &lt;span class="n"&gt;conditions&lt;/span&gt; &lt;span class="k"&gt;THEN&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;ELSE&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果在 process 中使用了 wait 语句，那么 process 就不能含有敏感信号列表了，所以此时 wait 必须是 process 的第一条语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax1&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt; &lt;span class="n"&gt;UNTILL&lt;/span&gt; &lt;span class="n"&gt;signal_condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;syntax2&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;signal1&lt;/span&gt; &lt;span class="p"&gt;[,&lt;/span&gt; &lt;span class="n"&gt;signal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;syntax3&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="kt"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;--simulation only&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;&lt;code&gt;case&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;case 和 when 的区别在于，case 允许在每个测试条件下执行多个赋值操作，而 when 只能执行一个赋值操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;CASE&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;CASE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;syntax1: FOR/LOOP repeat a fix number of times&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="k"&gt;IN&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;syntax: WHILE/LOOP&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;WHILE&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;syntax3: EXIT&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;EXIT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;syntax4: NEXT&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;NEXT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;loop_label&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Signals &amp;amp; Variables&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;VHDL 提供了 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;variable&lt;/code&gt; 两种对象来处理非静态数据；提供了 &lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;generic&lt;/code&gt; 来处理静态数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;signal&lt;/code&gt; 是全局的，可以在顺序执行的代码中，也可以在并发执行的代码中；&lt;code&gt;variable&lt;/code&gt; 是局部的，只能值顺序代码中，并且它们的值是不能向外传递的(如果想传递出去，必须先把这个变量值传递给一个信号，再由这个信号传递出去)。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;constant&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;constant 可以定义在 package, entity, architecture 中，对应的作用域也不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义在 package 中的 constant 是真正的全局的，可以被所有调用该 package 的 entity 使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在 entity 中的 constant 对于该 entity 的所有 architecture 而言是全局的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在 architecture 中的 constant 仅在该 architecture 中是全局的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;CONSTANT&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;VHDL 中的 &lt;code&gt;signal&lt;/code&gt; 代表的是逻辑电路中的 “硬”连线，既可以用于电路的输入输出端口，也可以用于 内部单元之间的连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和 Verilog HDL 的 always 中的 reg 类似，VHDL 的 process 中的 signal 也是在进程结束时更新值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对同一个信号多次重复赋值，结果取决于编译器。(Xilinx XST 不报错，认为最后一次赋值是有效的)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;相比于 signal 是局部的，variable 只能在 process，function，procedure 中使用，而且对它的赋值是立即更新的，新的值可以在下一行代码中立即使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Circuit-Design-VHDL-Volnei-Pedroni/dp/0262162245"&gt;Circuit Design with VHDL&lt;/a&gt;&lt;/p&gt;</summary><category term="VHDL"></category><category term="syntax"></category></entry><entry><title>FPGA 时钟设计 2 —— 时钟设计</title><link href="http://guqian110.github.io/pages/2014/09/12/the_clock_design_in_fpga_2_clock_design.html" rel="alternate"></link><updated>2014-09-12T12:45:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-09-12:pages/2014/09/12/the_clock_design_in_fpga_2_clock_design.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;无论是离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字设计，为了成功地操作，可靠的时钟是非常关键的。&lt;/p&gt;
&lt;p&gt;设计不良的时钟在极限的温度、电压或者制造工艺的偏差情况下将导致错误的行为，并且调试困难、花销很大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下 FPGA 中的时钟设计原则。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Clock Design&lt;/h2&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;在 FPGA/CPLD 中通常采用几种时钟类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门控时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级逻辑时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;波动式时钟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多时钟系统能够包括上述 4 种时钟类型的任意组合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是 &lt;a href="http://book.douban.com/subject/10593491/"&gt;《Xiliinx FPGA 高级设计及应用》&lt;/a&gt; 中的分类方法，个人觉得并不是很清晰，我总结了一下，大概可以分为下面的这 4 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;全局时钟 Global Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门控时钟 Gated Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑时钟 Logic Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分频/倍频时钟 Divied/Multiplied Clock&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Gloabl Clock&lt;/h3&gt;
&lt;p&gt;关于全局时钟，前面一篇 blog  &lt;a href=""&gt;FPGA 时钟设计 1 —— 时钟资源总结&lt;/a&gt; 中有总结。&lt;/p&gt;
&lt;p&gt;对于一个项目来说，全局时钟是 &lt;strong&gt;最简单&lt;/strong&gt;、&lt;strong&gt;最可预测&lt;/strong&gt; 的时钟。&lt;/p&gt;
&lt;p&gt;在 PLD/FPGA 项目中 &lt;strong&gt;最好的时钟方案&lt;/strong&gt; 是：由专用的全局时钟输入引脚驱动的单个主时钟去钟控设计项目中的每一个触发器。只要可能就应该尽量在设计中采用全局时钟&lt;/p&gt;
&lt;p&gt;PLD/FPGA 都具有专门的全局时钟引脚，它直接连接到器件中的每一个寄存器，这种全局时钟提供最短的时钟到输出的延时。&lt;/p&gt;
&lt;h3&gt;Gated Clock&lt;/h3&gt;
&lt;p&gt;门控时钟的意思是通过组合逻辑，控制、禁止或允许时钟输入到寄存器和其他同步原件上的一种方法。因为它能够有效地降低功耗，所以被广泛地应用于 ASIC 设计中。但是，它不符合 &lt;code&gt;同步设计&lt;/code&gt; 的思想，可能会影响系统设计的实现和验证，所以，&lt;strong&gt;在 FPGA 设计中应该避免使用门控时钟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 ASIC 和 FPGA 结构设计上的区别，两者对待门控时钟的态度是完全不同的：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://electronics.stackexchange.com/questions/73398/gated-clocks-and-clock-enables-in-fpga-and-asics"&gt;Gated clocks and clock enables in FPGA and ASICS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;往往可以将门控时钟转化为全局时钟以改善项目设计的可靠性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;就是使用寄存器 &lt;code&gt;时钟使能 (clock enable, CE)&lt;/code&gt; 端口。&lt;/p&gt;
&lt;p&gt;单纯从功能来看，使用使能时钟代替门控时钟是一个不错的选项，但是使能时钟在使能信号关闭时，时钟信号仍然工作，它无法像门控时钟那样降低系统的功耗。&lt;/p&gt;
&lt;p&gt;推译带使能端的触发器的代码：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;得到的结果就是原语 &lt;code&gt;FDCE&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/p&gt;
&lt;p&gt;//       Clock Enable (posedge clk).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;多路选择器（mux）&lt;/code&gt; 将组合逻辑从时钟通路搬移到数据通路。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="mux" src="/images/the-clock-design-in-fpga-2-clock-design/mux.png" /&gt;&lt;/p&gt;
&lt;p&gt;如果在设计中无法避免门控时钟，那么只要保证满足下面两个条件就可以使门控时钟和全局时钟一样可靠地工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;驱动时钟的逻辑必须只包含一个与门（或门），而且这个与门（或门）必须只有两个输入端。如果采用任何附加逻辑，则会出现竞争产生的毛刺。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑门的一个输入端为实际时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些条件的目的就是为了避免组合逻辑中的竞争带来的毛刺。&lt;/p&gt;
&lt;p&gt;根据数字电路的知识，我们知道可以通过添加“冗余逻辑”的方法来消除组合逻辑的冒险，但是，FPGA 的编译器在 综合时会去掉这些冗余逻辑，所以不能采用这种方法。&lt;/p&gt;
&lt;h3&gt;Logic Clock&lt;/h3&gt;
&lt;p&gt;有时候会用到组合逻辑的输出作为时钟信号或者复位信号，但是这种时钟信号有两个非常重要的缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑产生的信号不可避免地会出现毛刺，会导致系统运行失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑产生的时钟信号使用的是通用布线资源，和专用时钟布线相比，延迟长、时钟偏移大，满足时序要求会更加困难。如果大量的逻辑使用了这种时钟，这个问题会更加突出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（看到书上提出一个解决方案是：使用系统专用的时钟信号，将组合逻辑的输出打一拍，避免组合逻辑的直接输出，达到同步的效果。但是我个人认为这个方案不是非常好。）&lt;/p&gt;
&lt;p&gt;综上，对于 FPGA 来说，还是应该&lt;strong&gt;尽量避免使用组合逻辑的输出作为时钟&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;Divide/Multiplied Clock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline：&lt;/strong&gt; 尽量避免分频时钟&lt;/p&gt;
&lt;p&gt;在我们的设计中，一般都不止一个时钟频率。如果不加注意，随意使用分频时钟，这叫做时钟满天飞，是非常不好的设计风格。&lt;/p&gt;
&lt;p&gt;如果一定要使用分频时钟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于资源比较丰富的 FPGA&lt;/p&gt;
&lt;p&gt;使用内部提供的 PLL/DLL，输出时钟信号可以配置成不同的频率（倍频/分频）和相位，这样的分频时钟是最稳定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于无法使用 PLL/DLL 的 FPGA&lt;/p&gt;
&lt;p&gt;对于这些情况，首先检查是否可以用 &lt;code&gt;CE&lt;/code&gt; (clock enable) 来代替分频时钟，如果不行，则使用 &lt;a href="http://guqian110.github.io/pages/2014/10/13/clock_dividers.html"&gt;时钟分频器&lt;/a&gt; 中讨论的分频方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Other Tips&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;只使用时钟的单个边沿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了一些特殊的电路（如DDR）外，设计应该只使用单个边沿（上/下边沿）。使用两个边沿的问题是时钟占空比不一定是 50%，这会对电路的正常工作产生影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用差分时钟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常认为频率高于 100 MHz 就属于 &lt;code&gt;高频&lt;/code&gt;。建议在高频下使用差分时钟，因为差分时钟的抗噪声性能更好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检测时钟缺失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 DCM/MMCM 的 &lt;code&gt;locked&lt;/code&gt; 输出，在使用时钟前先检查时钟是否锁定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;</summary><category term="clock design"></category></entry><entry><title>数字信号处理和相关matlab函数总结</title><link href="http://guqian110.github.io/pages/2014/09/03/digital_signal_processing_and_matlab.html" rel="alternate"></link><updated>2014-09-03T23:16:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-09-03:pages/2014/09/03/digital_signal_processing_and_matlab.html</id><summary type="html">&lt;p&gt;学了这么多年的通信，却还是对信号处理的知识一知半解，应付考试还可以，但在实际应用中还是感到力不从心，很多知识都忘了。翻了一下午的 《信号与系统》、《数字信号处理》，简单总结一下。&lt;/p&gt;
&lt;p&gt;《信号与系统》算是通信专业最基础的专业课了。&lt;/p&gt;
&lt;p&gt;信号部分主要介绍信号的相关定义、分类、常用信号和三大变换：傅立叶变换、拉普拉斯变换和z 变换。&lt;/p&gt;
&lt;p&gt;系统部分主要从时域和频域使用不同的方法分析线性时不变系统（LTI）的性质。&lt;/p&gt;
&lt;p&gt;《数字信号处理》算是前一门课的深入，现在利用计算机处理信号，首先就是要将模拟信号数字化，然后进行处理。这门课也就是讲相关的知识。&lt;/p&gt;
&lt;p&gt;一般教材就讲两大部分：第一部分首先承接《信号与系统》，时域的连续信号要在计算机中处理就必须采样，变为时域离散信号，这部分就讲离散时间信号的处理，比如 z 变换 和离散傅立叶变换。第二部分讲数字滤波器的设计，包括 FIR 和 IIR 两种。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Signal Processing&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;这部分是我串联的这两本书中很小的一部分知识，算是一个备忘的笔记吧，作为一名学渣，一个月不看也会忘记不少 =.=&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从 《信号与系统》 中我们可以知道：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周期信号 （连续）傅立叶级数 （CFS）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，由高数知识可以知道：只要满足 Dirichlet 条件，周期信号就可以进行傅立叶级数分解，可以得到幅度频谱和相位频谱。&lt;/p&gt;
&lt;p&gt;时域信号是周期的、连续的，频域信号是离散的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非周期信号 （连续）傅立叶变换 （CFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;周期信号的周期无限增大，就可以将周期信号转化为非周期信号，从而得到非周期信号的傅立叶变换。&lt;/p&gt;
&lt;p&gt;得到的频率域的结果为连续信号，计算结果为时域信号的频谱密度函数，简称频谱函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周期信号 （连续）傅立叶变换 （CFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于周期信号，因为它不满足绝对可积的条件，所以从非周期信号无法直接推广。但是借助 &lt;em&gt;奇异函数&lt;/em&gt;（如冲激函数）的概念，可以使许多不满足绝对可积的信号（如周期信号）存在傅立叶变换。&lt;/p&gt;
&lt;p&gt;周期信号的傅立叶变换结果由一些冲激函数组成，冲激函数的强度是对应的傅立叶级数的 2pi 倍，频谱是离散的。&lt;/p&gt;
&lt;p&gt;这样，周期信号和非周期信号的傅立叶分析得到了统一。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;接下来，就要进入《数字信号处理》部分了：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散时间信号傅立叶变换 （DTFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时域连续信号经过采样，得到离散时间信号，对于离散时间信号，可以从 z 变换中引出 DTFT 的定义。&lt;/p&gt;
&lt;p&gt;DTFT 是一种特殊的傅立叶变换（FT），它满足所有的傅立叶变换的性质。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散傅立叶变换 （DFT）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然 DTFT 解决了信号在时域的连续问题，但是变换结果仍然是连续信号，也就是说在频域仍然是连续的，这样计算机仍然是无法处理的。所以，就引出了离散傅立叶级数（DFS)和离散傅立叶变换（DFT）。&lt;/p&gt;
&lt;p&gt;时域信号的周期性对应着频域的离散化，而且时域信号的离散化对应着频域的周期性。由这两点，可以知道周期的离散信号具有离散的、周期的频谱，也就是离散傅立叶级数（DFS）。&lt;/p&gt;
&lt;p&gt;把时域和频域的数据长度都限定在主周期，那么就得到了标准的离散傅立叶变换（DFT）。&lt;/p&gt;
&lt;p&gt;经过分析，可以知道，DFT 是 z 变换的取样，也是 DTFT 的取样结果。&lt;/p&gt;
&lt;p&gt;DFT 因为是离散的，长度有限，所以很适合计算机计算，而且人们发明了高效地计算 DFT 的方法 —— FFT 。&lt;/p&gt;
&lt;p&gt;知乎上还有一篇专栏的文章，得到了非常多人的赞同，可以进一步参考。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zhuanlan.zhihu.com/wille/19763358"&gt;傅里叶分析之掐死教程（完整版）更新于2014.06.06&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Matlab&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;basic&lt;/h3&gt;
&lt;p&gt;分析各种变化，可以得到以下的关系：&lt;/p&gt;
&lt;p&gt;N 点的 DFT（FFT），其结果对应的&lt;/p&gt;
&lt;p&gt;数字角频率 w 为 [0, 2pi)&lt;/p&gt;
&lt;p&gt;模拟角频率 Ω 为 [0, Ωs)&lt;/p&gt;
&lt;p&gt;模拟频率 f 为 [0, fs)&lt;/p&gt;
&lt;p&gt;所以对于 N 点 FFT 的结果，对应的横坐标频率的范围为 [0, fs)。&lt;/p&gt;
&lt;p&gt;matlab 提供了函数 fft 和 fftshift 直接完成变换。&lt;/p&gt;
&lt;h3&gt;adv&lt;/h3&gt;
&lt;p&gt;假设我们的采样频率为 Fs （采样周期为 T = 1/Fs），一共采了 N 个点，那么相当于对信号进行了截断，截断长度为 &lt;code&gt;L = N * T&lt;/code&gt; 秒。&lt;/p&gt;
&lt;p&gt;这 3 个参数就决定了我们的最终结果。&lt;/p&gt;
&lt;p&gt;在非周期信号处理中存在下面的 3 个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;频谱混叠。如果信号不是带限的，那么为了减小频谱混叠的影响，我们应该尽可能提高采样频率，也就是减小采样周期 T&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;频率分辨率和栅栏效应。因为 DFT 是 DTFT 的等间隔采样，那么 N 越大，采样点数越多，栅栏就越小，频率分辨率 &lt;code&gt;f0 = Fs/N&lt;/code&gt; 就越高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;截断效应和频谱泄漏。如果信号是无限长的，那么必须把它截断到长度 &lt;code&gt;L = N*T&lt;/code&gt;。截断会带来吉布斯效应，并且引入窗函数的频谱，造成频谱泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上面的分析，为了减少混叠，必须使 T 足够小；而为了提高分辨率，N 应该足够大。但是太小的 T 和太大的 N 也没有必要，所以应该合理选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般应该先选择 L 使得信号的绝大部分都在窗内，其次，根据分辨率的要求选择 T 和 N。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非周期信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如矩形脉冲信号，宽度为 [-tau/2, tau/2]，对应的频谱为 Sa 函数，零点为 1/tau，2/tau，3/tau ...&lt;/p&gt;
&lt;p&gt;假设 tau = 1，采样频率 Fs = 10 Hz，那么如果要求频率分辨率为 f0 = Fs/N = 1/40 Hz 的话，可以推出 N = 390。所以时域采样结果应该是 195 个 0，之后是 10 个 1，最后是 195 个 0。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;195&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;195&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fftshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;mag&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Fs&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mag&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;结果如下图所示，与预期是相符合的，1/tau 的整数倍处都是过零点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="sa" src="/images/digital_signal_processing_and_matlab/sa.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周期信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如 s(t) = 1 + 0.5cos(2&lt;em&gt;pi&lt;/em&gt;15&lt;em&gt;t) + 2sin(2&lt;/em&gt;pi&lt;em&gt;40&lt;/em&gt;t);&lt;/p&gt;
&lt;p&gt;最大的频率分量为 fmax =  40 Hz，如果采用频率为 10 倍，即 Fs = 400 Hz，如果要求频率分辨率为 0.5 Hz，那么可以得到 N = 800，为了计算方便使用 N = 1024；&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;f1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;f2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;% sample frequency is 400 Hz, sample number is 1024&lt;/span&gt;
&lt;span class="n"&gt;Fs&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;% fft operation&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fftshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;mag&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c"&gt;% magnitude&lt;/span&gt;
&lt;span class="n"&gt;f0&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;f0&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;f0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c"&gt;% plot time domain singal&lt;/span&gt;
&lt;span class="n"&gt;subplot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;time/s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;magnitude&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;time domain signal&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;grid&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;% plot frequency domain signal&lt;/span&gt;
&lt;span class="n"&gt;subplot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mag&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;fft result&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;grid&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;结果如下图所示，可以看到与预期相符，在 0、15、40 处有冲激函数。&lt;/p&gt;
&lt;p&gt;&lt;img alt="periodic" src="/images/digital_signal_processing_and_matlab/periodic.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3712794/"&gt;信号与系统引论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4025528/"&gt;数字信号处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/24868505/"&gt;数字信号处理教程——MATLAB释义与实现&lt;/a&gt;&lt;/p&gt;</summary><category term="digital procesing"></category><category term="matlab"></category></entry><entry><title>Xilinx FFT IP core 笔记</title><link href="http://guqian110.github.io/pages/2014/09/02/xilinx_fft_core_notes.html" rel="alternate"></link><updated>2014-09-02T23:12:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-09-02:pages/2014/09/02/xilinx_fft_core_notes.html</id><summary type="html">&lt;p&gt;关于 FFT 的背景介绍就不再赘述，通原书和网上的教程、课件很多；关于这个 IP 核的介绍也就不再粘贴复制了，原版的 datasheet 必然是最全面的，仅记录我的使用时遇到的问题和需要注意到细节。&lt;/p&gt;
&lt;p&gt;IP 核的接口示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="schematic symbol" src="/images/xilinx_fft_core_notes/symbol.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Timing&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;code&gt;START / RFD&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;datasheet 中没有专门描述 &lt;code&gt;start&lt;/code&gt; 信号和其他信号的时序关系，只是简单介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FFT start signal (Active High): START is asserted to begin the data loading and transform calculation (for the Burst I/O architectures). For Streaming I/O, START begins data loading, which proceeds directly to transform calculation and then data unloading.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我最开始的测试小程序中，是先判断 &lt;code&gt;rfd&lt;/code&gt; 信号，根据 rfd 来给 start 赋值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;思路是：首先必须等 IP core 准备好接收新数据时，才能开始&lt;/em&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rfd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;但是仿真出来的结果显示 IP core 根本就没有工作，后来改了这两个信号的先后关系，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;新思路：程序将输入 start 置有效，通知 IP core 需要调用，然后 IP core 根据自己的状态给出标识信号（rfd / busy），外部电路等到 rfd 有效时才输入需要变换的信号。&lt;/em&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这样子程序就可以正常运行了。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;RFD / DV&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;在 datasheet 中给出的时序图如下所示（Burst I/O Solutions with Natural Order Output）&lt;/p&gt;
&lt;p&gt;&lt;img alt="Burst I/O Solution" src="/images/xilinx_fft_core_notes/burst_io_solution.png" /&gt;&lt;/p&gt;
&lt;p&gt;实际仿真图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rfd_dv_sim" src="/images/xilinx_fft_core_notes/rfd_dv.png" /&gt;&lt;/p&gt;
&lt;p&gt;实际仿真结果和示意图有一点点小差别：datasheet 中的时序图显示 rfd 必须在等 unload 阶段结束之后才能变有效，输入新的数据；但是实际的仿真图显示，在 unload 的后半段时间，rfd 已经变有效了，开始载入新的数据。&lt;/p&gt;
&lt;p&gt;从理论上分析，采用 Burst I/O with Natural Order Output 方案，总共需要 3N 个时钟周期，load 阶段需要 N 个周期载入数据，processing 阶段需要 N 个时钟变换，unload 阶段需要 N 个周期来输出数据。&lt;/p&gt;
&lt;p&gt;从仿真结果来看，unload 阶段和下一帧的 load 阶段有部分是重叠的，这样实际上的周期是少于 3N 个时钟的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然功能上是不影响下一帧的数据的，毕竟和预期的时序不同，不知道是否会影响时序设计，有待继续观察。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Port&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;code&gt;NFFT&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 是可以设置为 动态重配置的，可以在运行时改变做运算的点数，非常方便，不过有一点需要注意到是重配置的点数是有范围限制的，比如我测试时设置的最大点数为 4096 点，那么运行重配置时，最小的点数为 64。可以选择 64 ~ 4096 之间的任何一个 2 的指数。&lt;/p&gt;
&lt;p&gt;由于我一开始忽略了这一点，重配置为 16 点，迷糊了半天，重新打开 IP core 设置时才发现是自己看文档不够仔细 =.=&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;CP&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 专门提供了一个端口可以设置循环前缀的长度，循环前缀 (cyclic prefix) 在通信中（尤其是 OFDM）是很有用的。&lt;/p&gt;
&lt;p&gt;在向导中设置了 cyclic prefix insertion，并且在程序重配置时设置了 CP length = 10，但是仿真结果却没有出现 CP，和 CP = 0 时的结果相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仔细看了两遍程序和 datasheet，没有发现问题...待解决！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 09/03/2014&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又仔细看了两遍 datasheet，终于发现了原因所在。在关于 CP length 部分，最有一小段话一直被我匆匆忽略了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The initial value and reset value of CP_LEN is 0 (no cyclic prefix). The core uses the log2(point size) MSBs of CP_LEN for the cyclic prefix length. So, when the point size decreases, the leftover LSBs are ignored. This effectively scales the cyclic prefix length with the point size, keeping them in approximately constant proportion. However, all bits of CP_LEN are latched into the core on CP_LEN_WE and are used in later transforms if the point size increases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细读了一遍才明白，CP_LEN 起作用的是高位的数据 —— 从 MSB 起共 log2(point size) 位。比如我测试程序设置的最大点数为 4096，这是 CP_LEN 的位宽为 12 比特，但是在程序运行过程中，我重配置为 64 点，所以这时候应该从 CP_LEN 的最高位数起，共 log2(64) = 6 比特数据起作用。如果我想设置 CP 的长度为 8 点，则应该如下&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cp_len&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;12&amp;#39;b001000&lt;/span&gt;&lt;span class="n"&gt;_000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这时候，如下图所示，结果与预期相符。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cp" src="/images/xilinx_fft_core_notes/cp.png" /&gt;&lt;/p&gt;
&lt;h3&gt;FFT/ IFFT&lt;/h3&gt;
&lt;p&gt;在 FFT 的测试程序中，一切都正常工作，但是切换为 IFFT 模式，却出现了问题。&lt;/p&gt;
&lt;p&gt;datasheet 中介绍，控制正反变换的信号一共有两个：&lt;code&gt;fwd_inv&lt;/code&gt; 和 &lt;code&gt;fwd_inv_we&lt;/code&gt;。前者取 1 时为 FFT，取 0 为 IFFT；后者是前者的写使能信号。&lt;/p&gt;
&lt;p&gt;因为 FFT 的程序可以正常工作，说明程序逻辑是没有问题的。但是只配置这两个端口，就是有问题。自己研究无果，只能 Google，还真的找到以前有人也遇到同样的问题，并且给出了解决方法（不得不说，还是 Google 好，某度搜出来的结果都是广告和没有用的链接）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://forums.xilinx.com/t5/Digital-Signal-Processing-IP-and/IFFT-of-FFT-module-does-not-work/td-p/71555"&gt;IFFT of FFT module does not work&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://myfpgablog.blogspot.com/2009/11/ifft-in-system-generator.html"&gt;IFFT in System Generator (blogspot 需翻墙)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转原博客部分内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, the FFT block is configured to calculate DFT. The setup and timing of control/data signals for IDFT are the same as DFT except for two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The FFT block needs to be set up for IDFT by setting fwd_inv_we signal to 1 and fwd_inv signal to 0 before the start of the transform.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The FFT output needs to be manually scaled to account for the factor 1/N in Equation 2 above. The scaling can be done either by using the scaling schedule input or shifting the FFT output if the FFT block is set to "unscaled".&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题关键就在于第二条，需要手动设置数据缩放，给结果乘以 1/N。&lt;/p&gt;
&lt;p&gt;原因就是这个 IP core 在计算 FFT 和 IFFT 时，利用两者表达式上的相似点，使用相同的结构，但是却缺少给 IFFT 的结果乘以 1/N 的步骤，需要用户自己添加。&lt;/p&gt;
&lt;p&gt;在 datasheet 中介绍说&lt;/p&gt;
&lt;p&gt;&lt;img alt="theory" src="/images/xilinx_fft_core_notes/theory.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The inverse FFT (IFFT) is computed by conjugating the phase factors of the corresponding forward FFT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是却没有提到这个额外的 1/N 需要用户自己手动设置，应该算是 Xilinx 的坑。修正这个倍数关系以后，结果就与预期相符了～&lt;/p&gt;
&lt;p&gt;（其实如果仔细分析对比 FPGA 和 Matlab 的结果，就能发现两者的差别就是这个 1/N 的倍数关系，只是自己对数字不敏感，又懒得仔细观察 =.=）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;P.S. Test program&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;FFT IP core&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;page1: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;channel = 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transform Length = 4096&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Radix-4, Burst I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run time configurable transform length&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fix Point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Input data width  = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase factor width = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block floating point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;natural output&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cyclic prefix insertion&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;input data timing - no offset&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page3:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;use 3-multiplier structer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use CLB logic to implement butterfly arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;运行时重配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变换长度为 64 点，cp 长度为 10&lt;/p&gt;
&lt;h3&gt;Matlab&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;im&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;%f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;%f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;FFT IP core 仿真结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fft core sim" src="/images/xilinx_fft_core_notes/fft_core_sim.png" /&gt;&lt;/p&gt;
&lt;p&gt;对比 Matlab 中的结果，可以看到 IP core 的计算结果是正确的（除了 CP 的问题）。&lt;/p&gt;</summary><category term="FFT"></category><category term="IP core"></category></entry><entry><title>FPGA 时钟设计 1 —— 时钟资源总结</title><link href="http://guqian110.github.io/pages/2014/08/28/the_clock_design_in_fpga_1_summary_of_clock_resource.html" rel="alternate"></link><updated>2014-08-28T22:45:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-08-28:pages/2014/08/28/the_clock_design_in_fpga_1_summary_of_clock_resource.html</id><summary type="html">&lt;p&gt;关于一款芯片，最权威、最新的资料当然是厂家的官方文件。很多大牛都推荐直接阅读原厂的 datasheet 和 user guide。根据我的体验，这确实是最好的途径。原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，市面上的书一般都落后业界的步伐，我们看到的很多书上的资料都是过时的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，市面上书（尤其是国内）很多都是简单的翻译手册而来的，而且虽然作者标的是某某大学的教授，事实上都是教授手下的研究生替老师干活翻译的，不能保证翻译的正确性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实验室有的芯片是 Xilinx 的 Virtex-5 系列，Virtex-5 的 User Guide 是 &lt;a href="http://www.xilinx.com/support/documentation/user_guides/ug190.pdf"&gt;UG190&lt;/a&gt;，以下内容都是从中摘抄的笔记。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Three Types of clock resource&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Global Clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了时钟目的，每个 Virtex-5 系列的器件内部都被分成不同的区域（regions），随着器件的尺寸不同，最小的有 8 个区域，最大的有 24 个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟资源（Global I/O）和局部时钟资源可以完成所有的复杂的/简单的时钟要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不推荐使用其他的非时钟资源（比如局部布线资源）来完成时钟功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 Virtex-5 系列的器件都有 32 条全局时钟线 （global clock line），可以驱动片上的所有时序资源（CLB、BRAM、CMTs、I/O），也可以驱动其他的逻辑信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些全局时钟线可以用在任何一个区域中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟线只能由全局时钟缓冲器（global clock buffer）驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器一般由时钟管理块（Clock Management Tile, CMT）驱动，以减少时钟布线延时或者调整和另外一个时钟的相对延时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟的个数比 CMTs 多，但是一个 CMT 可以驱动多个全局时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Regional Clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个区域（region）含有 2 个局部时钟缓冲器（regional clock buffer）和 4 个局部时钟树（regional clock tree）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了处于芯片中心列的组（bank）外，一个 Virtex -5 I/O bank 恰好横跨一个区域。大小和区域完全相同的每个组含有 4 个 clock-capable 的时钟输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个输入可以差分驱动或单端驱动同一组或区域中的四个 I/O 时
钟（I/O clocks）和两个区域时钟（regional clock）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;I/O clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第三种时钟资源是 I/O clocks，可以达到非常高的速度，用于局部的 I/O 串行器/解串器。
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Global Clocking Resources&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局时钟（global clocks）是个专用网络，是专为覆盖对 FPGA 中各种资源的所有时钟输入设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟资源包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Global Clock Inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Global Clock Buffers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Tree and Nets-GCLK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Regions&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Global Clock Inputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 FPGA 包含专用的全局时钟输入位置，这些输入位置即使不用作时钟输入，也可用作常规用户 I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个器件有 20 个全局时钟输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟输入可以按任意 I/O 标准配置，包括差分 I/O 标准。每个时钟输入可以是单端输入，也可以是差分输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Global Clock Input Buffer Primitives&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IBUFG，单端输入全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IBUFGDS，差分输入全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Global Clock Buffers&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个 Virtex-5 器件有 32 个全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每半个晶片 （上半 / 下半）包含 16 个全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器允许各种时钟源 / 信号源接入全局时钟树和网。可以输入全局时钟缓冲器的源包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Global clock inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Management Tile (CMT) outputs including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Digital Clock Managers (DCMs)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase-Locked Loops (PLLs)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Other global clock buffer outputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;General interconnect&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器只能由同半个晶片 （上半 / 下半）中的源驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，在一个时钟区域中仅能驱动十个不同的时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域 （20 个 CLB）是由上十个 CLB 行和下十个 CLB 行组成的时钟树的一个
枝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域仅横跨器件的一半。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Global Clock Buffer Primitives&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BUFGCTRL、BUFG、BUFGCE、BUFGCE_1、BUFGMUX、BUFGMUX_1、BUFGMUX_CTRL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他所有原语均出自 &lt;strong&gt;BUFGCTRL&lt;/strong&gt; 的软件预设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFG&lt;/strong&gt; 全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGCE&lt;/strong&gt; 带有时钟使能（CE）的全局缓冲（BUFG）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGMUX&lt;/strong&gt; 全局时钟选择缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGP&lt;/strong&gt; = IBUFG + BUFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGDLL&lt;/strong&gt; 全局缓冲延迟锁相环（舍，被 DCM 代替）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Clock Tree and Nets - GCLK&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 时钟树是为低歪斜和低功耗操作设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何未用分枝都不连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有全局时钟线和缓冲器都以差分形式实现，这有助于大大改善占空比和共模噪声抑制能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Virtex-5 架构中，全局时钟线的引脚接入不仅限于逻辑资源的时钟引脚。全局时钟线不用局部互连即可接入 CLB 中的其他引脚。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Clock Regions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 器件通过使用时钟区域改善时钟控制分配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个时钟区域最多可有十个全局时钟域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这十个全局时钟可以由 32 个全局时钟缓冲器的任意组合驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;How to use global clock&lt;/h3&gt;
&lt;p&gt;Xilinx 芯片全局时钟资源的使用方法主要有 5 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFG + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最基本的全局时钟资源使用方法，也称为 “ BUFGP 法 ”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFGDS + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当时钟信号为差分形式时，需要用 IBUFGDS 代替 IBUFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFG + DCM + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最灵活的使用方法（一般外部提供的时钟都需要倍频、分频、移相等操作以后才可以使用，所以中间需要 DCM）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logic + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BUFG 的输入可以是普通信号，当某个信号（时钟、使能、快速路径）的扇出非常大、要求抖动延迟最小时，可以使用 BUFG 来驱动这个信号，使这个信号利用全局时钟资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logic + DCM + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DCM 的输入也可以是普通信号，所以上面的例子中的信号需要倍频、分频等操作时，需要在中间添加 DCM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在具体使用这些组合方式时，有两种例化方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在设计中直接例化全局时钟资源&lt;/p&gt;
&lt;p&gt;比较简单，按照需求例化上面 5 种组合方式即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在综合阶段/实现阶段通过约束文件的方式实现&lt;/p&gt;
&lt;p&gt;随着综合工具/布局布线工具的不同而变化，大多数综合工具会自动分析时钟信号的扇出数目，在全局时钟资源富裕的情况下，使扇出数目最大的信号自动指定使用全局时钟资源。这时候我们必须保证满足下面的原则，否则会报错。如果不能满足，则必须在约束文件中明确声明该信号不使用全局时钟资源。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="no"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;CLK&amp;quot;&lt;/span&gt; &lt;span class="no"&gt;CLOCK_DEDICATED_ROUTE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Principle in Using global clock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原则：&lt;/strong&gt; 使用 IBUFG / IBUFGDS 的必要条件是信号从全局时钟引脚输入。&lt;/p&gt;
&lt;p&gt;也就是说，如果某个信号从全局时钟引脚输入，不管它是否为时钟信号，必须使用 IBUFG/IBUFGDS；如果对某个信号使用了 IBUFG/IBUFGDS，则这个信号必须从全局时钟引脚输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt; 由 Xilinx FPGA 内部结构决定的，IBUFG/IBUFGDS 的输入端仅和芯片的全局时钟引脚有物理连接，与普通的 I/O 和其他内部 CLB 等没有物理连接。&lt;/p&gt;
&lt;h3&gt;P.S. 第二全局时钟资源&lt;/h3&gt;
&lt;p&gt;在看其他资料时，看到一种新的时钟资源 —— 第二全局时钟资源。官方的文档我还没有找到，所以就直接摘抄书上的笔记了 =.=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第二全局时钟资源属于长线资源，长度和驱动能力仅次于全局时钟资源，也可以驱动芯片内部的任何一个逻辑，抖动和延时仅次于全局时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在设计中，一般将高频率、高扇出的时钟使能信号以及高速路径上的关键信号指定为全局第二时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用全局时钟资源并不占用逻辑资源，也不影响其他布线资源；第二时钟资源占用的是芯片内部的资源，占用部分逻辑资源，各个部分的布线会相互影响，所以建议在设计中逻辑占用资源不超过70%时使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在约束编辑器中的专用约束Misc选项中，指定所选信号使用低抖动延迟资源“Low Skew”来指定，也可以在ucf文件中添加“USELOWSKEWLINES"约束命令。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="no"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;s1&amp;quot;&lt;/span&gt; &lt;span class="no"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="no"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;s2&amp;quot;&lt;/span&gt; &lt;span class="no"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="no"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;s3&amp;quot;&lt;/span&gt; &lt;span class="no"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Regional Clocking Resources&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区域时钟网络是一组独立于全局时钟网络的时钟网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与全局时钟不同，区域时钟信号 (BUFR) 的跨度限于三个时钟区域，而 I/O 时钟信号只驱动一个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 时钟控制资源和网络由以下通路和组件构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Clock Capable I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O Clock Buffer (BUFIO)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regional Clock Buffer (BUFR)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regional Clock Nets&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Clock Capable I/O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;典型时钟区域中有四个 clock-capable I/O 引脚对 （中心列有例外）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有些全局时钟输入也是 clock capable I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个组中有四个专用 clock capable I/O 区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当用作时钟输入时，clock-capable 引脚可以驱动 BUFIO 和 BUFR。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些引脚不能直接连接到全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;I/O Clock Buffer - BUFIO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I/O 时钟缓冲器 (BUFIO) 是可以在 Virtex-5 器件中使用的一种时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 驱动 I/O 列内一个独立于全局时钟资源的专用时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 只能由位于同一时钟区域的 clock capable I/O 驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型的时钟区域中有四个 BUFIO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 不能驱动逻辑资源 （CLB、Block RAM 等），因为 I/O 时钟网络只能覆盖同一组或时钟区域内的 I/O 列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFIO Primitive&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFIO 其实就是一个时钟输入和时钟输出缓冲器。输入与输出之间有一个相位延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Regional Clock Buffer - BUFR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区域时钟缓冲器 (BUFR) 是可以在 Virtex-5 器件中使用的另一种时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFR 将时钟信号驱动到时钟区域内一个独立于全局时钟树的专用时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 BUFR 可以驱动其所在区域中的四个区域时钟和相邻区域 （最多三个时钟区域）中的四个时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 BUFIO 不同，BUFR 不仅可以驱动其所在时钟区域和相邻时钟区域中的 I/O 逻辑，还可以驱动其中的逻辑资源 （CLB、Block RAM 等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型的时钟区域 （四个区域时钟网络）中有两个 BUFR。中心列没有 BUFR。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFR Primitive&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFR 是一个具有输入时钟分频功能的时钟输入 / 时钟输出缓冲器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Regional Clock Nets&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;除了全局时钟树和网（global clock trees and nets），Virtex-5 器件还包含区域时钟网（Regional Clock Nets）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些时钟树也是为低歪斜和低功耗操作设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未用分枝都不连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域时钟网的传播并非遍及整个 Virtex-5 器件，而是仅限于一个时钟区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域包含四个独立的区域时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要接入区域时钟网，BUFR 必须例化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 BUFR 最多可以驱动两个相邻时钟区域中的区域时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Clock Management Technology&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 系列的芯片内部含有的时钟管理模块（Clock Management Tiles，CMTs）可以提供灵活的、高性能的时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 CMT 由 2 个 DCM 和 1 个 PLL 组成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DCM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DCM 原语有两个：DCM_BASE、DCM_ADV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCM_BASE 提供基本的功能，比如去歪斜、频率合成、固定相移；DCM_ADV 提供更高级的功能，比如动态重配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个原语都有各自的输入输出端口、属性设置和状态标识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCM 可以连接到芯片上的其他时钟资源，包括专用时钟 I/O，时钟缓冲器和PLL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==================Update (09/12/2014) 看到一篇介绍 DCM 的&lt;a href="http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;amp;tid=88967&amp;amp;page=1"&gt;文章&lt;/a&gt;，很有意思=================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;About DCM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DCM 的内部是 DLL (Delay Lock Loop) 结构，对时钟偏移量的调节是通过长达延时线形成的。&lt;/p&gt;
&lt;p&gt;DCM 会把输入时钟 &lt;code&gt;clkin&lt;/code&gt; 和 反馈时钟 &lt;code&gt;clkfb&lt;/code&gt; 相比较，调节 &lt;code&gt;clkin&lt;/code&gt; 和 &lt;code&gt;clk_1x&lt;/code&gt; 之间的延时线的数目，直到 &lt;code&gt;clkin&lt;/code&gt; 和 &lt;code&gt;clkfb&lt;/code&gt; 之间的相位差等于所设置的参数 &lt;code&gt;PHASESHIFT&lt;/code&gt;。如果 &lt;code&gt;clk_1x&lt;/code&gt; 和 &lt;code&gt;clkfb&lt;/code&gt; 不相关的话，那么就永远不能锁定了。&lt;/p&gt;
&lt;p&gt;这个从一开始的不等于到等于所花费的时间就是输出时钟锁定的时间，锁定之后，&lt;code&gt;locked&lt;/code&gt; 信号才会变高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DCM 的常用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dcm_usage" src="/images/the-clock-design-in-fpga-1-summary-of-clock-resource/dcm_usage.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;将其输出 &lt;code&gt;clk_1x&lt;/code&gt; 连接到 &lt;code&gt;BUFG&lt;/code&gt; 的输入，通过 BUFG 之后的输出一条支路是反馈到 DCM 的反馈时钟引脚 &lt;code&gt;clkfb&lt;/code&gt; 上，另外一条支路则输出驱动其他单元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DCM 消除 skew&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;DCM 的输出开始走线到达寄存器，这段路程导致的 skew 是永远存在的，DCM 为什么可以消除呢？&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为说明方便起见,我们将BUFG的输出引脚叫做 &lt;code&gt;clk_o&lt;/code&gt;,从 clk_o 走全局时钟布线到寄存器时叫做 &lt;code&gt;clk_o_reg&lt;/code&gt;,从 clk_o 走线到 DCM 的反馈引脚 CLKFB 上时叫 &lt;code&gt;clkfb&lt;/code&gt;,如上图所示。实际上 clk_o, clk_o_reg, clkfb 全部是用导线连在一起的。&lt;/p&gt;
&lt;p&gt;所谓时钟 skew,指的就是 clk_o 到 clk_o_reg 之间的延时。如果打开 FPGA_Editor 看底层的结构,就可以发现虽然 DCM 和 BUFG 离得很近,但是从 clk_o 到 clkfb 却绕了很长一段才走回来,从而导致从 clk_o 到 clk_o_reg 和 clkfb 的延时大致相等。&lt;/p&gt;
&lt;p&gt;总之就是 clk_o_reg 和 clkfb 的相位应该相等。所以当 DCM 调节 clkin 和 clkfb 的相位相等时,实际上就调节了 clkin 和 clk_o_reg 相等。而至于 clk_1x 和 clk_o 的相位必然是超前于 clkin, clkfb, clk_o_reg 的,而 clk_1x 和 clk_o 之间的延时就很明显,就是经过那个 BUFG 的延迟时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对时钟 skew 的进一步讨论&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后,说一说时钟 skew 的概念。&lt;/p&gt;
&lt;p&gt;时钟 skew 实际上指的是时钟驱动不同的寄存器时,由于寄存器之间可能会隔得比较远,所以时钟到达不同的寄存器的时间可能会不一样,这个时间差称为 &lt;code&gt;时钟 skew&lt;/code&gt; 。这种时钟 skew 可以通过 &lt;code&gt;时钟树&lt;/code&gt; 来解决,也就是使时钟布线形成一种树状结构,使得时钟到每一个寄存器的距离是一样的。很多 FPGA 芯片里就布了这样的时钟树结构。也就是说,在这种芯片里,时钟 skew 基本上是不存在的。&lt;/p&gt;
&lt;p&gt;说到这里,似乎有了一个矛盾,既然时钟 skew 的问题用时钟树就解决了,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;那么为什么还需要 DCM + BUFG 来解决这个问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外,既然时钟skew指的时时钟驱动不同寄存器之间的延时,那么上面所说的 clk_o 到 clk_o_reg 岂非不能称为时钟 skew？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先说后一个问题。在一块 FPGA 内部,时钟 skew 问题确实已经被 FPGA 的时钟方案树解决,在这个前提下 clk_o 到 clk_o_reg 充其量只能叫做 &lt;code&gt;时钟延时 delay&lt;/code&gt;,而不能称之为时钟skew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于第一个问题，个人不认同原博主的答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可惜的是FPGA的设计不可能永远只在内部做事情,它必然和外部交换数据。例如从外部传过来一个32位的数据以及随路时钟,数据和随路时钟之间满足建立保持时间关系(Setup Hold time),你如何将这32位的数据接收进来？如果你不使用DCM,直接将clkin接在BUFG的输入引脚上,那么从你的clk_o_reg就必然和clkin之间有个延时,那么你的clk_o_reg还能保持和进来的数据之间的建立保持关系吗？显然不能。相反,如果你采用了DCM,接上反馈时钟,那么clk_o_reg和clkin同相,就可以利用它去锁存进来的数据。可见,DCM
+ BUFG的方案就是为了解决这个问题。而这个时候clk_o到clk_o_reg的延时,我们可以看到做内部寄存器和其他芯片传过来的数据之间的时钟skew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为这个答案有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;外部数据和芯片不同源，算是异步问题，应该用同步化来解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随路失踪一般不驱动芯片的整个时钟网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，我认为答案应该是：&lt;/p&gt;
&lt;p&gt;要使用全局时钟网络，必须通过 BUFG 才行，所以才会用到 BUFG；而之所以用到 DCM 是因为它可以实现时钟的闭环控制，而且可以把时钟映射到 PCB 上，用于同步外部芯片，减少了对外部芯片的要求，将时钟控制一体化，利于系统设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在一片 FPGA 中使用两个 DCM，需要注意两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置 DCM 使用的时钟输入 &lt;code&gt;clk_in&lt;/code&gt; 是源自 FPGA 内部的，此时不能直接连接引脚的信号，需要加入缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应该手动例化一个 IBUFG，然后把 IBUFG 的输出连接到两个 DCM 的输入端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有这么做，而是完全按照单个 DCM 的流程使用，那么因为时钟引脚和两个 DCM 的路径长短不同，无法做到输入时钟、两个 DCM 的输出信号的相位对齐，输入时钟只能和其中一个对其，如果对相位有要求，则必须手动调整 DCM 在芯片中的位置。&lt;/p&gt;
&lt;h3&gt;PLL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 芯片最多包含了 6 个 CMT 模块，每个 CMT 模块包含一个 PLL，PLL 主要用来广谱频率的合成，并且与 DCM 配合最为外部/内部时钟的抖动滤波器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLL 也有两个原语：PLL_BASE、PLL_ADV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLL_BASE 提供基本的功能，比如时钟去歪斜、频率合成、精确相移、占空比调整；PLL_ADV 提供更高级的功能，比如时钟切换、动态重配置等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MMCM&lt;/h3&gt;
&lt;p&gt;不同系列的芯片内部的时钟管理模块是不同的，比如在 Virtex-5 系列后的芯片就含有了 混合模式时钟管理器 MMCM 。&lt;/p&gt;
&lt;p&gt;具体实现时该如何选择 DCM、DLL、PLL、MMCM ？找到一篇介绍 Xilinx 时钟资源的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ednchina.com/ART_8800512846_18_20010_TA_25f01c24.HTM"&gt;如何正确使用FPGA的时钟资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Other Tips&lt;/h2&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般来说，外部提供的时钟信号都需要进行倍频/分频才可以使用，这时候需要组合各种时钟缓冲器和 DCM、PLL 等模块，我们有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;代码中例化原语，手动组合各种时钟缓冲器和 DCM、PLL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 IP core 向导，创建时钟管理器（可以发现 IP core 生成的代码就是上面 5 种组合方式）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;个人感觉使用第二种方法应该更加简洁、方便，不容易出错吧。（如果在代码中没有明确声明使用buffer，ISE 综合属性、IP core 属性设置里面默认会给所有的输入输出自动加上缓冲器）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 FPGA 设计而言，全局时钟是最简单最可预测的时钟，最好的时钟方案是：由专用的全局时钟输入引脚驱动单个全局时钟，并用后者去控制设计中的每个触发器。全局时钟资源是专用布线资源，存在与全铜布线层上，使用全局时钟资源不影响芯片的其他布线资源，因此在可以使用全局时钟的时候尽可能使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;虽然各个芯片都不尽相同，但是了解相关的基本知识有利于我们快速掌握芯片的时钟资源、快速上手。&lt;/p&gt;
&lt;p&gt;Xilinx 的所有器件上的时钟资源可以分为前面说的 3 类：全局时钟（global clock）、局部时钟（regional clock）、I/O 时钟（I/O clock），但是不同的器件内部含有的时钟管理模块是不同的，具体到每一款芯片，应该以对应的 User Guide 为准。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/user_guides/ug190.pdf"&gt;Virtex 5 User Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发使用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ednchina.com/ART_8800512846_18_20010_TA_25f01c24.HTM"&gt;如何正确使用FPGA的时钟资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;amp;tid=88967&amp;amp;page=1"&gt;FPGA DCM时钟管理单元的理解&lt;/a&gt;&lt;/p&gt;</summary><category term="clock design"></category><category term="clock resource"></category></entry><entry><title>Verilog 中的参数化建模</title><link href="http://guqian110.github.io/pages/2014/07/09/parameterization_modeling_in_veriog.html" rel="alternate"></link><updated>2014-07-09T23:03:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-07-09:pages/2014/07/09/parameterization_modeling_in_veriog.html</id><summary type="html">&lt;p&gt;和写软件程序一样，我们也希望 Verilog 的模块也可以重利用。要使模块可以重复利用，关键就在于避免硬编码(hard literal)，使模块参数化。&lt;/p&gt;
&lt;p&gt;参数化建模的好处是可以使代码清晰，便于后续维护和修改。&lt;/p&gt;
&lt;p&gt;Verilog 的参数化建模是有一定限制的，它的参数值是编译时计算的，不会引入任何实际的硬件电路。参数必须在编译时确定值。也就是说只能达到动态编译，固态运行，而非软件的动态编译，动态运行。&lt;/p&gt;
&lt;p&gt;这主要是因为它是描述(Description)硬件的语言，而非软件设计(Design)语言。&lt;/p&gt;
&lt;p&gt;比如一个计数器，我们可以设置一个参数来指定它的计数周期(动态编译)，但是这个计数周期在综合之后就是固定值了(固态运行)，不能在运行的时候动态地改为另外一个值(除非电路综合时同时产生了多个计数器，这种情况不算真正意义上的动态运行，而且也达不到真正意义上的动态运行，因为不可能把所有可能的计数器都实现了备用，耗费资源而且没有实际意义)。&lt;/p&gt;
&lt;p&gt;参数化建模的主要目的是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高模块的通用性，只需要修改参数，不用修改其他代码就可以适用于不同的环境中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下我找到的资料，具体的参数化建模方法一共就 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 宏定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;parameter&lt;/code&gt; 模块参数化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`ifdef&lt;/code&gt; 等 条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面详细说明&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Define Macro Substitution&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 是编译器指令，功能是全局宏定义的文本代替。它类似于 C 语言中的 &lt;code&gt;#define&lt;/code&gt;，用法如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// define&lt;/span&gt;
&lt;span class="cp"&gt;`define     WORD_REG    reg     [31:0]&lt;/span&gt;

&lt;span class="c1"&gt;// using&lt;/span&gt;
&lt;span class="no"&gt;`WORD_REG&lt;/span&gt;   &lt;span class="n"&gt;reg32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;`define 定义的宏的作用域是全局的，这种机制会导致两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可能会有在不同文件中发生重定义的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译顺序有要求 file-order dependent，必须确保使用前，宏定义有效，所以每个使用到宏定义的源文件必须包含这个头文件，这会导致多重包含的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于第一个问题，尽可能把所有的宏定义放在同一个头文件中，比如 "global_define.vh"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于第二个问题，和 C++ 类似，头文件应该使用头文件保护符。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// global_define.vh head file&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt; &lt;span class="no"&gt;GLOBAL_DEFINE_VH&lt;/span&gt;
&lt;span class="cp"&gt;    `define     MAX = 8&lt;/span&gt;
&lt;span class="cp"&gt;    `define     SIZE = 4&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="no"&gt;`enif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Parameter&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Parameter&lt;/h3&gt;
&lt;p&gt;应该避免硬编码设计 &lt;code&gt;hard literal&lt;/code&gt;，使用参数 &lt;code&gt;parameter&lt;/code&gt; 来代替。举个例子&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// use parameter&lt;/span&gt;
&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="no"&gt;MAX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;      &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// DO NOT use hard literal&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;     &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Localparam&lt;/h3&gt;
&lt;p&gt;Verilog-2001 中添加了一个新的关键字 &lt;code&gt;localparam&lt;/code&gt;，用来定义模块内部的、不能被其他模块修改的局部常量，概念类似于 C++ 中 class 的 protect 成员。&lt;/p&gt;
&lt;p&gt;虽然 localparam 不能被外部模块修改，但是它可以用 parameter 来初始化。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;  &lt;span class="no"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;localparam&lt;/span&gt; &lt;span class="no"&gt;N1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Parameter Redefinition&lt;/h3&gt;
&lt;p&gt;在 Verilog-2001 出现之前，Verilog-1995 中只有两种方法实现参数重定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 # 符号，顺序列表重定义&lt;/li&gt;
&lt;li&gt;使用 defparam&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逐个讨论&lt;/p&gt;
&lt;h4&gt;1. Uisng &lt;code&gt;#&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个栗子，模块 myreg&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;myreg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;Trst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;Tclk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;在上一层的模块中传递参数例化这个模块&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt;  &lt;span class="n"&gt;bad_warpper&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;// legal parameter passing&lt;/span&gt;
    &lt;span class="n"&gt;myreg&lt;/span&gt;   &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// illegal parameter passing&lt;/span&gt;
    &lt;span class="c1"&gt;// myreg #(,,8) r1(.q(q), .d(d), .clk(clk), .rst(rst) );&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然每次例化都要说明所有的参数值，但是比第二种方法好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次例化都要说明所有的参数值。&lt;/p&gt;
&lt;h4&gt;2. Using &lt;code&gt;defparam&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;defparam&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;比如在上面的例子中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;defparam&lt;/span&gt;    &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以放在任何文件的任何地方，不用再重复没有修改的参数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 defparam 有这么 "强" 的功能，反而会导致一系列的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Hierarchical deparam. &lt;/p&gt;
&lt;p&gt;比如顶层模块使用 defparam 修改子模块的参数，子模块中又使用 defparam 修改顶层模块要传递进来的参数，形成一个环，这样子可能导致综合时不提示错误，但是结果与预期不符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiple defparams&lt;/p&gt;
&lt;p&gt;在 单个文件 / 多个文件 中重复定义 defparam，会有微妙的问题，Verilog-1995 中没有定义这种现象，实际结果依赖于使用的综合工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为 defparam 有这么多缺点，所以在 2001 年之前，Synopsys 是不支持 defparam 的，网上很多转载的博客都说 defparam 是不可综合的，实际上在后来，Synopsys 在压力之下添加了对其的支持。而我用 XST 也证明是支持 defparam 可综合。&lt;/p&gt;
&lt;p&gt;综上原因，Verilog Standards Group (VSG) 倡议大家抵制使用 defparam，大神 Clifford E. Cummings 在论文中建议综合工具如果用户坚持使用 defparam 语句，必须添加以一个参数 &lt;code&gt;+Iamstupid&lt;/code&gt;...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"The Verilog compiler found a defparam statement in the source code at
(file_name/line#).
To use defparam statements in the Verilog source code, you must include the switch
+Iamstupid on the command line which will degrade compiler performance and introduce
potential problems but is bug-compatible with Verilog-1995 implementations.
Defparam statements can be replaced with named parameter redefinition as define by
the IEEE Verilog-2001 standard."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;总结一下，可以发现 Verilog-1995 中的两种方法都不怎么好，显然 VSG 也发现了这个问题，所以在 Verilog-2001 中，出现了第三种方法，并且墙裂推荐使用这种新方法。&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;3. Using named parameter redefinition&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于模块例化时端口连接的方式，比如上例中只想改变 SIZE 的值&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;myreg&lt;/span&gt;   &lt;span class="p"&gt;#(.&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合了前两种方法的有点，既显示说明了哪个参数值改变了，也将参数传递放在了实例化的语句中。这种方法是最干净的 (cleanest) 方法，不依赖于任何综合工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;貌似没有～&lt;/p&gt;
&lt;h3&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;clock cycle definition&lt;/p&gt;
&lt;p&gt;因为时钟是一个设计中最基本的常量，它不会在随着模块变化，所以应该用 &lt;code&gt;`define&lt;/code&gt; 来定义，并且将它放在顶层的头文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FSM&lt;/p&gt;
&lt;p&gt;在一个设计中可能有不止一个 FSM，而通常 FSM 有一些共同的状态名字，比如 IDLE、READY、READ、WRITE、ERROR、DONE 等，所以应该用 &lt;code&gt;localparam&lt;/code&gt; 来定义这些常量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Conditional Compilation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Verilog 的条件编译和 C 也十分类似。前面介绍 define 时，已经用到了条件编译中的 &lt;code&gt;`ifdef&lt;/code&gt;。条件编译一共有 5 个关键字，分别是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;ifdef&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;   &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;elsif&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;endif&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;ifndef&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;条件编译一般在以下情况中使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择一个模块的不同部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的时序和结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的仿真激励&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// example1&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example2&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example3&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`elsif&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example4&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;条件编译是一个非常好的技术，它可以帮助我们更好的管理代码。&lt;/p&gt;
&lt;p&gt;举个栗子，比如我们写了一个程序，在 debug 阶段，在程序中添加了很多显示中间变量的语句，到最后 release 时，当然要去掉这些语句。最差的方法当然是删掉这些代码，但是如果以后我们还想 debug 时，又得手动写，而且时间长了，我们自己都记不清该加哪些语句了。稍微好点的方法是把它们注释起来，但是同样，时间长了，哪些该注释，那些不该注释又混淆了。最好的方法就是用条件编译。我们可以定义一个宏 DEBUG&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;`define DEBUG&lt;/span&gt;

&lt;span class="c1"&gt;// conditional compilation&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="no"&gt;DEBUG&lt;/span&gt;
    &lt;span class="c1"&gt;// debug&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// release&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这样，我们只需要选择是否注释第一行的宏定义就可快速在 debug 和 release 之间切换。&lt;/p&gt;
&lt;p&gt;再比如在 Verilog 的模块中，针对不同的应用环境，我们要实现不同的模块，这时候也可以使用条件编译选择具体综合哪段代码。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;总结一下，就是一下几点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要时使用条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;IEEE Std 1364-1995&lt;/p&gt;
&lt;p&gt;IEEE Std 1364-2001&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsHDLCON2002_Parameters_rev1_2.pdf"&gt;New Verilog-2001 Techniques for Creating Parameterized Models&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/oomusou/archive/2008/07/09/verilog_parameter.html"&gt;(原创) 如何使用参数式模组? (SOC) (Verilog) (C/C++) (template)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.chinaaet.com/detail/14875"&gt;艾米电子 - 参数与常量，Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/ilove314/blog/2012-03/231583_52a1d.html"&gt;Verilog代码可移植性设计&lt;/a&gt;&lt;/p&gt;</summary><category term="parameterization"></category></entry><entry><title>FPGA 数字处理基础 (2)</title><link href="http://guqian110.github.io/pages/2014/07/07/fpga_digital_processing_basic_2.html" rel="alternate"></link><updated>2014-07-07T23:28:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-07-07:pages/2014/07/07/fpga_digital_processing_basic_2.html</id><summary type="html">&lt;p&gt;讨论 FPGA 中无符号数 unsigned 和有符号数 signed 的问题。&lt;/p&gt;
&lt;h2&gt;Basic Knowledge&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;整数的分类：&lt;/strong&gt; 无符号数 &lt;code&gt;unsigned&lt;/code&gt; 和 有符号数 &lt;code&gt;signed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数制：&lt;/strong&gt; 10、2、8、16 进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器数：&lt;/strong&gt; 机器数的意思是数字在机器中的表示方式。主要有 3 种&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原码 sign-magnitude&lt;/code&gt;、&lt;code&gt;反码 one's complement&lt;/code&gt;、&lt;code&gt;补码 two's complement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以前写过的一篇总结： &lt;a href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统：&lt;/strong&gt; 采用二进制、补码系统。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FPGA 中是如何表示数字的呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以前写过一篇总结，&lt;a href="http://guqian110.github.io/pages/2014/05/14/fpga_digital_processing_basic_1.html"&gt;FPGA 数字处理基础 (1)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文算是上面文章的续吧。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;(un)signed in Verilog&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Integer&lt;/h3&gt;
&lt;p&gt;在 Verilog 中表示一个整数可以有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;简单的数字&lt;/p&gt;
&lt;p&gt;即只有简单的数字，默认为有符号数。比如 8, -10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数表示法 &lt;code&gt;&amp;lt;size&amp;gt;'&amp;lt;s&amp;gt;&amp;lt;base&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，size 指定需要多少位表示这个数字，有 s 表示这个数为有符号数，没有则表示这个数是无符号数，base 指定后面的 value 是使用哪种基数来描述，value 制定这个数字的大小。默认为无符号数，除非声明 s 字段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在 FPGA 也采用补码系统&lt;/strong&gt;，即在综合时，综合工具会将有符号数翻译为补码，在硬件中存储起来。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d5&lt;/span&gt;   &lt;span class="c1"&gt;// 这个数为无符号数，理解为 5, 占用 8 bit，存储的值为 0101&lt;/span&gt;
&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt;  &lt;span class="c1"&gt;// 这个数为有符号数，理解为 5, 占用 8 bit，存储的值为 0101&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d5&lt;/span&gt;  &lt;span class="c1"&gt;// 这个数为无符号数，理解为 -5, 占用 8 bit，存储的值为 1011&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt; &lt;span class="c1"&gt;// 这个数为有符号数，理解为 -5, 占用 8 bit，存储的值为 1011&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Register&lt;/h3&gt;
&lt;p&gt;Verilog 中数据的基本类型： &lt;code&gt;wire&lt;/code&gt;、&lt;code&gt;reg&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 Verilog-1995 中，规定所有的 wire、reg 都是 unsigned 类型，只有 integer 是 signed 类型。但是 integer 的宽度是固定的(与宿主机的字是一样的，最小为 32 位)，这样子，造成了很大的不方便和浪费。&lt;/p&gt;
&lt;p&gt;在 Verilog-2001 中，添加了 wire、reg 也可以是 signed 类型了。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据可以是 signed 和 unsigned，寄存器也可以是 signed 和 unsigned，那么综合时，是以哪个为准呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题一开始自己没有搞清楚，迷惑了一下午，后来写了几个小测试程序，最后发现这个结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;以变量类型为准&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;即 reg/wire 为哪种，那么综合时就以这个为标准进行综合。比如当 reg 为 unsigned 类型，当我们给它赋值为 signed 类型的数据 &lt;code&gt;-5&lt;/code&gt;(&lt;code&gt;-4’d5&lt;/code&gt;) 时，综合出来的结果为 reg 存储的是 &lt;code&gt;-5&lt;/code&gt; 的补码 &lt;code&gt;1011&lt;/code&gt;,但是解释为 unsigned 类型的 &lt;code&gt;+11&lt;/code&gt;。这时候就结果和我们的预期是不一样的，出现了误差，一定要注意！另一种情况类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果参与运算的变量混合有 signed 和 unsigned 类型，那么会将 signed 转换为 unsigned 类型。(应该避免这种情况)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;=========================================以下为详细的分类讨论==================================&lt;/p&gt;
&lt;p&gt;编写一个简单的测试程序，查看综合结果和仿真波形，就可以知道综合时的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;module: &lt;a href="http://guqian110.github.io/files/test_signed.v"&gt;test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;testbench: &lt;a href="http://guqian110.github.io/files/tb_test_signed.v"&gt;tb_test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;1. unsigned reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;那么可以从 RTL Schematic 中看到，综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4&gt;2. unsigned reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;那么综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4&gt;3. signed reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4&gt;4. signed reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4&gt;5. signed reg &amp;amp; unsigned reg&lt;/h4&gt;
&lt;p&gt;如果参与运算的两个变量一个是 signed，另一个是 unsigned。（注意这种现象应该避免，一般我们是不会将两种不同类型的数据混在一起进行计算的）&lt;/p&gt;
&lt;p&gt;定义 i 为 unsigned 类型，flag 为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;给 flag 赋值为 signed 的 -5&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// sigend&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;综合出来的比较器为 unsigned 类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 变量 integer 也是也可综合的。在上例中，如果将 flag 的类型改为 integer 也是可综合的，但是，因为只用到了低 8 位，所以在综合时会提示高 24 位是未连接 unconnected，但是因为 integer 是一个整体，所以即使未连接也不能优化掉，这就是在 Verilog-1995 中 integer 不够灵活的体现，好在 Verilog-2001 中已经添加了支持 reg/wire 为 signed 的类型，而且综合工具(XST)也是支持的。&lt;/p&gt;
&lt;p&gt;=======================================分割线结束==========================================&lt;/p&gt;
&lt;p&gt;以前只知道硬件上最基本的一些运算单元，比如加法器(adder)、减法器(subtractor)、比较器(comparator) 等，完成的功能是固定的，电路是不会检查输入数据的类型的。涉及到 signed 和 unsigned 类型，就出现一个问题：对于基本运算单元(比如加法器)，运算单元并不知道输入的数据是哪种数据，对于 unsigned 和 signed 类型，必然出现适合一种时不适合另外一种的问题。&lt;/p&gt;
&lt;p&gt;所以可以推断出 &lt;strong&gt;对于不同的数据类型，同样是个加法器，底层的硬件电路是不一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我在程序中定义了 signed 和 unsigned 类型的数据，那么综合工具是否足够智能，能够根据数据的类型综合出正确适合的电路？&lt;/p&gt;
&lt;p&gt;答案是肯定的，即&lt;strong&gt;综合器足够智能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面的程序证明了这一点，从 RTL 图中可以看到综合出的比较器是 signed 还是 unsigned 类型，仿真波形也可以看到，最终下载到板子上测试也符合预期。这些都证明 综合器足够智能。后来看到 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/xst.pdf"&gt;UG627(v14.5): XST User Guide&lt;/a&gt;，才发现里面已经非常清楚地写着&lt;/p&gt;
&lt;p&gt;Chapter 3: Signed and Unsigned Support in XST&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When using Verilog or VHDL in XST, some macros, such as adders or counters, can be
implemented for signed and unsigned values.
To enable support for signed and unsigned values in Verilog, enable Verilog-2001
as follows:
+ ISE® Design Suite
  Select Verilog 2001 as instructed in the Synthesis Options topic of ISE Design Suite
Help
+ XST Command Line
  Set -verilog2001 to yes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;花费了大量时间上网找资料，在论坛里问别人无果，最后自己动手写程序测试，最后才发现原来官方资料里面早就写的清清楚楚 =.=&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;说了这么多，总结下来就是下面这几句话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经验：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遇到问题，先不要急着上网求助，上网求助这个方法虽然简单，但是是最不好的，一方面别人的话不一定可靠，另一方面，放弃思考直接上网求助对学习无益。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找资料的技巧很重要。虽然我大概能够猜测到 Xilinx 官方的文档中肯定有说明，但是就是懒得去下载文档，再去找。认为网上肯定有人也有相同的困惑，所以直接 Google。结果找到一堆没有帮助的网页，浪费了时间，最后还是要看文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实践是检验真理的唯一标准，到底行不行，写测试程序，在板子上跑跑，验证一下是最有力的证明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Verilog-2001 已经支持 signed 类型的 wire 和 reg，所以我们代码中如果涉及到有符号数，那么像 C 语言一样直接定义、赋值、使用即可，综合工具会综合出正确的有符号数的运算电路。不必再像以前一样手动进行补码转换，自己来处理有符号数的补码计算的细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合时的原则是按照寄存器的类型进行综合(即上面的分类讨论的结论)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仔细对比 signed 和 unsigned 类型的综合结果，可以发现 Technology Schematic 是一样的，之所以和 “理论上硬件电路是应该不一样” 矛盾，我认为原因在于 FPGA 的实现是基于查找表的。以上面的例子来说明，这个比较器的功能最终是在一个 LUT6 的查找表上实现的，所以，ASIC 上硬件电路的不同映射到 FPGA 中就是 LUT 的内容不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="digital processing"></category></entry><entry><title>Sublime Text 2 和 Verilog HDL</title><link href="http://guqian110.github.io/pages/2014/07/04/sublime_text_2_and_verilog.html" rel="alternate"></link><updated>2014-07-04T23:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-07-04:pages/2014/07/04/sublime_text_2_and_verilog.html</id><summary type="html">&lt;h2&gt;Sublime Text&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;代码编辑器之于程序员，就如同剑之于战士。程序员关于代码编辑器的争论从来就没有停止过，每个程序员都有自己熟悉的编辑器，他们热爱自己的 “武器”，甚至可以形成 “宗教”，比如 Vim 和 Emac 的战争。&lt;/p&gt;
&lt;p&gt;如今，这个无休止的争论中要加入一个新成员了，她就是 &lt;a href="http://www.sublimetext.com/"&gt;Sublime Text&lt;/a&gt; 。其实她也不是 “新” 成员了，早在 2011 年她就诞生了，不过经过不断的改进，终于人们不得不正视这个新人，不仅仅因为漂亮的外在美，还有强大的内在美 :-P&lt;/p&gt;
&lt;p&gt;个人感觉，ST 的出现恰到好处，她兼具了 Vim 的强大功能和普通编辑器的易用性。虽然 Vim 轻巧、强大，但是 Vim 的门槛比较高，要想用好 Vim 是需要长期练习的，而 ST 可以说是老少皆宜，你是小白，不会用 Vim？没关系，她可以像普通的编辑器一样，即使你 0 基础也可以使用；你是老手，习惯 Vim？也没关系，她可以 &lt;strong&gt;开启 Vim 模式&lt;/strong&gt;，还是原来的配方，还是熟悉的味道～&lt;/p&gt;
&lt;p&gt;虽然她不是开源项目，有收费，但是我们有免费无限制无限期的试用权，而且她绿色小巧，不用安装，解压即可使用，跨平台，支持各种编程语言的代码补全和语法高亮。如果对现有的插件不满意，我们甚至可以自己定制插件。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;简单说一下我在使用过程中的一些问题，更加详细的使用官方和非官方的网站上都有详细的说明，还有别人总结的技巧请自行 Google。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.sublimetext.com/docs/2/index.html"&gt;Official docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/sublime-text-2/"&gt;Unofficial docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.iplaysoft.com/sublimetext.html"&gt;Others: Sublime Text 2 - 性感无比的代码编辑器！程序员必备神器！跨平台支持Win/Mac/Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S. 我使用的是 Sublime Text 2，虽然已经有 3 了，但是 3 还在 Beta 阶段，大家貌似对 3 不是很满意&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Vim Mode&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;ST 是自带 Vim 模式的（Vintage Mode），但是这个模式默认是没有开启的，毕竟对于大多数普通人来说， Vim 实在是不太友好...&lt;/p&gt;
&lt;p&gt;打开 ST 的 &lt;code&gt;Preferences/Setting - Defalut&lt;/code&gt;，在最后一行有句&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;ignored_packages&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Vintage&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只需要将方括号中的 Vintage 去掉就可以了。推荐在 Setting - User 中修改。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.sublimetext.com/docs/2/vintage.html"&gt;官方说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Package Control&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;ST 的一个强大之处就在于可以安装各种插件，要安装插件有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;手动下载，解压到指定目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;code&gt;Package Control&lt;/code&gt; 插件，自动管理安装插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种方法虽然麻烦，但是在没有网络的环境下，我们可以从别人那拷贝过来即可；第二种方法最方便了，不过要求有网络。&lt;/p&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;ST 默认是没有安装 Package Control 的，需要我们手动安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl ~&lt;/code&gt; 调出控制台&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在控制台中粘贴以下命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Package&lt;/span&gt; &lt;span class="n"&gt;Control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sublime&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sublime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;installed_packages_path&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;makedirs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;install_opener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build_opener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ProxyHandler&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;wb&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//sublime.wbond.net/&amp;#39;+pf.replace(&amp;#39; &amp;#39;,&amp;#39;%20&amp;#39;)).read()); print &amp;#39;Please restart Sublime Text to finish installation&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装完成之后，重启 ST 即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Using&lt;/h3&gt;
&lt;p&gt;按下 &lt;code&gt;Ctrl + Shift + P&lt;/code&gt;，在弹出的命令面板，输入 &lt;code&gt;package&lt;/code&gt;，就会自动弹出相关的命令，可以选择 &lt;code&gt;Install&lt;/code&gt;、&lt;code&gt;Remove&lt;/code&gt;、&lt;code&gt;Disable&lt;/code&gt;、&lt;code&gt;Enable&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Update&lt;/code&gt; 等命令。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sublime.wbond.net/"&gt;sublime wbond&lt;/a&gt; 上列出了 Package Control 可以找到的所有的插件，有详细的安装和使用说明。&lt;/p&gt;
&lt;p&gt;网上也有很多文章介绍了大量的常用插件，我们可以按照需求自己挑选需要的插件进行安装。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Verilog HDL&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;常用的插件，比如括号匹配、智能补全、自动对齐、Tags、注释生成、Terminal、Build、Git 等插件就不再赘述了，说一下网上介绍的比较少，但我自己使用比较多的关于 Verilog 的插件。&lt;/p&gt;
&lt;p&gt;可以通过 Package 下载到两个插件，&lt;code&gt;Verilog&lt;/code&gt; 和&lt;code&gt;Verilog-Automatic&lt;/code&gt;。第一个插件主要功能是支持 Verilog 的代码高亮和补全，第二个插件可以帮助我们自动生成模块例化、端口添加连接等功能。&lt;/p&gt;
&lt;p&gt;其中，第一个插件的 Snippet 并不太让人满意，在原 Snippet 的基础上，我添加了一些我常用到的 Snippets。&lt;/p&gt;
&lt;h3&gt;always&lt;/h3&gt;
&lt;p&gt;因为插件作者只添加了异步高有效复位方式的 &lt;code&gt;always&lt;/code&gt; 块，而我们同步和异步两种方式都可能会用到，所以，我添加同步复位的 Snippet&lt;/p&gt;
&lt;p&gt;ST 2 的 Package 都存放在 &lt;code&gt;/home/.config/sublime-text-2/Packages&lt;/code&gt; 目录下面，我们需要修改的就是这个目录下的 &lt;code&gt;Verilog/Snippets&lt;/code&gt; 下的 &lt;code&gt;.tmSnippet&lt;/code&gt; 文件。修改后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;always_async.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always @(posedge clk or ${1:posedge} ${2:rst}) begin
    if ($2) begin
        // reset
        $3
    end
    else if ($4) begin
        $0
    end
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_async&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_async&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;always_sync.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always @(posedge clk) begin
    if (${1:rst}) begin
        // reset
        $2
    end
    else begin
        $0
    end
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_sync&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_sync&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改之后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="always" src="/images/sublime-text-2-and-verilog/always.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;if-else&lt;/h3&gt;
&lt;p&gt;原来的 if snippet 没有 else 分支，所以，添加了一个有 else 分支的 if 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if ($1) begin
    $0
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;if-else.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if ($1) begin
    $2
end
else begin
    $0
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if_else&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if_else&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-else" src="/images/sublime-text-2-and-verilog/if-else.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;parameter&lt;/h3&gt;
&lt;p&gt;原来是没有 parameter 的snippets 的，拷贝一份其他的 snippet，修改其中的一些设置，即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parameter.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter   $1 = $2,
            $3 = $0
&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="parameter" src="/images/sublime-text-2-and-verilog/parameter.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;case&lt;/h3&gt;
&lt;p&gt;原来是没有 case 的 snippet，方法同上，可以修改出我们想要的 case snippet&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;case.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case ($1)
    $2: begin
        $3
    end
    $4: begin
        $5
    end
    $6: begin
        $7
    end
    $8: begin
        $9
    end
    default: begin
        $10
    end
endcase&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="case" src="/images/sublime-text-2-and-verilog/case.gif" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上面仅仅说了非常基本的几个设置，和我在写 Verilog 时自己添加的几个 snippet，其他的 ST 的使用技巧官方和非官方的 ref 有非常详细的介绍，另外其他人也有很多文章介绍～&lt;/p&gt;</summary><category term="Sublime Text"></category></entry><entry><title>FPGA 中的复位设计</title><link href="http://guqian110.github.io/pages/2014/06/20/the_art_of_reset_design_in_fpga.html" rel="alternate"></link><updated>2014-06-20T00:22:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-06-20:pages/2014/06/20/the_art_of_reset_design_in_fpga.html</id><summary type="html">&lt;p&gt;复位信号在系统中的地位和时钟信号几乎同等重要，我们想尽量把系统设计为可控，那么最基本的控制信号就是复位信号了。&lt;/p&gt;
&lt;p&gt;复位信号的设计需要考虑的因素，各种书刊、论文、白皮书、网上论坛都有相关讨论，但是至今对于给定 FPGA 设计中使用哪种复位方案仍然没有明确答案。本文总结了一些大神的经典论文和网上的许多博客，尽可能用简单的图说明选择某种设计方案及其理由，涉及的更深入的原理请自行 Google :-P&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Understanding the flip-flop reset behavior&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在开始详细讨论之前，首先得理解 FPGA 的基本单元 Slice 中的 FF 的复位方式。Xilinx 的 Virtex 5 系列的芯片中的 FF 的类型都是 DFF (D-type flip flop)，这些 DFF 的控制端口包括一个时钟 CLK，一个高有效的使能 CE，一个高有效的置位/复位 SR。这个 SR 端口可以配置为同步的置位/复位，也可以配置为异步方式的置位/复位。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/the-art-of-reset-design-in-fpga/dff.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;例化（&lt;code&gt;instantiation&lt;/code&gt;）和 推译（&lt;code&gt;inference&lt;/code&gt;）是在 FPGA 设计中使用元件的两种不同方法。综合器是通过 HDL 代码 推译（&lt;code&gt;infer&lt;/code&gt;） 最终的电路，所以我们写的 RTL 代码风格会影响最终综合出来的 FF 类型。&lt;/p&gt;
&lt;p&gt;如果代码的敏感列表中包含复位信号，那么就会综合出一个异步复位的 DFF，SR 端口将被配置为置位或者复位端口(FDPE &amp;amp; FDCE primitive)。当 SR 变高时，FF 的输出值立即变为代码中的复位时设定的值 SRVAL。&lt;/p&gt;
&lt;p&gt;同理，如果代码的敏感列表中不包含复位信号，那么就会综合出一个同步复位的 DFF，SR 端口将被配置为置位/复位端口(FDSE &amp;amp; FDRE primitive)。当 SR 变高时，FF 的输出值在下一个时钟的上升沿变为 SRVAL。&lt;/p&gt;
&lt;p&gt;虽然 FPGA 的 FF 可以配额为 preset/clear/set/reset，但是一个单独的 FF 每次只能配置为其中的一种，如果在代码中多于一个 preset/clear/set/reset，那么就会产生其他的逻辑，消耗 FPGA 资源。&lt;/p&gt;
&lt;p&gt;另外，基于 SRAM 的 FPGA 可以设定上电初始化的值：如果我们在定义 reg 变量时给它一个初始值，那么 FPGA 在上电配置(GSR 变高)时，载入这个值。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Active low  V.S.  Active high&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;大多数书籍和博客都推荐使用 “低电平有效” 的复位方案，却没有明确说明为什么使用 “低电平有效”。&lt;/p&gt;
&lt;p&gt;目前大多数书籍中都使用 低电平复位，网上给出的理由是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ASIC 设计大多数是低电平复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大多数厂商使用低电平复位多一些 (Xilinx 基本全是高电平复位，这也叫大多数？)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低电平复位方式，在上电时系统就处于复位状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3919870/"&gt;Verilog Verilog嵌入式数字系统设计教程&lt;/a&gt; 说明了原因：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One reason for using active-low logic is that some kinds of digital circuits are able to sink more current when driving an output low than they can source when driving the output high. If such an output is used to activate some condition for which current flow is required, it would be better to use a low logic level rather than a high logic level.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说目前推荐的 “低电平有效” 更多的是 IC 设计的传统，然而根据我查到资料来看，对于 Xilinx FPGA 这条传统并不适用。Xilinx 的器件全部是高电平复位端口，他们的 white paper 中的例子也都是高电平复位方式。而且，从综合结果来看，如果非要使用低电平复位，那么就会额外添加一个反相器，然后将反向得到的高电平连接到 FF 的复位端口，从而导致复位信号的传输时延增加，芯片的利用率下降，同时会影响到时序和功耗。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 中也证实了这一点，文中提到对于 Xilinx 器件，尽可能使用高有效复位，如果实在没有办法控制系统的复位极性，那么最好在系统的顶层模块中将输入的低有效复位翻转极性，这样做的好处是反向器将被吸收到 IO logic 中，不会消耗 FPGA 内的逻辑和布线资源。&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应该参考器件决定使用那种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Xilinx 器件，应该使用高电平复位方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Synchronous V.S. Asynchronous&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;因为 DFF 有两种复位端口，所以对应的有两种复位方式：同步复位 和 异步复位。两种复位方式各有特点，适用于不同的应用场景。下面先分别总结两种方案的优劣，最后总结当前流行的的主流复位方案。&lt;/p&gt;
&lt;h3&gt;Synchronous Reset&lt;/h3&gt;
&lt;p&gt;模块的 &lt;code&gt;sensitivity list&lt;/code&gt; 中不包含 &lt;code&gt;rst&lt;/code&gt; 信号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync reset" src="/images/the-art-of-reset-design-in-fpga/sync_reset.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdr&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Singal Data Rate D Flip-Flop with Synchronous Reset and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="no"&gt;FDRE&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Initial value of register (1&amp;#39;b0 or 1&amp;#39;b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;FDRE_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;R&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Synchronous reset input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDRE_inst instantiation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;有时候，有些器件不带同步复位专用端口，那么综合器一般会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;h4&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保证设计是 100% 同步，有利于时序分析，也利于仿真&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低亚稳态出现的几率，时钟起到过滤毛刺的作用(如果毛刺发生在时钟沿附近，那么仍然会出现亚稳态的问题)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在某些设计中，复位信号是由内部逻辑产生的，推荐使用同步复位，因为这样可以避免逻辑产生的毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;同步复位需要保证复位信号具有一定的脉冲宽度(脉冲延展器)，使其能被时钟沿采样到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在仿真过程中，同步复位信号可能被X态掩盖(?不懂...)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果设计中含有三态总线，为了防止三态总线的竞争，同步复位的芯片必须有一个上电异步复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果逻辑器件的目标库内的 FF 只有异步复位端口，那么使用同步复位的话，综合器会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;p&gt;有很多教材和博客都直接说 “同步复位会产生额外的逻辑资源”，可能他们是基于 Altera 的 FPGA 这么做的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="extra logic" src="/images/the-art-of-reset-design-in-fpga/extra_logic.png" /&gt;&lt;/p&gt;
&lt;p&gt;但是根据我实际的测试结果，对于 Virtex 5 系列的芯片，它的原语里面已经含有各种带同步、异步复位端口的 FF，ISE 自带的 XST 也已经很智能了，它会根据代码分析，自动选择合适的 FF。所以上面同步复位综合出来的 RTL Schematic 中没有所谓的 “多余的逻辑资源”。&lt;/p&gt;
&lt;p&gt;所以，是否占用多余的资源，还得针对具体的芯片分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Asynchronous&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="aync reset" src="/images/the-art-of-reset-design-in-fpga/async_reset.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdc&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Single Data Rate D Flip-Flop with Asynchronous Clear and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="no"&gt;FDCE&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Initial value of register (1&amp;#39;b0 or 1&amp;#39;b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;FDCE_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="c1"&gt;// 1-bit Asynchronous clear input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDCE_inst instantiation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;异步复位的优缺点和同步复位是相对应的：&lt;/p&gt;
&lt;h4&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;脉冲宽度没有限制，可以快速复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EDA 工具 route 起来更容易，对于大型设计，能显著减少编译时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有时钟的时候也可以将电路复位 (比如省电模式下，同步复位无法工作，而异步复位是可以的)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无需额外的组合逻辑 (同上，具体分析)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不是同步电路，不利于时序分析，设计者要正确约束异步复位信号比同步复位复杂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复位信号容易收到毛刺的干扰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易在复位信号撤销的时候(release)不满足 &lt;code&gt;removal time&lt;/code&gt; 时序要求，从而产生亚稳态 (关于亚稳态，网上有很多论文、博客都有详细说明)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Reset Synchronizer&lt;/h3&gt;
&lt;p&gt;两种复位方式各有优缺点，设计者应该根据实际情况选择合适的复位方法。目前，很多文献书籍中都推荐一种 “异步复位，同步释放” 的方法。这种方法可以将两者结合起来，取长补短。&lt;/p&gt;
&lt;p&gt;它的原理如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer.png" /&gt;&lt;/p&gt;
&lt;p&gt;需要注意到是，上图的复位是传统的低电平有效方式，对于 Xilinx 器件，原理图稍有不同，其复位按钮接到了 FF 的置位端，第一级 FF 的输入也由 &lt;code&gt;Vcc&lt;/code&gt; 变为 &lt;code&gt;GND&lt;/code&gt;。 &lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 介绍了对应的 RTL Schematic ：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset_synchronizer_xilinx" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_xilinx.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;对于 Xilinx 器件，用代码具体实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;SYSRST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sys_rst&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;rst_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;rst_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;sys_rst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;sys_rst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_rtl.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;rst_pb&lt;/code&gt; 是系统的复位按钮，&lt;code&gt;sys_rst&lt;/code&gt; 是同步化的结果。可以看到综合结果和上图是一致的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Simulation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="simulation" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_simulation.png" /&gt;&lt;/p&gt;
&lt;p&gt;所谓 “异步复位”，如上图(由于连接到了置位端，叫 “异步置位” 更合适)，一旦复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 有效，那么输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 立即被置为 &lt;code&gt;1&lt;/code&gt;，否则输出为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓 “同步释放”。如上图，当复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 释放时(从有效变为无效)，输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 不是立即变化，而是被 FF 延迟了一个时钟输出，从而使其和时钟同步化。这个和时钟同步化的复位信号可以有效的驱动后面的逻辑，避免亚稳态。&lt;/p&gt;
&lt;p&gt;可以看到，这种 “异步复位，同步释放” 的方法既解决了同步复位中脉冲宽度的要求，又解决了异步复位中亚稳态的问题。&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;知道了这点，选择复位信号的策略就很明显了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用同步复位，保持设计 “同步化”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了(CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无优点的。Xilinx 就是个例子，它所有的芯片都带有同步/异步复位端口)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不带有同步复位端口，那么就需要使用这种异步复位同步化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在详细讨论了复位的有效电平、复位方式之后，我们开始讨论稍微复杂一点的复位设计：包括系统的复位方案、多时钟域的复位方案、复位信号的去除毛刺等。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Think Local V.S. Think Global&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;我们使用复位信号的一个目的就是为了使电路可控，当上电时或者系统出错时，可以通过复位的方式回到正常状态。为了达到完全可控，传统的做法是对系统内的每个 FF 都连接复位信号，这样就造成了复位信号的高扇出，而高扇出会导致一系列的问题。&lt;/p&gt;
&lt;p&gt;Xilinx 有个 White Paper，&lt;a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;，提出一种新的复位思路： 能不用全局复位时，尽量不要使用，这样可以降低复位信号的扇出。&lt;/p&gt;
&lt;p&gt;这个原则和我们平时的理解和习惯是相反的，不使用全局复位的原因主要有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;随着时钟速率的提高，GSR 逐渐变为时序关键路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果电路中没有反馈环路，那么上电初始化已经足够了，很多设计中的 reset 信号都可以省去&lt;/p&gt;
&lt;p&gt;如果没有反馈环路，比如移位寄存器，即使开始状态是错误的，当数据流进入到一段时间，错误数据将被冲刷出去，所以没有必要保留 reset 信号。如果系统中有反馈环路，比如状态机，当初始状态不对或者状态跑飞时，无法回到正常状态，那么 reset 信号是有必要保留的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码中简单的添加一个 reset 端口，在底层实现时要消耗很多我们想不到的资源。&lt;/p&gt;
&lt;p&gt;全局复位会和设计中的其他单元竞争布线资源，全局复位一般来说肯定有非常高的扇出，因为它需要连接到设计中的每一个 FF。这样，它会消耗大量的布线资源，使芯片利用率下降，同时也会影响时序性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，有必要使用其他的不依靠全局复位的方法。&lt;/p&gt;
&lt;p&gt;如图所示，Xilinx FPGA 在配置/重配置的时候，每个 FF 和 BRAM 都会被初始化一个预先设定的值(大部分器件的默认值是 0, 也有例外)，所以，上电配置和全局复位有着类似的功能，将每个存储单元配置为一个已知的状态。&lt;/p&gt;
&lt;p&gt;&lt;img alt="configuration" src="/images/the-art-of-reset-design-in-fpga/configuration.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;系统在上电配置时，内部有个信号叫 &lt;code&gt;GSR&lt;/code&gt; (Global Set/Reset)，它是一种特殊的预布线的复位信号，能够在 FPGA 配置的过程中让设计保持初始状态。在配置完成后，GSR 会被释放，所有的触发器及其它资源都加载的是 INIT 值。除了在配置进程中自动使用 GSR，用户设计还可以通过实例化 STARTUP 模块并连接到 GSR 端口的方法来访问 GSR 网。使用该端口，设计者可以重新断言 GSR ，相应地 FPGA 中的所有存储元件将返回到它们的 INIT 属性所规定的状态。&lt;/p&gt;
&lt;p&gt;设定初值的语法很简单，只需要在定义变量时给它初始值就可以了：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;和 reg 类似，BRAM 也可以在配置的时候初始化，随着嵌入式系统的 BRAM 逐渐增大，BRAM 初始化非常有用：因为预先定义 RAM 的值可以使仿真更容易，而且无需使用引导序列为嵌入式设计清空内存。&lt;/p&gt;
&lt;p&gt;使用 GSR 的好处是 &lt;strong&gt;可以解决复位信号高扇出的问题&lt;/strong&gt;，因为 GSR 是预布线的资源，它不占用每个 FF 和 Latch 的 set/reset 端口，如下图所示。很多资料都推荐将设计中的 reset 按钮连接到 GSR，以利用它比较低的 skew。&lt;/p&gt;
&lt;p&gt;&lt;img alt="gsr rset" src="/images/the-art-of-reset-design-in-fpga/gsr_reset.gif" /&gt;&lt;/p&gt;
&lt;p&gt;既然 GSR 这么好，那么是不是只使用 GSR 就可以了，不必再用 FF 和 Latch 的 set/reset 端口了呢？&lt;/p&gt;
&lt;p&gt;答案当然是否定的。由于 GSR 的释放是异步方式，所以，如果我们只使用 GSR 作为系统的唯一复位机制，那么可能导致系统不可靠。所以还是需要显式地使用同步复位信号来复位状态机、计数器等能自动改变状态的逻辑。&lt;/p&gt;
&lt;p&gt;所以，应该使用 &lt;strong&gt;GSR + explict reset&lt;/strong&gt; 的解决方案：&lt;/p&gt;
&lt;p&gt;给系统中的 reg 赋初值，对于没有环路的电路节省 reset，利用 GSR 实现复位的功能；对于有环路的电路，使用显示的复位信号。&lt;/p&gt;
&lt;h3&gt;Upate: 07/01/2014&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关于 initialize 代替 reset&lt;/p&gt;
&lt;p&gt;这几天看 resest 相关问题时，又在 &lt;code&gt;stackoverflow&lt;/code&gt; 上发现一个关于&lt;a href="http://stackoverflow.com/questions/6363130/is-there-a-reason-to-initialize-not-reset-signals-in-vhdl-and-verilog"&gt;是否应该使用 initialize 代替 reset 的问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;支持用 initialize 代替 reset 的人提出的方案是尽量不要使用全局复位信号，使用初始化值代替复位，对于一些必须要求复位的模块，使用 &lt;em&gt;local&lt;/em&gt; 的复位信号。&lt;/p&gt;
&lt;p&gt;反对者认为，用 initialize 代替 reset 的想法只是学院派的不切实际的想法。一般只有基于 SRAM 的 FPGA 才会使用到初始化。而这样做的目的只是为了节省布线资源，降低时序要求，但是现代 FPGA 有很多布线资源和没有使用的全局网络，所以，复位信号一般不是时序关键路径。即使遇到问题，可以通过手动例化一个时钟 BUF 来解决。使用这种无复位的设计虽然在某些情况是可行的，但是当你把你的设计和其他系统连接起来时，通常会感到非常痛苦，因为大多数系统都会要求有个复位信号。在由 FPGA 转 ASIC 时也比较方便，因为只有基于 SRAM 的 FPGA 才可以使用这种 initialize 代替 reset 的技术，而 ASIC 不行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于 GSR&lt;/p&gt;
&lt;p&gt;网上有很多人都推荐将我们用户定义的复位信号连接到 GSR 信号上，以便利用 GSR 提供的低抖动性，包括 &lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 也推荐使用 GSR 信号。但是在 Xilinx 的另一份文档 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/sim.pdf"&gt;UG626: Synthesis and Simulation Design Guide&lt;/a&gt; 中说不推荐使用 GSR 来作为系统的复位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although you can access the GSR net after configuration, Xilinx does not recommend using the GSR circuitry in place of a manual reset. This is because the FPGA devices offer high-speed backbone routing for high fanout signals such as a system reset. This backbone route is faster than the dedicated GSR circuitry, and is easier to analyze than the dedicated global routing that transports the GSR signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这个矛盾早就有人在 Xilinx Forum 上提问了 &lt;a href="http://forums.xilinx.com/t5/Virtex-Family-FPGAs/What-does-GSR-signal-really-mean-and-how-should-I-handle-the/td-p/35610"&gt;What does GSR signal really mean and how should I handle the reset signal properly&lt;/a&gt;，还有 &lt;a href="http://forums.xilinx.com/t5/Archived-ISE-issues/FPGA-Power-On-Reset/m-p/7027?query.id=134602#M2035"&gt;FPGA Power On Reset!&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt; Conclustion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。&lt;/p&gt;
&lt;p&gt;P.S. 事实上没有一个通用的、适合所有器件的复位方案，我们应该首先了解所使用的器件和工具，针对它们的特点进行复位方案的设计。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;Shift Register Reset&lt;/h3&gt;
&lt;p&gt;并不是每一个设计，器件中的每一个寄存器都需要复位的。最好的做法是只将复位连接到那些需要复位的寄存器。一个典型特例就是移位寄存器的复位。&lt;/p&gt;
&lt;p&gt;如果一个模块内部含有一组触发器(移位寄存器)，这些寄存器可以分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;resetable flip-flops&lt;/p&gt;
&lt;p&gt;第一个 ff，它是需要复位信号的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;follower flip-flops&lt;/p&gt;
&lt;p&gt;后续的 ff，仅作为简单的数据移位寄存器，不含复位端&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么在设计时应该只复位第一个触发器，后续的触发器仅作为数据寄存器使用，不能对它们进行复位。
这里体现出来的一个原则就是：能节省 reset 时，尽量节省。&lt;/p&gt;
&lt;p&gt;原因就是 reset 作为一个实际存在的物理信号，需要占用 FPGA 内部的 route 资源，往往 reset 的fanout 又多得吓人。这就很容易造成 route 难度上升，性能下降，编译时间增加。因此，在 FPGA 设计中能省略的复位应尽量省略。&lt;/p&gt;
&lt;p&gt;比较好的设计风格，不同类型的 FF 不应该组合进单个 alway 块中。也就是说，不要把这两种 FF 写在同一个 always 块中，而应该每个 &lt;code&gt;always&lt;/code&gt; 模块只对一种 FF 建模。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bad Style:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;BADSTYLE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于第二个 ff 来说，是一个片选信号 &lt;code&gt;ce&lt;/code&gt;，这样的设计产生额外的逻辑，是不好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bad style" src="/images/the-art-of-reset-design-in-fpga/bad_style.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good Style:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;GOODSTYLE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于两个 ff 来说，都是复位信号，不需要额外的逻辑，这样的设计是比较好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="good style" src="/images/the-art-of-reset-design-in-fpga/good_style.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reset Distribution Tree&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;复位信号的 &lt;code&gt;reset distribution tree&lt;/code&gt; 和 时钟信号的 &lt;code&gt;clock distribution tree&lt;/code&gt; 差不多同等重要，因为在设计中，几乎每个器件都有时钟端口和复位端口(同步/异步)。&lt;/p&gt;
&lt;p&gt;reset distribution tree 和 clock distribution tree 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree" src="/images/the-art-of-reset-design-in-fpga/reset_tree.png" /&gt;&lt;/p&gt;
&lt;p&gt;系统中的主复位信号经过 reset distribution tree 达到每个元件，实现复位。&lt;code&gt;reset distribution tree&lt;/code&gt; 和 &lt;code&gt;clock distribution tree&lt;/code&gt; 最大的区别就是它们对 &lt;code&gt;skew&lt;/code&gt; 的要求不同。由上面的讨论可知，复位信号和时钟的关系最好是“同步释放”，不像时钟信号的要求那么严格，复位信号之间的 skew 不需要那么严格，只要复位信号的延迟足够小，满足能在一个时钟周期内到达所有的复位负载端，并且满足各个 reg 和 flip-flop 的 &lt;code&gt;recovery time&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3&gt;in ASIC&lt;/h3&gt;
&lt;p&gt;在 ASIC 设计中，两种 tree 的关系有以下两种方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;驱动 reset tree 最安全的方法就是使用 clock tree 的叶子结点的时钟信号来驱动，如下图所示。如果采用这种方法，时序分析是满足的，那么就没有问题。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_delayed_clock.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析以下情况：clock tree 中的一路叶子时钟信号驱动 &lt;code&gt;reset synchroinzer&lt;/code&gt;，得到的复位信号 masterrst_n 穿过 reset tree，输入到 DFF 的复位端口；clock tree 的另外一路叶子时钟信号直接连接 DFF 的时钟端。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;理想情况下（时钟速率不高），reset 支路即使经过 reset synchronizer 和 reset tree，仍然满足 slack 为正，满足时序，电路可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，在大多数情况下，时钟信号的频率都比较高，这些操作产生的延时太大，无法在一个时钟周期内完成，导致 slack 为负，此时无法满足时序要求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了加速 reset 信号到达系统内的 DFF，使用进入 clock tree 之前的时钟信号来驱动 reset synchronizer，如图所示。这时候 reset 和 clock 是异步的，所以必须在 &lt;code&gt;PAR&lt;/code&gt; 之后进行 &lt;code&gt;STA&lt;/code&gt;，以保证&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若系统使用异步复位方式，则经过 reset tree 的复位信号释放(release)满足 &lt;code&gt;恢复时间(recovery time)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若系统使用同步复位方式，则经过 reset tree 的复位信号满足&lt;code&gt;建立时间(setup time)&lt;/code&gt; 和 &lt;code&gt;保持时间(hold time)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，只有最后完成布局布线之后，才能根据具体情况进行分析调整 clock tree 和 reset tree。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_parallel_clock.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对于 synchronou/asynchronous 两种 tree，可以用两种技术来进行优化：&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;synchronous reset distribution tree&lt;/h4&gt;
&lt;p&gt;如下图所示，通过在 tree 中嵌入 DFF，这样 reset 信号就不必在一个时钟周期内到达每一个 DFF 的复位端口，从而可以把 reset 信号的时序要求降得很低。在每个模块中，输入的 reset 信号首先经过一个 DFF，然后把经过 DFF 延迟输出的复位信号用作复位信号来复位逻辑、驱动子模块。每个 module 里面都含有以下代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronous reset" src="/images/the-art-of-reset-design-in-fpga/synchronous_reset_distribution.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;input&lt;/span&gt;    &lt;span class="n"&gt;reset_raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// synchronous reset&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;reset&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;reset_raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;reset_raw 是本模块的输入复位信号，reset 为经过 DFF 后的本地（local）复位信号，同时也连接子模块 reset_raw 的输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantage&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;降低 reset 的时序要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低 reset 的扇出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利于时序工具分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要多个时钟周期才能复位&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;asynchronous reset distribution tree&lt;/h4&gt;
&lt;p&gt;和同步复位类似，异步复位也可以采用相同的策略，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="asynchronous reset" src="/images/the-art-of-reset-design-in-fpga/asynchronous_reset_distribution.png" /&gt;&lt;/p&gt;
&lt;p&gt;利用前面讨论过的 reset synchronizer 将异步复位信号同步到每个子模块当中。&lt;/p&gt;
&lt;p&gt;和 synchronous reset 一样，在 reset tree 中加入 synchronizer 之后，复位功能需要多个时钟周期才能完成。&lt;/p&gt;
&lt;h4&gt;Problem&lt;/h4&gt;
&lt;p&gt;因为不同的子模块深度不同，所以不同模块可能不是同时复位的（同一个时钟周期）。这种情况是否会引起问题，依应用情况而定，大多数设计都没有问题，但是如果要求一定要在同一时钟周期复位，那么就要平衡不同子模块内的 synchronizer 数量，无论是 synchronous 还是 asynchronous 都是一样的。&lt;/p&gt;
&lt;h4&gt;Advantage&lt;/h4&gt;
&lt;p&gt;前面讨论的 reset tree 和 clock tree 主要问题就是两者是异步的，一定要保证 reset 的释放满足 recovery time，在 P&amp;amp;R 之后，时序分析如果不满足的话，设计者需要手动调整时序，然后重新 P&amp;amp;R，时序分析直到满足为止。&lt;/p&gt;
&lt;p&gt;作为对比，如果采用这里插入 synchronizer 的方法，则免去了手动调整的工作，让综合工具完成时序分析和调整工作。经过调整之后，全局（global）复位信号就变为本地（local）复位信号了。（synchronous 也一样，变为 local reset）&lt;/p&gt;
&lt;h3&gt;in FPGA&lt;/h3&gt;
&lt;p&gt;对于 FPGA，因为系统的 clock tree 是预先布线好的，而全局主复位信号一般也使用时钟布线资源，所以不存在两棵 tree 之间关系的调整问题，所以只需要采用上面的 synchronou/asynchronous reset distribution tree 即可。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Multi-clock Reset&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在一个系统中，往往有多个时钟，这时候有必要为每个时钟域分配一个复位信号。&lt;/p&gt;
&lt;p&gt;因为只有一个全局复位的话，它与系统的时钟都没有关系，是异步复位信号，要求这个信号满足所有时钟域的 recovery 和 removal 时序不是一件容易的事情，因此为每个时钟域分配复位是有必要的。&lt;/p&gt;
&lt;p&gt;根据实际情况的不同，有两种方案可以采用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-coordinated reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于多时钟域的设计，很多时候不同时钟域之间复位信号的先后顺序没有要求，尤其是在有 &lt;code&gt;request-acknowledge&lt;/code&gt; 这样握手信号的系统中，不会引起硬件上的错误操作，这时候下图所示的方法就足够了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="non coordinated reset" src="/images/the-art-of-reset-design-in-fpga/non_coordination.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequenced coordination of reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些设计，要求复位信号的释放顺序有一定顺序，这时候应该使用下图所示的方法&lt;/p&gt;
&lt;p&gt;&lt;img alt="sequenced rcoordination" src="/images/the-art-of-reset-design-in-fpga/sequenced_coordination.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 在文中提供了一张图来说明典型的系统复位方案，图中 &lt;code&gt;MMCM&lt;/code&gt; 的 &lt;code&gt;lock&lt;/code&gt; 和外部输入的复位信号相与，目的是为了保证提供给后面的同步器的时钟信号是稳定的；每个时钟域都有一个同步器来同步复位信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="typical reset implementation in FPGA" src="/images/the-art-of-reset-design-in-fpga/typical_reset.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reset Glitch Filtering&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;最后讨论一下复位信号毛刺的问题。&lt;/p&gt;
&lt;p&gt;使用异步复位信号时，考虑到异步复位信号对毛次比较敏感，所以在一些系统中需要处理毛次，下图显示了一种简单但是比较丑陋的方法(时延不是固定的，会随温度、电压变化)&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset glitch filtering" src="/images/the-art-of-reset-design-in-fpga/reset_glitch_filtering.png" /&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;毛刺 Glitch&lt;/code&gt; 是一个很重要的问题，不论是对于时钟、复位信号还是其他信号，详细讨论待续&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不是所有的系统都需要过滤毛刺，设计者要先研究需求，再觉得是否使用延时来过滤毛次&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;本文是读书笔记，总结了参考资料中的复位信号的设计方法和需要注意的问题，包含了底层的 DFF 复位方式、高/低电平有效、同步/异步复位、和系统级的复位方案选择、设计。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应该参考器件决定使用那种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Xilinx 器件，应该使用高电平复位方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用同步复位，保持设计 “同步化”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了(CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无优点的。Xilinx 就是个例子，它所有的芯片都带有同步/异步复位端口)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不带有同步复位端口，那么就需要使用这种异步复位同步化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用 synchronou/asynchronous reset distribution tree 可以降低 reset 信号的时序要求，减小扇出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个时钟域都应该有一个同步器来同步复位信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_Resets.pdf"&gt;Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2003Boston_Resets.pdf"&gt;Asynchronous &amp;amp; Synchronous Reset Design Techniques - Part Deux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I rest my FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/coyoo/blog/13-12/301045_9c39f.html"&gt;FPGA复位电路的实现及其时序分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://item.jd.com/11337565.html"&gt;100 Power Tips for FPGA Designers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379"&gt;Advanced FPGA Design by Steve Kilts&lt;/a&gt;&lt;/p&gt;</summary><category term="reset"></category></entry><entry><title>学习 Arduino #3 Intel Galileo Linux</title><link href="http://guqian110.github.io/pages/2014/06/13/learning_arduino_series_3_intel_galileo_linux.html" rel="alternate"></link><updated>2014-06-13T20:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-06-13:pages/2014/06/13/learning_arduino_series_3_intel_galileo_linux.html</id><summary type="html">&lt;h2&gt;Linux on Galileo Board&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Galileo 不是简单的 Arduino 板子，实际上它运行着一个 Linux 操作系统。把它看作是 “兼容 Arduibo 接口的板子” 或许更合适一些。&lt;/p&gt;
&lt;p&gt;Galileo 板子上容量为 8 MB 的 SPI Flash 中已经烧写了一个精简版的 Linux 系统，因为容量的限制，这个系统去掉了一些不常用的模块，比如 wi-fi 驱动，python 支持等。&lt;/p&gt;
&lt;p&gt;Galileo 也支持从 SD 卡启动系统，并且 Intel 提供了一个基于 Yocto 项目，已经制作好的完整版 Linux 系统。当精简版系统不能满足我们的要求时（添加外设等），我们可以下载这个完整版系统镜像，烧录到 SD 卡中，并从 SD 卡中启动即可。（也可以自己基于 Yocto 项目按照自己的需求制作系统镜像）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们并不仅仅满足于通过 Arduino IDE 对 Galileo 进行操作，放着一个操作系统，为什么不去使用呢：-P 那么怎么才能登录到这个 Linux 系统中呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Using Ethernet&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Intel 论坛的一个帖子列举了几种登录到 Galileo Linux 的方法&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/thread/46335"&gt;Connecting to Galileo via Linux Console&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the UART connector&lt;/li&gt;
&lt;li&gt;Use the LAN connection direct to your PC&lt;/li&gt;
&lt;li&gt;Use the LAN connection and connect to your local network &lt;/li&gt;
&lt;li&gt;You can also connect using WiFi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑到我们目前有的材料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Galileo 开发板&lt;/li&gt;
&lt;li&gt;Galileo 电源&lt;/li&gt;
&lt;li&gt;micro USB 线&lt;/li&gt;
&lt;li&gt;5 类网线&lt;/li&gt;
&lt;li&gt;运行着 Linux (Ubuntu) 的 PC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为没有串口线，所以我们采用第 2 种方案，即直接连接 PC 和 Galileo，通过 Ethernet 登录。&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;Galileo 默认是不开启 &lt;code&gt;Lan&lt;/code&gt; 的，也不开启 &lt;code&gt;Telnet&lt;/code&gt; 服务，所以我们需要做的事就是写一个 &lt;code&gt;sketch&lt;/code&gt;，启动 Lan 连接服务和 Telnet 服务，然后分别给 PC 和 Galileo 一个属于同一子网的静态 IP 地址，这样就可以使用 PC 通过 Telnet 协议登录到 Galileo 上的 Linux 系统中。&lt;/p&gt;
&lt;h3&gt;Setp 1: Write sketch&lt;/h3&gt;
&lt;p&gt;代码需要完成的功能一共有 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开启 telnet 服务&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;telnetd -l /bin/sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 IP 地址&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将板子的以太网配置状态显示在 serial monitor 中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 &amp;gt; /dev/ttyACM0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全部代码如下&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// put your setup code here, to run once:&lt;/span&gt;
  &lt;span class="c1"&gt;// Initial serial prot&lt;/span&gt;
  &lt;span class="n"&gt;Serial&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9600&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// Start telnet service on board&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;telnetd -l /bin/sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// Assign the IP address &amp;#39;169.254.1.1&amp;#39; to it&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// put your main code here, to run repeatedly: &lt;/span&gt;
  &lt;span class="c1"&gt;// Show the IP detial in the serial monitor of IDE&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 &amp;amp;&amp;gt; /dev/ttyGS0 &amp;amp;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Step 2: Connect，Upload&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网线直连 PC 和 Galileo，设置 PC 的 IP 地址为 &lt;code&gt;link-local only&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_config" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_ethernet_config.png" /&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给 Galileo 供电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接 USB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 Arduino IDE，&lt;code&gt;Upload&lt;/code&gt; 上面的 sketch&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Step 3: Login&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开 IDE 的 serial monitor，可以看到 Galileo 的 ethernet 配置信息&lt;/p&gt;
&lt;p&gt;&lt;img alt="galileo_ethernet_quary" src="/images/learning-arduino-series-3-intel-galileo-linux/galileo_ethernet_quary.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 PC 的网络配置&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ifconfig&lt;/span&gt; &lt;span class="n"&gt;eth0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;查询结果&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_quary" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_ethernet_quary.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 PC 的终端 Terminal，使用 telnet 登录&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;telnet&lt;/span&gt; &lt;span class="mf"&gt;169.254.1.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;登录结果，如图&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_login" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_telnet_login.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这个精简版的 Linux 系统是不支持 Python 的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Using UART&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;About serial port&lt;/h3&gt;
&lt;p&gt;如果有串口线的话，我们也可以通过串口来登录，包括 SPI 和 SD 卡上的系统。&lt;/p&gt;
&lt;p&gt;关于串口线，说明一下。估计是为了节省板子的面积，Intel 在板子上设置的是音频接口(AV jack)，所以，这里需要额外的一个将音频接口转接为串口的器件。有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上网买一个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自己 DIY 一个&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果上网买的话，注意 Galileo 用的是 RS232 电平，不要买错成 TTL 电平的。如果是自己 DIY 的话，Intel Galileo Get Started 里面有介绍串口线的接法，他们的论坛上也有相关的讨论：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/message/208448#208448"&gt;UART cable pin-out&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pinouts.ru/SerialPorts/Serial9_pinout.shtml"&gt;RS 232 DE-9 port&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Linux Platform&lt;/h3&gt;
&lt;p&gt;我在 Ubuntu 下使用的终端软件是 &lt;code&gt;gtkterm&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;Step 1: Burn the full-linux sytem&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Intel 官网提供的完整版 Linux 镜像是基于 &lt;code&gt;Yocto&lt;/code&gt; 项目裁剪出来的，取名叫 &lt;code&gt;Claton&lt;/code&gt;，目前(2014-6-13)的版本号为 &lt;code&gt;1.0.0&lt;/code&gt;，但是这个版本在我的SD卡中是无法启动的，浪费了大量时间，最后终于发现 &lt;code&gt;0.7.5&lt;/code&gt; 版本可以...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有就是 Get Started 中推荐不要使用 PC 操作系统提供的格式化功能，更好的选择应该是专业格式化软件，比如 &lt;code&gt;SDFormatter&lt;/code&gt;。但是我实际使用时，发现反而是 &lt;code&gt;SDFormatter&lt;/code&gt; 制作的不能启动...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Step 2: Connect&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入 SD 卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置串口&lt;/p&gt;
&lt;p&gt;选择正确的端口（因为我使用的串口线是 &lt;code&gt;AV-RS232-USB&lt;/code&gt;，所以下面选择的端口是 &lt;code&gt;ttyUSB0&lt;/code&gt;）；&lt;code&gt;Baud Rate = 115200&lt;/code&gt;，&lt;code&gt;Bits =8&lt;/code&gt;，&lt;code&gt;Stopbits = 1&lt;/code&gt;，&lt;code&gt;Parity = none&lt;/code&gt;，&lt;code&gt;Flow control = none&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先不要接 USB 下载线，给板子上电&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Step 3: Login&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这时候我们应该就可以从串口看到板子上电后 &lt;code&gt;grub&lt;/code&gt; 程序和系统启动的相关信息了。&lt;/p&gt;
&lt;p&gt;上电后，&lt;code&gt;grub&lt;/code&gt; 引导启动哪个系统&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm boot information" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_boot_information.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm grub" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_grub.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 SPI Flash 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，这个精简版的系统不支持 &lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_login_spi.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 mirco-SD card 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，SD 卡中的系统是支持 &lt;code&gt;python&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_login_sd_card.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Windows Platform&lt;/h3&gt;
&lt;p&gt;我在 Windows 下使用的终端软件是 &lt;code&gt;Putty&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;Step 1: Burn the full-linux system&lt;/h4&gt;
&lt;p&gt;与 Linux 平台下相同。&lt;/p&gt;
&lt;h4&gt;Step 2: Connect&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入 SD 卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置串口&lt;/p&gt;
&lt;p&gt;同样，选择正确的端口和波特率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先不要接 USB 下载线，给板子上电&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Step 3: Login&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这时候我们应该就可以从串口看到板子上电后 &lt;code&gt;grub&lt;/code&gt; 程序和系统启动的相关信息了。&lt;/p&gt;
&lt;p&gt;上电后，&lt;code&gt;grub&lt;/code&gt; 引导启动哪个系统&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm boot information" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_boot_information.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm grub" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_grub.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 SPI Flash 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，这个精简版的系统不支持 &lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_login_spi.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 mirco-SD card 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，SD 卡中的系统是支持 &lt;code&gt;python&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_login_sd_card.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Another method&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;如果你觉得插网线、配置 IP 地址太麻烦，甚至懒得自己 DIY 串口线，也没有钱去买一个，别担心，因为 “天空飘来五个字，这都不是事～” 因为你可以借鉴下面这位大神的方法，只需要像下载普通 sketch 一样，将他提供的 sketch 下载到 Galileo 中就可以了，然后通过 IDE 的 serial monitor 就可以登录到 Linux 系统中：&lt;/p&gt;
&lt;p&gt;&lt;a href="(https://communities.intel.com/message/222211)"&gt;Poor man's telnet for Galileo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他的 sketch 的原理就是使用 &lt;code&gt;system()&lt;/code&gt; 函数将我们在 serial monitor 中的命令传到到 Linux shell 中 ，并将命令的结果返回到 serial monitor 中 。&lt;/p&gt;
&lt;p&gt;不过这种方法的缺点是每个命令传递到 Galileo 后会开辟一个新的进程，当命令执行完返回结果时，这个进程自动结束，所以会产生一些 “问题”：当我们 &lt;code&gt;cd&lt;/code&gt; 到某个子目录后，返回结果之后，我们又回到的之前的目录，举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;home&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;pwd&lt;/span&gt;

&lt;span class="c1"&gt;// result is root dirctory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;解决方法就是将命令写在一行&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pwd&lt;/span&gt;

&lt;span class="c1"&gt;// result is home directory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/thread/46335"&gt;Connecting to Galileo via Linux Console&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/docs/DOC-22293"&gt;Tutorial 3: Connecting to Linux through telnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/message/208564#208564"&gt;Using Galileo Linux over Ethernet(Telnet)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="(https://communities.intel.com/message/222211)"&gt;Poor man's telnet for Galileo&lt;/a&gt;&lt;/p&gt;</summary><category term="Arduino"></category><category term="Linux"></category></entry><entry><title>有限状态机设计</title><link href="http://guqian110.github.io/pages/2014/06/05/fsm_design.html" rel="alternate"></link><updated>2014-06-05T17:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-06-05:pages/2014/06/05/fsm_design.html</id><summary type="html">&lt;p&gt;有限状态机是数字电路中经常出现、非常重要的电路，设计一个安全、高效的状态机有一套程序化的方法，我们在数字电路课中就学习过了。搬运以前写的博客，总结一下相关知识，温故而知新～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面的废话：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇博客是在我以前在 CSDN 上写的两篇博客的基础上，参考了其他各位大神、博主的文章，写的总结。欢迎批评、讨论，毕竟写博客的意义就在于给自己一个总结知识的机会、并且在和别人讨论的过程中进步 :-D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;What is FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Finite-state_machine"&gt;FSM on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有限状态机 (Finite State Machine, FSM)&lt;/strong&gt; 有时候也简称为&lt;strong&gt;状态机 (state machine)&lt;/strong&gt;，它是一种数学模型，通常用来设计电脑程序或者时序电路。它被构思设计为一个抽象的机器，并且某个时刻只能处于一个有限数字代表的状态之下。&lt;/p&gt;
&lt;p&gt;有限状态自动机在很多不同领域中是重要的，包括电子工程、语言学、计算机科学、哲学、生物学、数学和逻辑学。有限状态机是在自动机理论和计算理论中研究的一类自动机。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。(这里讨论的只限于电子工程里的状态机)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组成元素：&lt;/strong&gt;输入、状态、状态转移条件、输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态转移图&lt;/li&gt;
&lt;li&gt;状态转移表&lt;/li&gt;
&lt;li&gt;HDL 描述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照输出的产生方式，可以将状态机分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Moore_machine"&gt;Moore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="moore diagram" src="/images/fsm-design/moore.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a href="http://homepages.ius.edu/JFDOYLE/c421/html/Chapter8.htm"&gt;图片来源&lt;/a&gt;，homepages.ius.edu)&lt;/p&gt;
&lt;p&gt;一种状态机，它的输出只取决于当前状态，而与输入无关。Moore 状态机最重要的特点就是将输入与输出信号隔离开来，而且输出与时钟信号同步的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Mealy_machine"&gt;Mealy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mealy diagram" src="/images/fsm-design/mealy.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a href="http://homepages.ius.edu/JFDOYLE/c421/html/Chapter8.htm"&gt;图片来源&lt;/a&gt;，homepages.ius.edu)&lt;/p&gt;
&lt;p&gt;另外一种状态机，它的输出不仅和当前状态有关，而且和输入也有关。Mealy 有限状态机对输入的响应发生在当前时钟周期，比 Moore 有限状态机对输入信号的响应要早一个周期。因此，输入信号的噪声可能影响在输出的信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;How to Design a FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;关于如何设计一个状态机，这在数字电路和逻辑设计的书里有详细介绍。简单地总结一下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑抽象，建立原始状态转移图：确定输入、输出、状态变量、画状态转移图&lt;/li&gt;
&lt;li&gt;状态简化，得到最简的状态转移图(卡诺图)&lt;/li&gt;
&lt;li&gt;状态分配，选择编码方案(Binary、Gray、One-Hot)&lt;/li&gt;
&lt;li&gt;画逻辑图，检查能否自启动，得到了最终的状态机模型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;How to implement a FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;当设计好之后，就要使用 HDL 语言来实现这个 FSM 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言：&lt;/strong&gt; Verilog HDL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合工具：&lt;/strong&gt; XST (Xilinx Synthesis Tools)&lt;/p&gt;
&lt;p&gt;下面讨论了一些 FSM 实现时需要注意的问题&lt;/p&gt;
&lt;h3&gt;Coding Style&lt;/h3&gt;
&lt;p&gt;状态机一般有三种写法，他们在速度、面积、代码可维护性等各个方面互有优劣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一段式：&lt;/strong&gt;只有一个always block，把所有的逻辑（输入、输出、状态）都在一个always block中实现；这种写法 &lt;em&gt;看起来很简洁&lt;/em&gt;，但是 &lt;em&gt;不利于维护&lt;/em&gt;。如果状态复杂一些就很容易出错。不推荐这种方法，但是在简单的状态机可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二段式：&lt;/strong&gt;有两个always block，把时序逻辑和组合逻辑分隔开来。时序逻辑里进行当前状态和下一状态的切换，组合逻辑实现各个输入、输出以及状态判断。这种写法 &lt;em&gt;不仅便于阅读、理解、维护，而且利于综合器优化代码，利于用户添加合适的时序约束条件，利于布局布线器实现设计。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在两段式描述中，当前状态的输出用组合逻辑实现，可能存在竞争和冒险，产生毛刺。则要求对状态机的输出用寄存器打一拍，但很多情况不允许插入寄存器节拍，此时使用三段式描述。其优势在于能够根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而不需要额外插入时钟节拍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三段式：&lt;/strong&gt;有三个always block，一个时序逻辑采用同步时序的方式描述状态转移，一个采用组合逻辑的方式判断状态转移条件、描述状态转移规律，第三个模块使用同步时序的方式描述每个状态的输出。&lt;em&gt;代码容易维护，时序逻辑的输出解决了两段式组合逻辑的毛刺问题&lt;/em&gt;，但是从资源消耗的角度上看，&lt;em&gt;三段式的资源消耗多一些，且输出比另外两种会延时一个时钟周期。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;三段式代码模板&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="no"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&amp;#39;b0000&lt;/span&gt;&lt;span class="n"&gt;_0001&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="no"&gt;WAIT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&amp;#39;b0000&lt;/span&gt;&lt;span class="n"&gt;_0010&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="no"&gt;STRT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&amp;#39;b0000&lt;/span&gt;&lt;span class="n"&gt;_0100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;//初始化寄存器，避免生成latch&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
       &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 注意&lt;/span&gt;
       &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// ...          //初始化一组值，避免latch&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;           &lt;span class="c1"&gt;//注意为NS&lt;/span&gt;
            &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;endcase&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;一段 or 三段？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，三段式的效果更好，唯一的缺点是占用的资源稍微多一点(对于拥有丰富的触发器资源的 FPGA 来说，这个缺点可以忽略吧)。所以除非是非常简单的状态机用一段式实现，其他情况下三段式更简单。&lt;/p&gt;
&lt;p&gt;对于上面的三段式模板，按代码顺序解释一下相关的注意事项&lt;/p&gt;
&lt;h3&gt;参数使用 parameter&lt;/h3&gt;
&lt;p&gt;尽量使用 &lt;code&gt;parameter&lt;/code&gt; 而不是 &lt;code&gt;define&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个原则不仅仅限于 FSM，其他模块也应该遵守。因为使用 &lt;code&gt;define&lt;/code&gt; 定义的参数是全局变量，而 &lt;code&gt;parameter&lt;/code&gt; 定义的是局部变量。如果设计中包含多个 FSM，包含多个同名的变量，显然使用 &lt;code&gt;parameter&lt;/code&gt; 是更好的选择。&lt;/p&gt;
&lt;h3&gt;FSM 复位&lt;/h3&gt;
&lt;p&gt;FPGA 上电时，GSR(Global Set/Reset) 拉高，对所有 寄存器/RAM 进行复位，此时配置于 FPGA 的逻辑并未生效，所以不能保证 FSM 进入正确的初始化状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般，FSM 使用其他的复位(同步 or 异步)。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Synchronous Reset&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一种方法，是将初始状态编码为全 0 (带 0 的 One-Hot 编码方式)，这样当 GSR 复位后，状态机自动进入初始状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;编码方式&lt;/h3&gt;
&lt;p&gt;状态机的状态的编码，通常有 &lt;code&gt;Binary&lt;/code&gt;、&lt;code&gt;One-Hot&lt;/code&gt;、&lt;code&gt;Gray&lt;/code&gt; 码等几种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binary 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用最简单的递增的编码方式对状态进行编码，对于 n 个状态的状态机，共需要 log2(n) 个触发器表示所有的状态。&lt;/p&gt;
&lt;p&gt;优点：在状态很多的情况下，可以大大减少触发器的数量，对设计的面积有积极的作用。&lt;/p&gt;
&lt;p&gt;缺点：但是在状态跳转过程中，很可能出现多位同时变化的情况，容易在 next state 的生成逻辑上产生毛刺。同时，输出也是所有状态位的译码，译码逻辑多数很复杂，往往成为整个设计的关键路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gray 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似 Binary，但是采用了格雷码的编码方式，每两个相邻的状态只有一位信号变化。&lt;/p&gt;
&lt;p&gt;有点：避免了 next state 上毛刺的产生。同时两个相邻状态的输出译码变得简单了，避免了复杂组合逻辑的产生。&lt;/p&gt;
&lt;p&gt;缺点；格雷码的这些优点都是建立在状态跳转是顺序执行的基础上的。如果状态机有很多随机跳转和分支，格雷码的实际效果和二进制码相差无几，优势荡然无存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;One-Hot 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前设计中最常用的状态机编码方式。One-Hot 编码在一组 0 中只有一个 1，对一个 n 个状态的 FSM 设计，需要 n 个触发器。&lt;/p&gt;
&lt;p&gt;优点：在任意两个状态之间跳转都只有两位状态位变化，不会产生非常复杂的组合逻辑。各个状态之间的译码也相对简单。&lt;/p&gt;
&lt;p&gt;缺点：对状态编码需要的寄存器比其他方式多，不过这个缺点基本可以忽略吧 :-P&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Binary、Gray 编码使用最少的触发器，较多的组合逻辑。而 One-Hot  编码反之。由于 CPLD 更多的提供组合逻辑资源，而 FPGA 更多的提供触发器资源，所以 CPLD 多使用 Gray，而 FPGA  多使用 One-Hot 编码。另一方面，对于小型设计使用 Gray 和 Binary 编码更有效，而大型状态机使用 One-Hot 更高效。&lt;/p&gt;
&lt;p&gt;(XST 的选项 &lt;code&gt;FSM encoding algorithm&lt;/code&gt; 值默认为 &lt;code&gt;auto&lt;/code&gt;，编写程序测试发现，它会根据代码中状态的多少，FSM 的复杂度，自动选择合适的编码方式对状态进行编码。)&lt;/p&gt;
&lt;h3&gt;安全的 FSM&lt;/h3&gt;
&lt;p&gt;所谓 “安全” 的状态机，就是说即使因为某些意外原因，状态机跑飞了，仍然可以自动回复到正常状态。&lt;/p&gt;
&lt;p&gt;如果我们对状态向量的所有取值情况都显式地进行了说明，那么这个状态机就是安全的，否则就是不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可能出现的不安全情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，我们在 One-Hot 方式中，对于 8 个状态，总共使用了 8 bit 的寄存器，那么这个状态寄存器向量可以取到的值一共有 &lt;code&gt;2^8 = 256&lt;/code&gt; 种。如果我们只对需要的 8 种状态进行了说明，而忽略了剩余的 248 种，此时综合工具(Synplify、XST)会对设计进行 “优化”，将没有用到的状态去掉。但是，有时候这种 “优化” 反而不好，如果状态机进入未定义的全 0 状态，那么它就会卡在这个未定义的状态，无法自动回复正常工作状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;书写完备的 &lt;code&gt;case&lt;/code&gt; 语句。在代码中对每一种可能的取值对进行描述，对于不使用的状态编码，一定要有 &lt;code&gt;default&lt;/code&gt; 分支进行说明。&lt;/p&gt;
&lt;p&gt;在第二段 &lt;code&gt;always&lt;/code&gt; 中，&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
    &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这里应该赋值 &lt;code&gt;8'bx&lt;/code&gt; 更合理，因为状态机上电时处于未知状态，所以应该赋值 &lt;code&gt;x&lt;/code&gt; 更符合实际，但是这样赋值必须有个条件，就是必须所有的状态编码都全部被使用了，不然就会出现锁死现象，FSM 无法返回工作状态。我们前面使用的是 One-Hot 编码方式，有大量无效状态，所以这里不能赋值为 &lt;code&gt;x&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XST支持状态机编码的完备属性 —— &lt;code&gt;case implementation style&lt;/code&gt;，虽然可以打开这个设置，但是一般我们应该在代码中满足条件，而不是依靠综合工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使使用第一种方法，似乎我们的状态机已经是 perfect 了，但是真的是这样么？考虑这种情况：一个状态机有 8 个状态，采用 One-Hot 编码方式，代码含有 &lt;code&gt;default&lt;/code&gt; 分支处理未定义的状态向量可能取到的值。现在把这个状态机放在卫星中，接受宇宙射线的辐射，导致状态向量的值发生了变化，进入了无效状态，然后状态机自动恢复到正常状态(Good Job)，但是！状态机的外围电路并没有随着状态机恢复，它还在等 FSM 输出某个信号呢。所以，仅仅是回到正常状态并不够，最好的设计应该有个错误状态专门来与外围电路通信，当 FSM 自动恢复时，它会通知外围电路 reset 。&lt;/p&gt;
&lt;p&gt;(XST 的选项 &lt;code&gt;safe implementation&lt;/code&gt; 值默认为 &lt;code&gt;None&lt;/code&gt;，如果应用环境要求 FSM 必须能恢复任何错误，比如航天、医疗、汽车等，这时我们可以打开这个设置，这时综合工具会添加额外的逻辑，保证 FSM 可以从无效状态恢复过来。)&lt;/p&gt;
&lt;h3&gt;检查状态完备性&lt;/h3&gt;
&lt;p&gt;在第二个 &lt;code&gt;always block&lt;/code&gt; 中，第一句是&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这是个很有用的小技巧，它可以帮助我们在综合前发现状态是否完备：如果状态完备，则在下面的 &lt;code&gt;case&lt;/code&gt; 中会给 &lt;code&gt;NS&lt;/code&gt; 合适的值；如果状态不完备，则状态机会进入错误状态，输出不定，仿真时可以很快的发现。而且，综合工具对于 &lt;code&gt;x&lt;/code&gt; 采取的态度是 &lt;code&gt;don't care&lt;/code&gt;，综合时会自动将其忽略，生成的电路最简洁。&lt;/p&gt;
&lt;h3&gt;避免 Latch&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在第三个 &lt;code&gt;always&lt;/code&gt; 中，在 &lt;code&gt;case&lt;/code&gt; 前，所有的输出都有默认的值，这样做的好处是可以消除 &lt;code&gt;Latch&lt;/code&gt; 的出现，而且，可以减少在后面每种状态下重复相同的赋值，而且强调显示了 case 内哪个输出发生了变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;书写完备的 &lt;code&gt;if-else&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; 语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;消除输出毛刺&lt;/h3&gt;
&lt;p&gt;对于三段式，因为输出是寄存器输出，所以解决了输出毛次。&lt;/p&gt;
&lt;p&gt;讨论一下采用寄存器输出的方式对设计的影响&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动可以优化 FSM 的时序性能&lt;/p&gt;
&lt;p&gt;影响一个时序电路运行速度的主要因素是两个寄存器之间的组合逻辑路径的长度，越长的组合逻辑路径，其时序性能越差。一个电路中的最长组合逻辑路径决定了这个电路最高运行速率，该路径就是这个电路的关键路径（&lt;code&gt;critical path&lt;/code&gt;）。所以，切断最长的组合逻辑路径可以提高局部电路的运行速度，切断多个较长的组合逻辑路径可以提高整体电路的运行速度。切断组合逻辑路径的工具就是寄存器。所以，添加寄存器可以提高电路的性能，但是会增加资源的消耗，这也是速度（speed）和面积（area）互为矛盾的原因。&lt;/p&gt;
&lt;p&gt;在考虑FSM的时序问题时，不能独立的考虑FSM本身，需要综合考虑FSM模块和下游模块构成的电路。在FSM不采用输出寄存时，在FSM模块和下游模块的接口处，是两部分组合逻辑直接相连。关键路径由两部分组合逻辑构成；在FSM采用输出寄存时，两个模块的组合逻辑被分隔成两部分，可能的关键路径被切断了。同步寄存器输出和组合逻辑输出就是采用资源优化还是速度优化的问题。组合逻辑表面上会提高电路的速度，看似节省了资源而且提高了速度，其实不然（对FPGA结构来说，节省寄存器不等于节省LE；对同步设计来说，异步输出速度上的优势是可以忽略的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动会降低输出队输入信号变化的响应速度？&lt;/p&gt;
&lt;p&gt;到底应不应该采用FSM输出寄存器？是否必须在时序性能和响应速度之间做出取舍？在同步设计中，答案是必须牺牲一定的响应速度以换取更佳的时序性能，只考虑响应速度会带来潜在的时序性能损失。&lt;/p&gt;
&lt;p&gt;在考虑FSM的响应速度时，不能独立的考虑FSM本身，需要综合考虑FSM模块和上、下游模块构成的电路。采用输出寄存器的电路可以运行在更高的时钟频率下，所引入的响应时延与更高的运行频率相比是可以牺牲的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;case (NS) vs case (CS)&lt;/h3&gt;
&lt;p&gt;采用二段式实现状态机，它的输出是组合逻辑，可能存在竞争和冒险，产生毛刺，要消除毛刺就要对输出用寄存器打一拍，但是很多时候，是不允许插入寄存器节拍的。&lt;/p&gt;
&lt;p&gt;这时候可以采用三段式实现，三段式的输出是寄存器输出，所以消除了毛次；同时，如果三段式的第三段判断输出采用&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// ....&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就可以提前判断下一状态的输出，节省了一个节拍，使输出和状态变化同步。&lt;/p&gt;
&lt;p&gt;设计一个简单的 FSM，测试使用 &lt;code&gt;case(CS)&lt;/code&gt; 和 &lt;code&gt;case(NS)&lt;/code&gt; 的结果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FSM 设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一共有 4 个状态(IDLE、S1、S2、S3)，只有一个输入(&lt;code&gt;jump&lt;/code&gt; 信号)，两个输出(&lt;code&gt;dout_p&lt;/code&gt;、&lt;code&gt;dout_q&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳转规律&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态机开始处于 IDLE 状态，当 jump 变高时，从 IDLE 跳转到 S1 状态，同时内部的一个 4 bit 计数器开始计数，当计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 S2，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时跳转到 S3，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 IDLE，等待 jump 再次变高。状态转移图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/diagram.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态机源文件&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/fsm.v"&gt;fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试平台 testbench&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tb_fsm.v"&gt;tb_fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;NS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出同时改变。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_ns.png" /&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;CS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出变化相对于状态变化延时一个时钟周期。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_cs.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1998SJ_FSM.pdf"&gt;Clifford E. Cumming     State Machine Coding Styles for Synthesis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsICU2002_FSMFundamentals.pdf"&gt;Clifford E. Cumming     The Fundamentals of Efficient Synthesizable Finite State Machine
Design using NC-Verilog and BuildGates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.trilobyte.com/pdf/golson_snug94.pdf"&gt;Steve Golson                State machine design techniques for Verilog and VHDL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/freeny/archive/2012/04/14/2447612.html"&gt;Verilog HDL学习心得&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;foreveryoung 《状态机设计》&lt;/p&gt;
&lt;p&gt;云创工作室     《Verilog HDL程序设计与实践》&lt;/p&gt;</summary><category term="FSM"></category><category term="Verilog"></category></entry><entry><title>学习 Arduino #2 初识 Intel Galileo 开发板</title><link href="http://guqian110.github.io/pages/2014/05/29/learing_arduino_series_2_intel_galileo_development_board.html" rel="alternate"></link><updated>2014-05-29T23:27:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-29:pages/2014/05/29/learing_arduino_series_2_intel_galileo_development_board.html</id><summary type="html">&lt;h2&gt;Preface&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Arduino 有很多开发板，分别针对不同的应用环境含有不同的模块。学习一款 Intel 推出的开发板 —— &lt;em&gt;Intel Galileo Development Board&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;Intel Gailileo Development Board 是 Intel 进入 Arduino 领域的试水产品，它含有一颗 Quark Soc X1000 CPU，这是一款 32 位、x86 构架、低功耗的 SoC 芯片，它的主频可以达到 400 MHz，内部有 512 KB 的 SRAM，同时 Galileo 有丰富的接口(USB, JTag, RS232, Ethernet, mPCIE...)，支持很多外围设备。&lt;/p&gt;
&lt;p&gt;Galileo 试图达到的目标是融合 Arduino 对硬件操作的便利和 Linux 系统对硬件操作完整支持。所以，Galileo 也兼容 Arduino 接口，你可以很方便的把 Arduino 项目移植到 Galileo 上运行，使用常用的一些 Arduino 库(Ethernet, Wi-Fi, SD, EEPROM...)也可以获得内部 Linux 系统的完整功能(Python, SSH, Telnet， OpenCV...)。&lt;/p&gt;
&lt;p&gt;总结一下我学习这块板子的知识，不仅仅为 Arduino 开发做准备，也为后面的一个竞赛(基于Yocto 项目)开发积累知识～&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Official Arduino Boards&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Arduino 官网上列出所有了官方开发板，其中也包含了官方认证过的开发板(Intel Galileo)，和一些推荐的第三方产品&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Main/Products"&gt;Arduino Products&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还详细列出了这些开发板上的微控制器的区别&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Products.Compare"&gt;Compare boards specs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;官方的开发板的核心都是 Atmel 的微控制器，基于市场战略的需求，看到数莓派、Arduino发展的热火朝天，Intel 也坐不住了(瞎猜的 =.=)，推出了新的基于 Intel 架构(x86)、可以和 Arduino 兼容的开发板。Galileo 是这个家族中的第一款，目前 Intel 又推出了一款新的开发板，取名叫 Edison。(Intel 这是要把所有科学家的名字都取个遍么)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Intel Galileo Board&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Arduinco.cc&lt;/h3&gt;
&lt;p&gt;在 Arduino 官网上有一篇简单介绍 Galileo 的网页&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/ArduinoCertified/IntelGalileo"&gt;Intel Galileo on arduino.cc&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Intel Official Introduction&lt;/h3&gt;
&lt;p&gt;Arduino 官网上的介绍只是非常简单的介绍，Intel 自己的官网上有关于 Galileo 全部的详细资料&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.intel.cn/content/www/cn/zh/do-it-yourself/galileo-maker-quark-board.html"&gt;Galileo Maker Quark Board&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于 Galileo 的全部文档，包括 Datasheet、Schematic、Quick Start、User Guide 等：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/community/makers/documentation/galileodocuments"&gt;Intel Galileo Development Board Documents&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Other Introductions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt; 送上一篇非常好的介绍文章（来自 Ifanr.com），介绍了在 Maker 眼中，这个板子到底可以 hack 到什么程度～&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ifanr.com/388835"&gt;x86 版的 Arduino 来了，Intel Galileo 开发板的体验、分析和应用【超长文多图】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再&lt;/strong&gt; 附上一篇完爆我的总结的教程～&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.sparkfun.com/tutorials/galileo-getting-started-guide"&gt;Galileo Getting Started Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇教程基本就是按照 Intel 官方的 Getting Started 流程写的，总结一下我遇到的问题 (Windows 7 &amp;amp; Linux Ubuntu)。&lt;/p&gt;
&lt;p&gt;Arduino 官方的 IDE 中 &lt;code&gt;Board&lt;/code&gt; 选项中没有 Galileo，所以我们应该从 Intel 下载定制过的 IDE。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows IDE 闪退&lt;/p&gt;
&lt;p&gt;这个 IDE 在部分 Windows 下有闪退的现象。&lt;/p&gt;
&lt;p&gt;原因 是 Intel 的 IDE 版本采用的是未发布的 1.5.3, 它会检测系统的语言设置，当系统不是 En/US 时，就会退出。&lt;/p&gt;
&lt;p&gt;解决方法 更改系统语言设置 或者 使用一款名为 Locale Emulator 的软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDE 解压路径&lt;/p&gt;
&lt;p&gt;Windows 下的解压路径 &lt;em&gt;必须是顶层目录&lt;/em&gt;，比如 &lt;code&gt;D:\arduino-1.5.3&lt;/code&gt;，否则在 &lt;code&gt;Verify&lt;/code&gt; 时会提示找不到特定的文件/目录。Linux 下无此问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 连接板子和 PC&lt;/p&gt;
&lt;p&gt;在 Windows 下第一次连接系统自动安装驱动肯定会失败的，需要我们手动指定驱动文件的路径。&lt;/p&gt;
&lt;p&gt;在 Linux 终端下，必须以 &lt;code&gt;sudo&lt;/code&gt; 权限运行 IDE，否则即使板子已经连接了 PC，在 IDE 下的 &lt;code&gt;Tools\Serial Port&lt;/code&gt; 是 disable 的，不能选择端口&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;arduino&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 下 disable modem manager&lt;/p&gt;
&lt;p&gt;前面的教程中提到，在大多数 Linux 发行版下，都需要 disable modem manager 才能 &lt;code&gt;Upload&lt;/code&gt; 成功，不过我在 Ubuntu 下没有遇到这个问题...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt; 扯几句&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;硬件配置&lt;/p&gt;
&lt;p&gt;从 Board Guide 中找到的截图如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="key_componets_1" src="/images/learning-arduino-series-2-intel-galileo-development-board/key_components_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="key_componets_2" src="/images/learning-arduino-series-2-intel-galileo-development-board/key_components_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;从它的配置中可以看到，Galileo 并不是一款简单的 Arduino 开发板，它的硬件系统其实是按照 PC 来设计的，如果我们只是简单的把它当作 Arduino 开发板来应用，有点大材小用了，这样子完全没有体现出 Galileo 的优势，只是一个速度更快的 Arduino 罢了。&lt;/p&gt;
&lt;p&gt;事实上，如果功能上没有比传统的 Arduino 更强大的功能，估计 Intel 也不会推出这个产品了～Galileo 的真正强大的地方在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;背后基于 UEFI/Linux 的软件平台以及 Galileo 自身的硬件配置。为此，Intel 提供了丰富的开发文档、软件代码支持，方便开发人员真正的发挥出 Galileo 的所有潜力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件构架&lt;/p&gt;
&lt;p&gt;Galileo 不仅仅是硬件上按照 PC 设计的，事实上，它的软件构架也和 PC 一样。和普通的单片机不同，它并不是简单的运行用户开发的程序那么简单。它实际上运行着一个操作系统 —— 包含 UEFI(BIOS 的替代者)、Grub、嵌入式 Linux 系统，用户编写的 &lt;code&gt;Sketch&lt;/code&gt; 只是一个在 Linux 上面运行的应用而已。&lt;/p&gt;
&lt;p&gt;Galileo 启动时可以从 ISP Flash 中启动一个微型的 Linux 系统，也可以从 MicroSD 卡中启动一个完整版的 Linux 系统。我们 &lt;code&gt;Upload&lt;/code&gt; 时，Arduino IDE 将程序编译链接成一个标准的 Linux ELF 文件，并且下载到 Arduino 板子上运行，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="target_software" src="/images/learning-arduino-series-2-intel-galileo-development-board/target_software.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发嵌入式 Linux 设备&lt;/p&gt;
&lt;p&gt;或许这才是 Galileo 的 "正经" 用途吧...基于 Yocto Project，我们可以开发属于自己的 Linux 系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，送上一个别人的 Galileo 开箱视频&lt;/p&gt;
&lt;p&gt;&lt;embed src="http://player.youku.com/player.php/sid/XNjQ0NTMzMjYw/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/p&gt;</summary><category term="Intel Galileo"></category></entry><entry><title>学习 Arduino #1 Arduino 入门</title><link href="http://guqian110.github.io/pages/2014/05/27/learing_arduino_series_1_getting_started.html" rel="alternate"></link><updated>2014-05-27T12:34:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-27:pages/2014/05/27/learing_arduino_series_1_getting_started.html</id><summary type="html">&lt;h2&gt;What is Arduino&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="logo" src="/images/learning-arduino-series-1-getting-started/logo.png" /&gt;&lt;/p&gt;
&lt;p&gt;版权所有：Arduino.cc&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/"&gt;Arduino 官网&lt;/a&gt; 首页的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARDUINO IS AN OPEN-SOURCE ELECTRONICS PROTOTYPING PLATFORM BASED ON FLEXIBLE, EASY-TO-USE HARDWARE AND SOFTWARE. IT'S INTENDED FOR ARTISTS, DESIGNERS, HOBBYISTS AND ANYONE INTERESTED IN CREATING INTERACTIVE OBJECTS OR ENVIRONMENTS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Guide/Introduction"&gt;官方网站最权威的答案：&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arduino is a tool for making computers that can sense and control more of the physical world than your desktop computer. &lt;strong&gt;It's an open-source physical computing platform based on a simple microcontroller board, and a development environment for writing software for the board.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino can be used to develop interactive objects, taking inputs from a variety of switches or sensors, and controlling a variety of lights, motors, and other physical outputs. Arduino projects can be stand-alone, or they can communicate with software running on your computer (e.g. Flash, Processing, MaxMSP.) The boards can be assembled by hand or purchased preassembled; the open-source IDE can be downloaded for free.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Development Language：&lt;/strong&gt; &lt;a href="http://arduino.cc/en/Reference/HomePage"&gt;Arduino programming language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IDE：&lt;/strong&gt; &lt;a href="http://arduino.cc/en/Main/Software"&gt;Arduino IDE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt; &lt;a href="http://en.wikipedia.org/wiki/Arduino"&gt;Wikipedia 上的介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的说：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino 是一个开放源代码的单片机，它使用了 Atmel AVR 单片机，采用了基于开放源代码的软硬件平台，构建于开放源代码 simple I/O 接口板。开发语言为 Arduino programming language（基于 Wiring 语言），开发环境基于 Processing 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Story of Arduino&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;wikipedia 上的&lt;a href="http://zh.wikipedia.org/wiki/Arduino"&gt;小故事&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arduino的核心开发团队成员包括：Massimo Banzi，David Cuartielles，Tom Igoe，Gianluca Martino，David Mellis 和 Nicholas Zambetti。&lt;/p&gt;
&lt;p&gt;据说 Massimo Banzi 之前是意大利 Ivrea 一家高科技设计学校的老师。他的学生们经常抱怨找不到便宜好用的微控制器。2005年冬天， Massimo Banzi 跟 David Cuartielles 讨论了这个问题。David Cuartielles 是一个西班牙籍芯片工程师，当时在这所学校做访问学者。两人决定设计自己的电路板，并引入了 Banzi 的学生 David Mellis 为电路板设计编程语言。两天以后，David Mellis 就写出了程式码。又过了三天，电路板就完工了。这块电路板被命名为 Arduino。几乎任何人，即使不懂电脑编程，也能用 Arduino 做出很酷的东西，比如对传感器作出回应，闪烁灯光，还能控制马达。随后 Banzi，Cuartielles，和 Mellis 把设计图放到了网上。保持设计的开放源码理念，因为版权法可以监管开源软件，却很难用在硬件上，他们决定采用共享创意许可。共享创意是为保护开放版权行为而出现的类似 GPL 的一种许可（license）。在共享创意许可下，任何人都被允许生产电路板的复制品，还能重新设计，甚至销售原设计的复制品。你不需要付版税，甚至不用取得 Arduino 团队的许可。然而，如果你重新发布了引用设计，你必须说明原始 Arduino 团队的贡献。如果你调整或改动了电路板，你的最新设计必须使用相同或类似的共享创意许可，以保证新版本的 Arduino 电路板也会一样的自由和开放。唯一被保留的只有 Arduino 这个名字。它被注册成了商标。如果有人想用这个名字卖电路板，那他们可能必须付一点商标费用给 Arduino 的核心开发团队成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Why is Arduino&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Guide/Introduction"&gt;官网介绍&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are many other microcontrollers and microcontroller platforms available for physical computing. Parallax Basic Stamp, Netmedia's BX-24, Phidgets, MIT's Handyboard, and many others offer similar functionality. All of these tools take the messy details of microcontroller programming and wrap it up in an easy-to-use package. &lt;strong&gt;Arduino also simplifies the process of working with microcontrollers, but it offers some advantage for teachers, students, and interested amateurs over other systems:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inexpensive&lt;/li&gt;
&lt;li&gt;Cross-platform (Windows, Linux, Macintosh OSX)&lt;/li&gt;
&lt;li&gt;Simple, clear programming environment&lt;/li&gt;
&lt;li&gt;Open source and extensible software&lt;/li&gt;
&lt;li&gt;Open source and extensible hardware&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;How-to Develope&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;IDE installation&lt;/h3&gt;
&lt;p&gt;官网上有 Windows, Linux, Mac 的详细安装步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://arduino.cc/en/Guide/Windows"&gt;for Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://playground.arduino.cc/Learning/Linux"&gt;for Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux 安装过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解决包依赖关系：安装 openjdk-7-jre (openjdk-6-jre, sun's java 6 runtime, the sun-java6-jre package, the oracle JRE 7 应该也可以)&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;openjdk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;jre&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载合适的 &lt;a href="http://arduino.cc/en/Main/Software"&gt;Arduino IDE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;解压、切换到解压路径，运行目录下的 &lt;code&gt;arduino&lt;/code&gt; 脚本&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zxvf&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0.5&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux32&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tgz&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0.5&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;arduino&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法二 (for Ubuntu)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载 &amp;amp; 安装&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Dev&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IDE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino IDE 是用 Java 写的跨平台的程序，它源自 &lt;a href="http://en.wikipedia.org/wiki/Processing_(programming_language)"&gt;Processing programming language&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Wiring_(development_platform)"&gt;Wiring&lt;/a&gt; 项目的 IDE 。它是为艺术家和其他不熟悉软件开发的新手而设计的。它包含一个有语法高亮、括号匹配、自动缩进功能的代码编辑器，还可以通过一个按键完成编译程序(compile)和烧录至电路板(upload)的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Programming&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 Arduino 程序/代码 称为 "&lt;em&gt;Sketch&lt;/em&gt;"。Arduino 程序是用 C/C++ 写成的，Arduino IDE 含有一个名叫 "Wiring" 的代码库(源自于 Wiring 项目)，这样子可以大幅度简化常用 I/O 操作，用户只需要定义两个函数就可以写出一个可以运行的程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;setup()&lt;/em&gt; : 系统上电或者复位时启动，只运行一次，初始化配置&lt;/li&gt;
&lt;li&gt;&lt;em&gt;loop()&lt;/em&gt; : 一直循环被调用，直到断电&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Arduino 的示例程序 "Blink"：(等同于 C 的 hello world，对于硬件最简单就是控制一个 LED 的亮灭)&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;Blink&lt;/span&gt;
&lt;span class="cm"&gt;Turns on an LED on for one second, then off for one second, repeatedly.&lt;/span&gt;

&lt;span class="cm"&gt;This example code is in the public domain.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="c1"&gt;// Pin 13 has an LED connected on most Arduino boards.&lt;/span&gt;
&lt;span class="c1"&gt;// give it a name:&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// the setup routine runs once when you press reset:&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                
  &lt;span class="c1"&gt;// initialize the digital pin as an output.&lt;/span&gt;
  &lt;span class="n"&gt;pinMode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;OUTPUT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// the loop routine runs over and over again forever:&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;HIGH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// turn the LED on (HIGH is the voltage level)&lt;/span&gt;
  &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="c1"&gt;// wait for a second&lt;/span&gt;
  &lt;span class="n"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LOW&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// turn the LED off by making the voltage LOW&lt;/span&gt;
  &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="c1"&gt;// wait for a second&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;上面的这段代码对于一个标准 C++ 编译器来说是无效的，事实上当我们按下 IDE 界面上的 "Upload to I/O board" 按钮时，IDE 会拷贝一份代码，在开头加上 &lt;code&gt;include&lt;/code&gt; 指示，在结尾加上一个很简单的 &lt;code&gt;main()&lt;/code&gt; 函数，这样它就是一个有效的 C++ 程序了。&lt;/p&gt;
&lt;p&gt;Arduino 使用 &lt;a href="http://en.wikipedia.org/wiki/GNU_toolchain"&gt;GNU toolchain&lt;/a&gt; 和 AVR Libc 来编译程序的，使用 AVRdude 把程序下载到板子上。因为 Arduino 平台采用的是 Atmel 的微控制器，所以 Atmel 的开发环境 AVR Studio 或者更新的 Atmel Studio 应该也可以作为 Arduino 的开发环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习资源&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Arduino 的联合创始人 Massimo Banzi 的 Tutorial Series Vedio&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youku.com/playlist_show/id_19440139.html"&gt;优酷视频地址&lt;/a&gt;，一共 11 课，涵盖最基本的面包板搭电路、I/O 接口控制、传感器控制、网络应用等方面，如果有编程基础，很快就可以上手制作自己的设备了～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/"&gt;Arduino 中文社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/thread-1066-1-1.html"&gt;论坛教程汇总帖&lt;/a&gt;，因为 Arduino 诞生的一个很大的目的就是为设计师、艺术家、业余爱好者提供更加方便的开发环境，所以，Arduino 的教程对于有编程基础的同学来说是很容易的 ：-P&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Reference/HomePage"&gt;Arduino Language Reference en&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网上关于 Arduino 编程语言的介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/reference/"&gt;Arduino Language Reference zh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Arduino 中文社区翻译的 编程语言介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Tutorial/HomePage"&gt;Arduino Core Functions, Libraries&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网上关于 IDE 中 &lt;code&gt;File/Examples/&lt;/code&gt; 下示例程序的说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/"&gt;Arduino official website&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Arduino"&gt;Arduino on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/"&gt;Arduino 中文社区&lt;/a&gt;&lt;/p&gt;</summary><category term="Open-source Hardware"></category></entry><entry><title>BUPT MITC lab Verilog HDL coding style guide</title><link href="http://guqian110.github.io/pages/2014/05/19/bupt_mitc_lab_verilog_hdl_coding_style_guide.html" rel="alternate"></link><updated>2014-05-19T10:12:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-19:pages/2014/05/19/bupt_mitc_lab_verilog_hdl_coding_style_guide.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Version&lt;/strong&gt; : 1.1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Date&lt;/strong&gt; : 2014-5-24&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Author&lt;/strong&gt; : Qian Gu (guqian110@gmail.com)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt; : This is a brief Verilog HDL coding style guide for BUPT MITC lab to design circuits on FPGA. This guide is only concerned about code format and dose not involve principles for writing synthesisable codes.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;总则&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码模块化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顶层模块只有子模块的例化，不包含任何逻辑 ；常用、通用功能模块化，避免在多个模块中重复实现多次；模块内容过多时考虑分解为多个模块；模块按照功能、信号传递流程原则划分 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块结构化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分节书写，合理使用空格、括号，使代码更容易查看 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用缩写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;约定命名规则、大小写规则、常用单词缩写规则，避免过长的信号名 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;分述&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;head of file&lt;/h3&gt;
&lt;p&gt;Xilinx ISE 自动生成的标准文件头部，添加 &lt;code&gt;Email&lt;/code&gt;、&lt;code&gt;File Name&lt;/code&gt; 两个信息，最终结果：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Company: &lt;/span&gt;
&lt;span class="c1"&gt;// Engineer: &lt;/span&gt;
&lt;span class="c1"&gt;// Email:&lt;/span&gt;
&lt;span class="c1"&gt;// &lt;/span&gt;
&lt;span class="c1"&gt;// Create Date:    20:43:36 11/12/2013 &lt;/span&gt;
&lt;span class="c1"&gt;// Design Name: &lt;/span&gt;
&lt;span class="c1"&gt;// Module Name:    CLKMGN&lt;/span&gt;
&lt;span class="c1"&gt;// File Name:      clkmgn.v&lt;/span&gt;
&lt;span class="c1"&gt;// Project Name: &lt;/span&gt;
&lt;span class="c1"&gt;// Target Devices: &lt;/span&gt;
&lt;span class="c1"&gt;// Tool versions: &lt;/span&gt;
&lt;span class="c1"&gt;// Description: &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// Dependencies: &lt;/span&gt;
&lt;span class="c1"&gt;// &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// Revision: &lt;/span&gt;
&lt;span class="c1"&gt;// Revision 0.01 - File Created&lt;/span&gt;
&lt;span class="c1"&gt;// Additional Comments: &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;module&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;模块命名大小写：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件名：xxx.v (小写)&lt;/li&gt;
&lt;li&gt;模块名：XXX (大写)&lt;/li&gt;
&lt;li&gt;例化名：U_XXX (大写)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模块端口定义顺序：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;li&gt;双向&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;模块调用规范：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;em&gt;信号映射法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;举例说明：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Module Declaration                                                            //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;MODULE_NAME&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="c1"&gt;// input ports&lt;/span&gt;
    &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;port_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="c1"&gt;// output ports&lt;/span&gt;
    &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;port_m&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;////////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Port Declarations                                                              //&lt;/span&gt;
&lt;span class="c1"&gt;////////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//input ports&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// comments&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//output ports&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// comments&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Parameter Declarations                                                        //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;DIN&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTA&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTE&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTCTR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Wire &amp;amp; Reg Declarations                                                       //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="kt"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="kt"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Main Body of Code                                                             //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;

    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// Instantiate sub module                                //&lt;/span&gt;
    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="no"&gt;MODULE_NAMW_A&lt;/span&gt; &lt;span class="no"&gt;U_MODULE_NAMW_A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// do something&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;wire_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wire_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;FSM&lt;/h3&gt;
&lt;p&gt;有限状态机(Finite State Machine) 使用三段式格式。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FSM-1&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// next state&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// FSM-2&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// FSM-3&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;

    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// default output&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;defaut:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;endcase&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;always&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个 &lt;code&gt;always&lt;/code&gt; 中不要同时含有 &lt;em&gt;组合逻辑&lt;/em&gt; 和 &lt;em&gt;时序逻辑&lt;/em&gt;，分开写在不同的 &lt;code&gt;always&lt;/code&gt; 块中。&lt;/li&gt;
&lt;li&gt;组合逻辑使用 &lt;em&gt;阻塞赋值(=)&lt;/em&gt;，时序逻辑使用 &lt;em&gt;非阻塞赋值(&amp;lt;=)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;不要在多个 &lt;code&gt;always&lt;/code&gt; 中对同一信号赋值，也不要在一个 &lt;code&gt;always&lt;/code&gt; 中对一个信号进行多次赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标准 &lt;code&gt;always&lt;/code&gt; 格式&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;

    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do somethig&lt;/span&gt;

    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;parameter&lt;/h3&gt;
&lt;p&gt;parameter 全部大写，用 parameter 定义有实际意义的常数，比如 LED 亮灯状态、状态机状态等，避免 "magic number"。举例：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Parameter Declarations                                                        //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;DIN&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTA&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTE&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTCTR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;if-else&lt;/h3&gt;
&lt;p&gt;标准 &lt;code&gt;if-else&lt;/code&gt; 格式&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;

&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;

&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;case-default&lt;/h3&gt;
&lt;p&gt;标准 &lt;code&gt;case&lt;/code&gt; 格式&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;variable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nl"&gt;vaule1:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;

    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="nl"&gt;value2:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;

    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;naming&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词首字母缩写，大写。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="no"&gt;DMI&lt;/span&gt;     &lt;span class="c1"&gt;// Data Memory Interface&lt;/span&gt;
&lt;span class="no"&gt;DEC&lt;/span&gt;     &lt;span class="c1"&gt;// Decoder&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块间信号名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分为两部分，第一部分表示信号方向，大写，第二部分表示信号意义，小写，下划线连接。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;CPUMMU_wr_req&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// write request form CPU to MMU&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块内命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词缩写，下划线连接，小写。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;sdram_wr_en&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// SDRAM write enable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统级命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时钟信号、置位信号、复位信号等需要输送到各个模块的全局信号，以 &lt;code&gt;SYS_&lt;/code&gt; 前缀开头。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_clk_100MHz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// system clock&lt;/span&gt;
&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_set_cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// system counter set&lt;/span&gt;
&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_rst_cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// system counter reset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;低电平有效信号命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;低电平有效信号加后缀 &lt;code&gt;_n&lt;/code&gt;，举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// low valid reset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;经过锁存器的信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过锁存器的信号加后缀 &lt;code&gt;_r&lt;/code&gt;，以和锁存前区别。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// latch input data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际意义缩写，大写。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="no"&gt;WAIT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;常用信号名缩写：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;acknowledge&lt;/td&gt;
&lt;td&gt;ack&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ready&lt;/td&gt;
&lt;td&gt;rdy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;adress&lt;/td&gt;
&lt;td&gt;addr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;enable&lt;/td&gt;
&lt;td&gt;en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;receive&lt;/td&gt;
&lt;td&gt;rx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arbiter&lt;/td&gt;
&lt;td&gt;arb&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;frame&lt;/td&gt;
&lt;td&gt;frm&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;req&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;check&lt;/td&gt;
&lt;td&gt;chk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;generate&lt;/td&gt;
&lt;td&gt;gen&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;resest&lt;/td&gt;
&lt;td&gt;rst&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;clk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;grant&lt;/td&gt;
&lt;td&gt;gnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;segment&lt;/td&gt;
&lt;td&gt;seg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;cfg&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;increase&lt;/td&gt;
&lt;td&gt;inc&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;source&lt;/td&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;control&lt;/td&gt;
&lt;td&gt;ctrl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;statistic&lt;/td&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;counter&lt;/td&gt;
&lt;td&gt;cnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;switcher&lt;/td&gt;
&lt;td&gt;sf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data in&lt;/td&gt;
&lt;td&gt;din&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;out&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;timer&lt;/td&gt;
&lt;td&gt;tmr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data out&lt;/td&gt;
&lt;td&gt;dout&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;packet&lt;/td&gt;
&lt;td&gt;pkt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;tmporary&lt;/td&gt;
&lt;td&gt;tmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decode&lt;/td&gt;
&lt;td&gt;de&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;priority&lt;/td&gt;
&lt;td&gt;pri&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;transmit&lt;/td&gt;
&lt;td&gt;tx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decrease&lt;/td&gt;
&lt;td&gt;dec&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ptr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;valid&lt;/td&gt;
&lt;td&gt;vld&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delay&lt;/td&gt;
&lt;td&gt;dly&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;rd&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write enable&lt;/td&gt;
&lt;td&gt;wr_en&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable&lt;/td&gt;
&lt;td&gt;dis&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read enbale&lt;/td&gt;
&lt;td&gt;rd_en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;wr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;incedent&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;tab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的 &lt;code&gt;tab&lt;/code&gt; 全部用 &lt;em&gt;4 个 &lt;code&gt;space&lt;/code&gt;&lt;/em&gt; 代替！不同层次之间用 &lt;code&gt;tab(4 sapce)&lt;/code&gt; 缩进 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;space&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信号端口定义，关键字、宽度说明、信号名之间对齐。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;input&lt;/span&gt;          &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;input&lt;/span&gt;          &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;input&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二元运算符用 &lt;code&gt;space&lt;/code&gt; 隔开&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dout_en&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;comments&lt;/h3&gt;
&lt;p&gt;采用英文，合理注释。修改代码一定要注释，添加 Revision 信息 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;建议&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;开发工具：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理工程： Xilinx ISE&lt;/li&gt;
&lt;li&gt;综合工具： Xilinx Synthsis Tools&lt;/li&gt;
&lt;li&gt;仿真平台： ModelSim SE&lt;/li&gt;
&lt;li&gt;代码编辑： Sublime Text 2 + Verilog 插件&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Verilog"></category><category term="coding style"></category></entry><entry><title>FPGA 数字处理基础 (1)</title><link href="http://guqian110.github.io/pages/2014/05/14/fpga_digital_processing_basic_1.html" rel="alternate"></link><updated>2014-05-14T23:25:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-14:pages/2014/05/14/fpga_digital_processing_basic_1.html</id><summary type="html">&lt;h2&gt;数字处理基础&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;数字处理基础&lt;/strong&gt;主要包括两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数的表示&lt;/li&gt;
&lt;li&gt;常用算术运算的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别讨论&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;数的表示&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这部分讨论对于计算机(PC)、数字信号处理器件(DSP)、数字芯片(包括 FPGA) 都是成立的。&lt;/p&gt;
&lt;h3&gt;人类如何计数&lt;/h3&gt;
&lt;p&gt;最早我们的祖先采用的是结绳计数，经过几千年的发展，现在我们使用的 10 进制位置计数法 。那么我们为什么偏偏选择 10 这个数字呢？&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; 在他的著作 &lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt; 中分析了我们的计数进制现象 。原因其实很简单，10 这个数字对于我们如此特别只是因为我们有 10 个手指(脚趾)，于是我们采用了 10 进制，并且逐渐习惯了它 。他在书中模拟了一下进制系统的演化过程，让我们逐渐从人类的 10 进制思维逐渐转化到计算机的 2 进制系统中：&lt;/p&gt;
&lt;p&gt;假设我们是卡通动画中的人物，比如米老鼠 Mickey，仔细观察它就会发现，他的每个手只有 4 个手指，理所当然，他采用 8 进制来计数。如果更进一步，假设我们是龙虾，那么我们的每一只钳子上有两个 “手指”，一共有 4 个手指，所以，我们会采取 4 进制计数系统。最后，假设我们是海豚，那么我们只有两个鳍来计数了，这时候的计数系统就是 2 进制数字系统了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;r 进制 to 10 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需要按权值展开就可以了，比如： &lt;/p&gt;
&lt;p&gt;2 进制数 &lt;code&gt;110101&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;32 + 16 + 4 + 1 = 53&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;8 进制数 &lt;code&gt;B65F&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;11 × 16^3 + 6 × 16^2 + 5 × 16 + 15 × 1 = 46687&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10 进制 to r 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整数部分：基数连除，逆序取余&lt;/p&gt;
&lt;p&gt;小数部分：基数连乘，顺序取余&lt;/p&gt;
&lt;h3&gt;计算机如何计数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;正数 &amp;amp; 负数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人类和计算机的计数原理是完全不同的，所以采用的方法也是完全不同的。对于人来说，区分正负数只需要在数字绝对值前添加一个符号 &lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;-&lt;/code&gt; 即可，但是计算机只有 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 这两个符号可以使用；对于人来说，减法借位很容易，但是对于计算机硬件电路来说这是一件很麻烦的事。&lt;/p&gt;
&lt;p&gt;常用的表示方法有 3 种：&lt;strong&gt;原码&lt;/strong&gt;、&lt;strong&gt;反码&lt;/strong&gt;、&lt;strong&gt;补码&lt;/strong&gt; 。对于计算机而言，硬件上最容易实现的是补码，这也是大多数计算机采用补码系统的原因 。&lt;/p&gt;
&lt;p&gt;以前总结过一篇博客，&lt;a href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整数 &amp;amp; 小数&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数&lt;/p&gt;
&lt;p&gt;对于整数而言，不存在小数点的问题，所以自然地将我们人类所熟悉的 10 进制数转化为计算机熟悉的 2 进制数，分配足够的空间存储起来就 ok 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小数&lt;/p&gt;
&lt;p&gt;在计算机中，整数和小数之间并不是很容易转换的的，而且小数的存储和处理要比整数复杂。对于小数，可以有两种方法来表示：&lt;strong&gt;定点数&lt;/strong&gt; &amp;amp; &lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定点数的意思是小数点在数中的位置是固定不变的。整数可以看作是一种特殊的定点数，小数点在数的末尾。值得注意的是小数点的位置信息并没有和数字存储在一起，所以，使用定点数的程序必须知道小数点的位置。&lt;/p&gt;
&lt;p&gt;浮点数的意思是小数点在数中的位置是变化的。当代大部分计算机处理浮点数的标准是 IEEE 在 1985 年制定的 ANSI/IEEE Std 754-1985 。&lt;/p&gt;
&lt;p&gt;==============================跑题分割线========================&lt;/p&gt;
&lt;p&gt;在计算机出现不久的年代，计算机处理浮点数是一件很重要但也让人头疼的事。最早，还没有专门处理浮点数的硬件，所以程序猿必须编写软件来完成浮点数的计算。浮点数在科学运算和工程类程序中极为重要，因此常常被赋予很高的优先级，在计算机发展的早期，为新制造的计算机做的第一项工作就是为其编写浮点数运算程序。&lt;/p&gt;
&lt;p&gt;如果可以直接利用计算机机器码指令来实现浮点数的计算，类似于 16 位处理器上进行乘法和除法运输，那么这台机器上所有的浮点数运算都会变得更快。IBM 公司在 1954 年发布了 IBM 704，它是第一台将浮点数运算硬件作为可选配件的商用计算机。该机器的浮点运算硬件可以直接进行加法、减法、乘法和除法，其他的浮点运算必须通过软件来实现。&lt;/p&gt;
&lt;p&gt;从 1980 年开始，浮点运算硬件开始应用于桌面计算机，这起始于 Intel 当年发布的 8087 数字协同处理(Numberic Data Coprocessor)芯片，当时这种集成电路被称为 &lt;strong&gt;数学协同处理器(math coprocessor)&lt;/strong&gt; 或者 &lt;strong&gt;浮点运算单元(floating-point,FPU)&lt;/strong&gt;。8087 不能独立工作，必须和 8086 或者 8088 一起工作，所以被称为 “&lt;strong&gt;协处理器&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;在最初版本的 IBM PC 主板上，位于 8080 芯片的右边有一个 40 个管脚的插槽供 8087 芯片接入，但是，这个插槽是空的，如果用户需要浮点运算则必须单独购买一块 8087 芯片。数字协处理器并不能加速所有的程序的运行速度，比如文字处理程序几乎用不到浮点运算，而电子表格处理程序对浮点数运算依赖程度很高。&lt;/p&gt;
&lt;p&gt;安装了数学协处理器，程序员必须使用协处理器的机器码指令来编写特定的程序，因为数学协处理器不是标准硬件。最后就出现了这样的局面：如果机器上安装了数学协处理器，程序员就要学会编写相应的应用程序以支持它的运行；如果没有安装，程序员必须通过编程来模拟它进行浮点数的运算。&lt;/p&gt;
&lt;p&gt;在 1989 年发布的 486DX 芯片中，FPU 已经内建在 CPU 的结构里，但是在 1991 年发布的 486SX 中，又没有内建 FPU，到了 1993 年发布的奔腾芯片中，CPU 内置 FPU 再次成为标准，并且是永远的标准。在 1990 年发布的 68040 芯片中，摩托罗拉首次将 FPU 集成到 CPU 中，在此之前是使用 68881 和 68882 数学协处理器来支持 68000 家族的微处理器。PowerPC 芯片同样使用了内置 FPU 的技术。&lt;/p&gt;
&lt;p&gt;==============================跑题分割线结束========================&lt;/p&gt;
&lt;p&gt;FPGA 不同于微处理器，它内部没有内置 FPU(不包括硬核)，对于FPGA，浮点数可以克服定点数动态范围小的缺点，但是在运算时，实现浮点数的硬件实时成本高，处理速度慢，所以在非实时运算中有广泛的应用。对于通信系统中的信号，一般都是实时处理的，所以在 FPGA 开发中，一般只使用定点数 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;常用算术运算的 FPGA 实现&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;加法&lt;/h3&gt;
&lt;p&gt;在 Verilog HDL 中，直接使用运算符 &lt;code&gt;+&lt;/code&gt;，其本质上是一种并行加法器，应该保证两边的数位宽是一致的。举个栗子&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;add_4&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;          &lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;乘法&lt;/h3&gt;
&lt;p&gt;第一种方法，最简单，直接使用运算符 &lt;code&gt;*&lt;/code&gt;，如下所示 。但是这种方法写出来的代码效率很低，甚至有时候是不可综合的，实际应用中基本不会采用这种方法。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;第二种方法是自己写代码实现乘法运算，或者是使用 IP COre。一般 FPGA 中都集成了硬核的乘法器，所以可以有两种方案来实现乘法器，DSP48 硬核 或者是 Slice 搭建 。&lt;/p&gt;
&lt;h3&gt;除法&lt;/h3&gt;
&lt;p&gt;除法是四则基本运算中最复杂的，也是最难实现的。除法可以看作是乘法的逆运算，但除法要复杂的多，最大的区别是乘法中的一些操作可以并行支持，通过流水线提高计算速度，但是除法必须顺序执行，运算最耗时间。&lt;/p&gt;
&lt;p&gt;Verilog 提供了除法运算符 &lt;code&gt;/&lt;/code&gt;，如下所示。但是只有在除数为 2 或者 2 的整幂次时才是可综合的，其余情况都不可综合 。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;常用的方法是采用 IP Core，可以完成定点数和浮点数两类算法。&lt;/p&gt;
&lt;h3&gt;Cordic 算法&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/CORDIC"&gt;Cordic 算法&lt;/a&gt; 算法即坐标旋转数字计算方法，是J.D.Volder1于1959年首次提出，主要用于三角函数、双曲线、指数、对数的计算。该算法通过基本的加和移位运算代替乘法运算，使得矢量的旋转和定向的计算不再需要三角函数、乘法、开方、反三角、指数等函数。&lt;/p&gt;
&lt;p&gt;它通常应用在没有硬件乘法器的应用中，比如微控制器、FPGA 中，进行的所有操作只有加法、移位和查表 。&lt;/p&gt;
&lt;p&gt;Coridc 算法可以自己编写代码实现，也可以使用 IP Core 。(事实上，所有的 IP 软核理论上都可以自己写，因为这些软核实际上就是别人写好的代码和文档，类似于C语言中的库函数)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3795386/"&gt;《无线通信的 Matlab 和 FPGA 实现》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt;&lt;/p&gt;</summary><category term="digital processing"></category></entry><entry><title>麦田里的守望者 书评</title><link href="http://guqian110.github.io/pages/2014/05/14/the_catcher_in_the_rye_review.html" rel="alternate"></link><updated>2014-05-14T00:41:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-14:pages/2014/05/14/the_catcher_in_the_rye_review.html</id><summary type="html">&lt;p&gt;&lt;img alt="the catcher in the rye" src="/images/the-catcher-in-the-rye-review/the_catcher_in_the_rye.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;如何认识这本书&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;以前就听说过这本书的名字，真正感兴趣是在《我爱摇滚乐》上看到的一篇文章，介绍了枪杀传奇乐队披头士 The Beatles 的主唱约翰·列侬(John Winston Lennon) 的凶手马克·查普曼 (Mark David Chapman)，他被捕时身上就带着一本《麦田里的守望者》。当查普曼被捕时，警方从他的副本中发现了这样的话：“亲爱的霍尔顿·考尔菲德，自霍尔顿·考尔菲德，这是我的陈述。”&lt;/p&gt;
&lt;p&gt;后来才发现，其实这本书很有争议，它和几起枪击案与小说有关，这包括罗伯特·约翰·巴窦枪击丽贝卡·谢弗，约翰·欣克利刺杀罗纳德·里根未遂。马克·大卫·查普曼枪击了约翰·列侬。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;这是一本曾样的书&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E9%BA%A5%E7%94%B0%E6%8D%95%E6%89%8B"&gt;麦田里的守望者 on wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该书于1951年出版之后，立刻引起巨大的轰动，受到读者——特别是青年人——的热烈的欢迎，被翻译为多国语版。小说每年大约有250,000本售出、总计为6500万本。时代杂志将《麦田里的守望者》列在“2005年度百大英语小说（自1923年起）”榜上，现代图书馆及其读者也将其列在20世纪百大英文小说榜上。赞赏者认为本书用青少年的口吻平铺直叙，增加了作品的感染力，传神地描写主角的内心思维，并说出了青少年不满成年世界充满虚伪欺瞒的心声。批评者则认为书中主角离经叛道，逃学、吸烟、喝酒又满嘴粗话，会给年轻读者带来不良影响。当时许多图书馆及学校将之列为禁书，并被列在美国最具挑战性图书榜上。但现在这本书却是许多美国学校的指定读物。有的评论家说，它“大大地影响了好几代美国青年”。而且有学者认为，霍尔顿是当代美国文学中最早出现的反英雄形象之一。&lt;/p&gt;
&lt;p&gt;《麦田里的守望者》位列20世纪最佳小说之林。小说出版后不久，纳什·K·伯格（Nash K. Burger）写给《纽约时报》称小说为“少见的杰作”，詹姆斯·斯特恩（James Stern）则模仿霍尔顿的语气，为小说送上钦佩之词。.美国前总统乔治·赫伯特·沃克·布什称小说为“了不起的作品”，并称它启迪了自己。2009年6月，BBC的芬洛·卢勒（Finlo Rohrer）写道小说问世已有58年之久，但依然是“青春期的定义之作”。霍尔顿常常愤世嫉俗、郁郁寡欢、离群索居、与世隔绝、迷失方向、玩世不恭”。亚当·戈普尼克认为小说与美国文学中的《了不起的盖茨比》、《哈克历险记》并列为“三部完美之作”，称“在对纽约50年代的捕捉上，没有哪一部作品可以与《麦田里的守望者》并驾齐驱。”&lt;/p&gt;
&lt;p&gt;并非所有评论都是积极的；与其他评论家一样，卢勒写道：“笼罩在神秘之中的小说并没有满足读者的期待，这让人感到失望。塞林格助长了这种神秘感，或者说，他什么都没做。”。。论道小说风靡与争议的背后缘故时，称小说“捕捉到了青春期存在的焦虑”、“中心人物复杂”、“对话风格平易近人”；与此同时，一些读者可能会对“纽约40年代的俗语”、“人物的自恋”、“过多的牢骚”表示反感。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;每个人心中都有一个霍尔顿&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;花费了三天时间看完了全书，默默无语，不知道该说些什么...&lt;/p&gt;
&lt;p&gt;这本书描写的对象是上世纪 50 年代，美国战后一代人的精神状态，他们酗酒、抽烟、吸毒，被称为 “垮掉的一代”，破破烂烂的T恤衫和牛仔裤，开着父母给的昂贵的跑车，抽一支接一支的大麻香烟，在公共场所旁若无人地亲吻，挑战社会传统和道德底线。因为时代背景、文化背景不同，很多中国小孩刚开始看前几章时，不是很有共鸣（比如我），甚至可能读到一半就想放弃。但是如果你坚持看完，相信我，你会不由自主的喜欢上这个满口脏话、叛逆、成绩不及格的问题少年——霍尔顿。&lt;/p&gt;
&lt;p&gt;每个人都有不同的成长经历，或顺利，或坎坷，但是没有人永远一帆风顺，每个人都有不开心、孤独、寂寞、迷茫的时候，如果你坚持看下去，你会从这个叛逆少年身上发现自己的影子，触动内心那温柔的一角。&lt;/p&gt;
&lt;h3&gt;青少年 &amp;amp; 成年人&lt;/h3&gt;
&lt;p&gt;这本书描写的对象是美国 “垮掉的一代”，和他们联系在一起的是酗酒、大麻、吸毒、叛逆等词，作为中国人，作为 90 后，我们似乎和他们没有任何交集和共同点 。但是仔细回顾历史，就会发现其实不光美国这一代人，在人类社会发展历史中，每一代人在前辈口中都是几乎一样的一无是处 。我们的父辈似乎总在对我们挑刺，认为我们叛逆、不听话，但是他们在批评我们时，却忘了他们当年也是这样过来的，就像 70 后看不顺眼 80 后，80 后看不顺眼 90 后，现在，我们90 后也看不顺眼 00 后，认为这帮熊孩子屁事不懂，一天只知道火星文、非主流、45度仰望天空 。&lt;strong&gt;而这说白了就是青少年和成年人世界的代沟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;青少年的困境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;美国硅谷创业之父 Paul Graham 的著作《黑客与画家》中第一篇文章：为什么书呆子不受欢迎，就讨论了青少年和成人世界的隔阂 。&lt;/p&gt;
&lt;p&gt;关于校园暴力，成年人不是不知道孩子们内部发生的这些事，他们知道孩子的行为有时候是极端残酷的，正如我们知道贫穷国家的人们生活极端艰难，但是，像所有人一样，成年人不喜欢揪住不放这种令人不快的事实 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学校就像是监狱一样，老师就像是狱卒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个比喻是作者形容美国公立学校的，或许在中国，即使一个学校再烂，大多数中国人都不会这么描述，中国的 “标准答案” 是学校是花园，老师辛勤的园丁。如今的成年人根本不接受青少年，他们在上班的路上顺便把孩子送到学校关着，就像周末出门时把狗送到寄养的地方。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而在工业社会以前，青少年的角色则更加积极，他们是学徒，不是在作坊里，就是在农庄里，或者是在某艘军舰上，他们是成年人社会的低级成员。青少年尊重成年人，成年人也接受青少年。而现在，青少年在生产活动中，根本毫无用处，只能在快餐店充当廉价劳动力。所以，成年人不得不把他们集中到一起，让几个成年人看守所有的孩子 —— 学校诞生了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很新奇的看法，和中国传统意见完全不同，我们不妨保持 open mind，某种程度上这个分析是有道理的 :-P&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔阂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们总是固执己见，尤其是青少年，谁没有从逃课准备去西部生活的霍尔顿身上看到自己的影子呢？但愿不要有一天，像 Eason 在 《shall we talk》 中唱的一样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;孩童只盼望歡樂　大人只知道寄望&lt;/p&gt;
&lt;p&gt;為何都不大懂得努力體恤對方&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;陪我講　陪我講出我們最後何以生疏&lt;/p&gt;
&lt;p&gt;誰怕講　誰會可悲得過孤獨探戈&lt;/p&gt;
&lt;p&gt;難得　可以同座　何以　要忌諱赤裸&lt;/p&gt;
&lt;p&gt;如果心聲真有療效　誰怕暴露更多　你別怕我&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;成人只寄望收穫　情人只聽見承諾&lt;/p&gt;
&lt;p&gt;為何都不大懂得努力珍惜對方&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;陪我講　陪我講出我們最後何以生疏&lt;/p&gt;
&lt;p&gt;誰怕講　誰會可悲得過孤獨探戈&lt;/p&gt;
&lt;p&gt;難得　可以同座　何以　要忌諱赤裸&lt;/p&gt;
&lt;p&gt;如果心聲真有療效　誰怕暴露更多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Hold on&lt;/h3&gt;
&lt;p&gt;面对这个世界，你需要的是保持一个善良的心，并且坚持下去。每个人都有不开心、孤独、寂寞、迷茫的时候，保持一颗善良朴实的心灵，坚守住我们心中的那片麦田才是真正难能可贵的事。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有那么一群小孩子在一大块麦田里做游戏。几千几万个小孩子，附近没有一个人——没有一个大人，我是说 —— 除了我。
我呢，就站在那混帐的悬崖边。我的职务是在那儿守望，要是有哪个孩子往悬崖边奔来，我就把他捉住——我是说孩子们都在狂奔，也不知道自己是往哪儿跑，我得从什么地方出来，把他们捉住。
我整天就干这样的事。我只是想当个麦田里的守望者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;To-Do List&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;麦田里的守望者(The Catcher in the Rye)、在路上(On the Road)、了不起的盖茨比(The Great Gatsby)并称 “美国xxx小说”，盖茨比看过电影了，小说没有看过，以后有时间了再看～&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On the Road&lt;/li&gt;
&lt;li&gt;The Great Gatsby&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E9%BA%A5%E7%94%B0%E6%8D%95%E6%89%8B"&gt;麦田里的守望者 on wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="The Catcher in The Rye"></category><category term="review"></category></entry><entry><title>学习 OFDM 及其 FPGA 实现 1 —— OFDM Basic</title><link href="http://guqian110.github.io/pages/2014/05/13/learning_ofdm_on_fpga_1_ofdm_basic.html" rel="alternate"></link><updated>2014-05-13T23:16:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-13:pages/2014/05/13/learning_ofdm_on_fpga_1_ofdm_basic.html</id><summary type="html">&lt;h2&gt;Why OFDM&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;移动通信的信道模型一般建立为 &lt;strong&gt;时变多径信道模型&lt;/strong&gt;，描述信道多径时延特性的一个重要统计参量是 &lt;strong&gt;均方根时延扩展&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;经过无线信道的时变多径传输，接收到的信号幅度会有起伏变化（瑞利分布 or 莱斯分布），这种现象称为 &lt;strong&gt;信号衰落&lt;/strong&gt; 。按照已调信号的带宽可以将衰落分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窄带信号受到 &lt;strong&gt;平坦性衰落&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;宽带信号受到 &lt;strong&gt;频率选择性衰落&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;判断信号受到何种衰落：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义信道的 &lt;strong&gt;相干带宽&lt;/strong&gt; 。当数字信号的带宽越小于信道的相干带宽，则经过时变多经信道后，在信号带宽内的不同频率分量的幅度的相关性越大，不同的频率分量近似经历相同的衰落，即平坦性衰落，平坦性衰落对接收信号的波形无明显影响，码间干扰可以忽略，该系统称为 &lt;strong&gt;窄带系统&lt;/strong&gt; 。当数字信号的带宽相对于信道的相干带宽越大时，信号带宽内的不同频率分量通过信道传输时会受到不同的衰落，即频率选择性衰落，频率选择性衰落使信号中的不同频率分量产生不同的幅度变化，造成接收信号的严重失真，引起吗见干扰，产生误码，该系统称为 &lt;strong&gt;宽带系统&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3&gt;Problem&lt;/h3&gt;
&lt;h4&gt;需求&lt;/h4&gt;
&lt;p&gt;无线信道的频率资源是有限的，要求数字通信系统有效利用信道频带。希望数据传输速率越高越好。&lt;/p&gt;
&lt;h4&gt;瓶颈&lt;/h4&gt;
&lt;p&gt;在系统设计选择数字调制方式时，必须兼顾 &lt;strong&gt;频带利用率&lt;/strong&gt; 和 &lt;strong&gt;误码性能&lt;/strong&gt; 。在 AWGN 信道下，在满足误码性能的前提下，应该尽可能采用频带利用率高的数字调制方式。&lt;/p&gt;
&lt;p&gt;然而，在以衰落为特征的移动通信系统中，影响误码性能的不仅仅是 &lt;strong&gt;加性噪声&lt;/strong&gt;，还包括 &lt;strong&gt;衰落&lt;/strong&gt; 和 &lt;strong&gt;码间干扰&lt;/strong&gt; 。实现高速无线通信并非易事。&lt;/p&gt;
&lt;p&gt;为避免码间干扰，数字调制信号的最大符号速率受到很大的限制 。&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;信道均衡&lt;/strong&gt; 是一种经典的对抗码间干扰的技术，许多移动通信系统都采用信道均衡技术消除码间干扰。但是如果数据速率非常高，采用单载波传输数据，需要设计几十审计上百个抽头的均衡器，这简直是硬件设计的噩梦 。&lt;/p&gt;
&lt;p&gt;既要对抗码间干扰，又要满足低复杂度且高效的手段传输高速数据业务，我们可以采用另外一种技术 —— &lt;strong&gt;OFDM&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;OFDM History&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;多载波调制技术早在 20 世纪 50年代末至 60 年代初就已经应用于军事高频无线通信中，由于实现复杂，没有被广泛应用 。OFDM 就是一种多载波调制，其子载波间隔是子载波符号间隔的倒数，各子载波的频谱是重叠的，这种重叠可以使频谱效率显著提高 。&lt;/p&gt;
&lt;p&gt;20 世纪 70 年代，Weinstein 和 Ebert 提出用 &lt;strong&gt;离傅里叶变换(DFT)&lt;/strong&gt; 及其 &lt;strong&gt;逆变换(IDFT)&lt;/strong&gt; 进行 OFDM 多载波调制方式的运算。&lt;/p&gt;
&lt;p&gt;DFT 和 IDFT 的快速计算方法：FFT 和 IFFT 使 OFDM 能够以低成本的数字方式实现 。&lt;/p&gt;
&lt;p&gt;在 20 世纪 80 年代，随着 OFDM 理论的不断完善、数字信号处理及微电子技术的不断快速发展，OFDM 技术也逐步走向实用化 。&lt;/p&gt;
&lt;p&gt;大约从 20 世纪 90 年代起，OFDM 技术开始应用于各种有线及无线通信中，包括：DSL、DAB、DVB、WLAN等。OFDM 已经成为下一代蜂窝移动通信空中接口的候选技术 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;OFDM Theory&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Orthogonal frequency-division multiplexing (OFDM) 的基本原理是将高速的数据流分解为多路并行的低速数据流，在多个载波上同时进行传输。&lt;/p&gt;
&lt;p&gt;通过将高速数据分解为多个并行低速速率，克服了信道时延扩展对数据速率的限制，其中各个子载波之间是相互正交的关系，如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="carrier wave" src="/images/learning-ofdm-basic/carriers.png" /&gt;&lt;/p&gt;
&lt;p&gt;OFDM 每个子载波的调制方式可以相互不同，比如 BPSK、QPSK、QAM 等方式 。&lt;/p&gt;
&lt;p&gt;(OFDM 系统的内容可以写一本书了，简单写写 :-P )&lt;/p&gt;
&lt;h3&gt;OFDM 基带数字实现&lt;/h3&gt;
&lt;h4&gt;发送端 Transmitter&lt;/h4&gt;
&lt;p&gt;基带系统发送端要实现的功能是将待发送序列 {A1,A2,A3...} 变换，得到复包络的采样值 {a1,a2,a3...} 。&lt;/p&gt;
&lt;p&gt;为了实现 OFDM 调制的基带数字实现，首先要将 OFDM 信号的复包络进行采样，成为离散时间信号 。根据公式(《通信原理》)，采样结果正好是对发送序列进行离散傅里叶反变换(IDFT)的结果，所以，我们可以 &lt;em&gt;借助 IDFT 即可得到 OFDM 复包络的时间采样 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;发送端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="transmitter" src="/images/learning-ofdm-basic/transmitter.png" /&gt;&lt;/p&gt;
&lt;h4&gt;接收端 Receiver&lt;/h4&gt;
&lt;p&gt;基带系统接收端要实现的功能是对采样序列 {a1,a2,a3...} 进行变换，得到发送端发送过来的信息序列 {A1,A2,A3...} 。&lt;/p&gt;
&lt;p&gt;接收端通过 I/Q 正交解调可以恢复 OFDM 信号的复包络，将其采样得到的时间序列 。因为发送端采用的 IDFT 是可逆变换，所以对采样结果进行 DFT 就可以得到发送序列 。&lt;/p&gt;
&lt;p&gt;当序列的点数为 2 的整幂次时，DFT 和 IDFT 存在快速算法： FFT 和 IFFT 。&lt;/p&gt;
&lt;p&gt;接收端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="receiver" src="/images/learning-ofdm-basic/receiver.png" /&gt;&lt;/p&gt;
&lt;h3&gt;循环前缀 cyclic prefix&lt;/h3&gt;
&lt;p&gt;为了有效对抗多径信道的时延扩展，OFDM 系统由多个子载波构成，只要子载波的取值可以满足符号周期远大于信道的时延扩展，就可以达到目标。在此基础上，还需要采取措施消除前后两个 OFDM 符号之间的 &lt;strong&gt;码间干扰 ISI&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;一种方法是在每个 OFDM 符号之间插入 &lt;strong&gt;保护间隔 Guard Interval&lt;/strong&gt; 。为了对抗信号因信道延迟的影响，Gurad interval(Tg) 长度要大于最大的 Delay spread，即 Tg &amp;gt; delay spread time。&lt;/p&gt;
&lt;p&gt;在保护区间未放信号的 OFDM 系统称 ZP-OFDM(zero padding)。ZP-OFDM 有比较低的传输功率，但在接收端接收于 zero padding 区域信号时，会破坏载波的正交性造成 “&lt;strong&gt;载波间的干扰（ICI）&lt;/strong&gt;”，所以复制 OFDM symbol 后半段信号并摆放于保护区间内，称之为 &lt;strong&gt;循环字首(cyclic prefix)&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3&gt;加窗技术&lt;/h3&gt;
&lt;p&gt;前面介绍了 OFDM 符号的生成、循环前缀消除码间干扰，但是此时符号边界有尖锐的相位跳变，由此可知，OFDM 的带外衰减是比较慢的 。虽然随着载波数目的增大，OFDM 信号的带外衰减会增加，但是仍然不够快 。&lt;/p&gt;
&lt;p&gt;为了使 OFDM 信号的带外衰减更快，可以采用对单个 OFDM 符号加窗的方法 。OFDM 的窗函数可以使信号的幅度在u符号边界更平滑地过渡到 0 。常用的窗函数是 &lt;strong&gt;升余弦滚降窗&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;增大滚降因子虽然能够使带外衰减更快，但降低了 OFDM 系统对多经实验的容忍能力，所以 &lt;em&gt;在实际系统设计中，应当选择较小的滚降因子 。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;OFDM 系统设计&lt;/h3&gt;
&lt;p&gt;OFDM 系统框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ofdm-system" src="/images/learning-ofdm-basic/ofdm_system.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;交织&lt;/strong&gt; 是为了克服深衰落发生突发差错的影响，如果交织器的长度足够大，解交织后可将突发差错改造为独立差错，再通过纠错译码来纠正 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在发送端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;二进制数据&lt;/em&gt; 通过纠错编码、交织后映射到 QAM 星座得到 &lt;em&gt;一个 QAM 复数符号序列&lt;/em&gt;，再经过并串转换，得到 &lt;em&gt;N个并行 QAM 符号&lt;/em&gt;，每个符号进行 IFFT，将 OFDM 复包络的频域样值变换为 &lt;em&gt;时域样值&lt;/em&gt;，进行并串转换，将时域样值变换为按时间顺序排列的 &lt;em&gt;时域样值&lt;/em&gt;，然后在每个 OFDM 符号前插入前缀，通过 D/A，将离散的复包络变成 &lt;em&gt;连续时间的复包络&lt;/em&gt; 。再将复包络的 I(t) 和 Q(t) 正交调制得到 &lt;em&gt;OFDM信号&lt;/em&gt;，将基带信号上变频到射频，经过功放，发送出去 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在接收端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端于发送端进行相反的变换，恢复出原数据 .&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;《通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4130536/"&gt;《移动通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Orthogonal_frequency-division_multiplexing"&gt;OFDM wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="OFDM"></category></entry><entry><title>Yocto 从零单排 1 —— 入门</title><link href="http://guqian110.github.io/pages/2014/05/12/learning_yocto_from_zero_1_getting_started.html" rel="alternate"></link><updated>2014-05-12T12:46:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-12:pages/2014/05/12/learning_yocto_from_zero_1_getting_started.html</id><summary type="html">&lt;p&gt;最近做嵌入式，开始学习 Yocto 项目相关的知识。网上关于 Yocto 的介绍、博客不少，但是大多数都是英文的。中文博客也有，不过都是一些大牛写的笔记，对于新手来说，并不是很容易懂,于是，就有了我的 “Yocto 从零单排” ^_^&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yocto 从零单排第 1 期 —— 入门，了解什么是 Yocto&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习一个新事物，当然是官网的东西最权威最简洁明了，不易出错（避免二次理解），以下内容来自 &lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto 官网&lt;/a&gt; 和对其的翻译，本文只是我的学习笔记，详细内容见官网：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto Project 官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;What &amp;amp; Why Yocto&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;What is Yocto&lt;/h3&gt;
&lt;p&gt;官网上的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The Yocto Project is an open source collaboration project that provides templates, tools and methods to help you create custom Linux-based systems for embedded products regardless of the hardware architecture. &lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 &lt;em&gt;“Yocto 是一个开源协作项目，它通过提供模板、工具和方法来帮助开发者为嵌入式产品订制基于 LInux 的系统，而不用关注硬件结构。”&lt;/em&gt; 这样，它就可以极大地简化开发过程，因为你不用再从头裁剪一个完整的Linux发布版本，后者通常包括许多你并不需要的软件。&lt;/p&gt;
&lt;p&gt;它由许多硬件制造商、开源操作系统提供商和电子器件公司一起合作于 2010 年建立，目的是为了使混乱的嵌入式 Linux 开发更简单有序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; Yocto 项目有时也被称为 "Umbrella" 项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.P.S.&lt;/strong&gt; yocto 的名字是委员会决定的，这个词本来是国际单位中的最小的单位，表示 10^-24，也就是千万亿分之一，在此寓意 “基本的粒子” —— 贯穿嵌入式 Linux 开发过程的工具。&lt;/p&gt;
&lt;h3&gt;Why using Yocto&lt;/h3&gt;
&lt;p&gt;它是一个完整的嵌入式 Linux 开发环境，包含工具(tools)、元数据(metadata)和文档(documentation)——你需要的一切。这些免费工具(包含仿真环境emulation environments、调试器debuggers、应用程序开发工具Application Toolkit Generator)很容易上手，功能强大，并且它们可以让系统开发以最优化的方式不断前进，而不用担心在系统原形阶段的投资损失。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Yocto Project Charter&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Yocto 作为一个开源项目，其本质就是欢迎大大小小的参与者。&lt;/p&gt;
&lt;p&gt;Yocto 的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为进一步的开发、定制 LInux 平台，基于 Linux 系统的开发提供一个写作平台&lt;/li&gt;
&lt;li&gt;鼓励 Linux 平台开发的标准化和组建的重利用&lt;/li&gt;
&lt;li&gt;专注于创造一个构建系统的基础设施和技术，能够满足所有用户的需求，并增加了缺失的功能——来自于 OpenEmbedded 架构&lt;/li&gt;
&lt;li&gt;文档化可以用到的工具和方法，使开发人员更容易使用它们&lt;/li&gt;
&lt;li&gt;尽可能地保证这些开发工具和系统架构无关&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Governance &amp;amp;  Administration&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Yocto 是一个开源项目，它由维护者和 &lt;a href="(https://www.yoctoproject.org/about/governance/advisory-board)"&gt;Yocto Project Advisory Board&lt;/a&gt; 领导。&lt;/p&gt;
&lt;h3&gt;Technical Leadership&lt;/h3&gt;
&lt;p&gt;Yocto 项目的 &lt;a href="(https://www.yoctoproject.org/about/governance/technical-leadership)"&gt;technical leadership&lt;/a&gt; 和 Linux Kernel 的类似，是一个分级的、任人唯贤的，由一个 “仁慈的独裁者”(benevolent dictator) 领导的组织。组织的上层负责决策，同时也是下层子系统的领导者，下层维护者负责处理细节问题，比如bug 和补丁。&lt;/p&gt;
&lt;p&gt;Yocto 项目架构师：Richard Purdie&lt;/p&gt;
&lt;p&gt;子系统/ BSP 层维护者：...&lt;/p&gt;
&lt;h3&gt;The Yocto Project Community&lt;/h3&gt;
&lt;p&gt;Yocto 是由社区的专家和志愿者共同协助设计、开发的，他们统称为贡献者(contributors)，贡献者包括任何可能对 Yocto 有贡献的人，比如代码开发人员、文档编写者、兴趣小组、管理小组、维护者和技术领导小组等。&lt;/p&gt;
&lt;p&gt;下图简明说明了 Yocto 项目社区的各个成员之间的相互影响的关系：&lt;/p&gt;
&lt;p&gt;&lt;img alt="yocto-community" src="https://www.yoctoproject.org/sites/yoctoproject.org/files/page/os63yoctodev.org-diagramv11.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Linux Foundation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="(http://www.linuxfoundation.org/)"&gt;Linux Foundation&lt;/a&gt; 是一个致力于促进 Linux 发展的非盈利组织，关于它的主要事实：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赞助 Linux 的创造者 Linus Torvalds 的工作&lt;/li&gt;
&lt;li&gt;持有 Linux 商标&lt;/li&gt;
&lt;li&gt;经营着 Linux.com，每个月拥有活跃的 2000,000 的 Linux 开发人员和用户 &lt;/li&gt;
&lt;li&gt;主持着多个推进或标准化 Linux 的工作小组&lt;/li&gt;
&lt;li&gt;举行世界上顶尖的 Linux 会议，包括 LinuxCon&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The Linux Foundation and the Yocto Project&lt;/h3&gt;
&lt;p&gt;Linux Foundation 是业界最大的非盈利组织，作为 Linux 的维护者和 Linux 创造者 Linus Torvalds 的雇主，没有比它更适合 Yocto 项目生存的了。Linux Foundation 主持 Yocto 项目作为一个开源项目，它提供了一个厂商中立的协作环境。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Yocto Project 简介&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Yocto 项目中有很多独立的子项目，这些子项目在嵌入式 Linux 开发中扮演着重要的角色，Yocto 项目则整合它们使它们可以相互协同工作。&lt;/p&gt;
&lt;h3&gt;Openembedded Core&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Metadata Set&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;元数据集(Metadata Set) 按 "层" 进行排列，这样一来每一层都可以为下面的层提供单独的功能。基层是 OpenEmbedded-Core 或 oe-core，提供了所有构建项目所必需的常见配方(recipes)、类和相关功能。&lt;/p&gt;
&lt;p&gt;Openembedded Core 包含了 核心方法(recipes)的基础层、类(classes) 和 相关文档，它们是各种嵌入式 Linux 系统(包含 Yocto 在内)的共同基础。Openembedded Core 由 Yocto Project 和 OpenEmbedded 项目共同维护，将 Yocto 和 Openembedded 分开的层是 meta-yocto 层，该层提供了 Pocky 发行版配置和一组核心的参考BSP。&lt;/p&gt;
&lt;p&gt;Openembedded 项目本身是一个ie独立的开源项目，具有可与 Yocto 项目交换的配方(recipes)，但两者具有不同的治理和范围。&lt;/p&gt;
&lt;h3&gt;Swabber&lt;/h3&gt;
&lt;p&gt;Swabber 可以提供一种检测主机系统的机制，一旦检测到问题，你就可以分析这是否真的是个问题。&lt;/p&gt;
&lt;h3&gt;Application Development Toolkit (ADT)&lt;/h3&gt;
&lt;p&gt;Application Development Toolkit (ADT) 能够让系统开发人员为他们使用 Yocto Project 工具创建的发行版提供软件开发工具包 (SDK)，为应用程序开发人员提供了一种针对系统开发人员提供的软件栈进行开发的方法。ADT 包含一个交叉编译工具链、调试和分析工具，以及 QEMU 仿真和支持脚本。ADT 还为那些喜欢使用集成开发环境 (IDE) 的人提供了一个 Eclipse 插件。&lt;/p&gt;
&lt;h3&gt;AutoBuilder&lt;/h3&gt;
&lt;p&gt;AutoBuilder 是一款能够不断自动构建 Yocto 的工具，它启用自动化的 Quality Assurance(QA) 活动。&lt;/p&gt;
&lt;h3&gt;BitBake&lt;/h3&gt;
&lt;p&gt;BitBake 是一个构建引擎。它读取配方(recipes)并按照配方来获取、构建程序包，并将结果导入可启动的系统映像中。BitBake 是 Yocto 项目的核心组件。&lt;/p&gt;
&lt;h3&gt;Build Appliance&lt;/h3&gt;
&lt;p&gt;Build Applicance 是一台运行 Hob 的虚拟机，它可以让你在非 Linux 环境下构建启动一个基于 Yocto 的嵌入式系统镜像。并不建议在日常开发中使用 Build Applicance，应该将其用在测试和体验 Yocto 项目上。&lt;/p&gt;
&lt;h3&gt;Cross-Prelink&lt;/h3&gt;
&lt;p&gt;Cross-Prelink 为交叉编译开发环境提供预链接，这样可以在应用程序启动时提高其性能表现。&lt;/p&gt;
&lt;h3&gt;Eclipse IDE Plug-in&lt;/h3&gt;
&lt;p&gt;Eclipse IDE Plug-in 把 Yocto ADT 和工具链集成到 Eclipse IDE 中。&lt;/p&gt;
&lt;h3&gt;EGLIBC&lt;/h3&gt;
&lt;p&gt;Embedded GLIBC (EGLIBC) 是 GNU C Library (GLIBC) 的一个变体，旨在能够在嵌入式系统上运行。EGLIBC 的目标包括减少内存占用、让组件可配置、更好地支持交叉编译和交叉测试。EGLIBC 是 Yocto Project 的一部分，但在它自己的治理结构内加以维护。&lt;/p&gt;
&lt;h3&gt;Hob&lt;/h3&gt;
&lt;p&gt;Hob 是 BitBake 的图形前端，它的主要目的是使常用命令更加方便使用。&lt;/p&gt;
&lt;h3&gt;Matchbox&lt;/h3&gt;
&lt;p&gt;Matchbox 是 一个基于 X Window 系统的开源环境，主要用于非桌面系统、屏幕大小、输入方式或系统资源有限的嵌入式设备中，比如手持设备、机顶盒、电话亭等。&lt;/p&gt;
&lt;h3&gt;Poky&lt;/h3&gt;
&lt;p&gt;Poky 是 Yocto Project 的一个参考构建系统。它包含 BitBake、OpenEmbedded-Core、一个板卡支持包 (BSP) 以及整合到构建过程中的其他任何程序包或层。Poky 这一名称也指使用参考构建系统得到的默认 Linux 发行版，它可能极其小 (core-image-minimal)，也可能是带有 GUI 的整个 Linux 系统 (core-image-sato)。&lt;/p&gt;
&lt;p&gt;你可以将 Poky 构建系统看作是整个项目的一个参考系统，即运行中进程的一个工作示例。在下载 Yocto Project 时，实际上也下载了可用于构建默认系统的这些工具、实用程序、库、工具链和元数据的实例。这一参考系统以及它创建的参考发行版都被命名为 Poky。你还可以将此作为一个起点来创建您自己的发行版，当然，你可以对此发行版随意命名。&lt;/p&gt;
&lt;p&gt;构建一个系统必须有工具链(toolchain)：一个编译器(compiler)、汇编器(assembler)、链接器(linker)以及为给定架构创建二进制可执行文件所需的其他二进制实用程序(other binary utilities)。Poky 使用了 GNU Compiler Collection (GCC)，不过你也可以指定其他工具链。Poky 使用了一种名为交叉编译(cross-compilation) 的技术：在一个架构上使用工具链为另一个架构构建二进制可执行文件（例如，在基于 x86 的系统上构建 ARM
发行版）。开发人员常常在嵌入式系统开发中使用交叉编译来利用主机系统的高性能。&lt;/p&gt;
&lt;h3&gt;Pseudo&lt;/h3&gt;
&lt;p&gt;构建一个系统时，有时候有必要把自己模拟为系统管理员进行一些操作，比如定义某个文件的归属权和权限配置等。Pseudo 是一个可以模拟 root 的程序，使普通用户也可以具有 root 权限。&lt;/p&gt;
&lt;h3&gt;Toaster&lt;/h3&gt;
&lt;p&gt;Toaster 是一个 API，它基于 web 界面来使用 BitBake，你可以通过浏览器来查阅 Toaster 收集到的你的系统的相关信息。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto Project 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/linux/library/l-yocto-linux/index.html?ca=dat"&gt;Build custom embedded Linux distributions with the Yocto Projec&lt;/a&gt;&lt;/p&gt;</summary><category term="Yocto"></category></entry><entry><title>我的 PKM</title><link href="http://guqian110.github.io/pages/2014/05/06/my_pkm.html" rel="alternate"></link><updated>2014-05-06T15:57:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-06:pages/2014/05/06/my_pkm.html</id><summary type="html">&lt;h2&gt;PKM&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;什么是 PKM&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;个人知识管理(Personal Knowledge Management)是一种新的知识管理的理念和方法，能将个人拥有的各种资料、随手可得的信息变成更具价值的知识，最终利于自己的工作、生活。通过对个人知识的管理，人们可以养成良好的学习习惯,增强信息素养，完善自己的专业知识体系,提高自己的能力和竞争力，为实现个人价值和可持续发展打下坚实基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知乎上的&lt;a href="http://www.zhihu.com/question/19576595"&gt;回答&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个人知识管理的概念最早是由Paul Dorsey教授提出的,原文为” Personal Knowledge Management should be viewed as a set a problem-solving skills that have both a logical or conceptual as well as physical or hands-on component. ”,中文意思就是: 个人知识管理应该被看作既有逻辑概念层面又有实际操作层面的一套解决问题的技巧与方法。所以个人知识管理主要讲的是一种方法论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Personal_knowledge_management"&gt;Personal knowledge management on wikipedia&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;为什么写这篇 blog&lt;/h3&gt;
&lt;p&gt;从小到大，上了这么多年的学，每个人都有自己的学习习惯和知识管理方法。这篇 blog 是在我 Google、知乎问答、参考相关博客内容的基础上，总结出的学习习惯和使用各种工具的经验，写这篇博客的目的不是秀逼格有多高（估计很多人都看不上），也不是所谓的教程（根本不够资格），而是&lt;strong&gt;为了分享和讨论&lt;/strong&gt; :-D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;获取知识&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;总结我的知识来源，大致可以分为 3 类：纸质书籍、网络资源、其他 。分别总结如下&lt;/p&gt;
&lt;h3&gt;书籍&lt;/h3&gt;
&lt;p&gt;书籍上的知识占到了我总来源的 50% 。相比于电子读物，我更喜欢阅读纸质书籍。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;纸质书籍更适合深度阅读&lt;/p&gt;
&lt;p&gt;这就是为什么很多码农桌子上都有那么几本经典著作，虽然他们的电脑里面也保存着相应的电子版。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纸和笔是最原始的阅读工具，但是也是最有效，或者 &lt;em&gt;最自由的&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是目前电子书籍/笔记最大的缺点，写一段标注文字，画一个草图，列一个表格，插入一个公式，不仅需要花费很多时间，而且操作很繁琐，结果也往往差强人意 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阅读体验&lt;/p&gt;
&lt;p&gt;毫无疑问纸质书籍的阅读体验更好一些，不然 Kindle 也就不会出现了 :-D&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于读书笔记，我的方法很原始 =.=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;书边笔记，这样笔记和书是一体的，如果空白不够大，有便利贴&lt;/li&gt;
&lt;li&gt;标记符号，简单的标记，比如 &lt;code&gt;？&lt;/code&gt; 表示疑问、&lt;code&gt;！&lt;/code&gt; 表示注意、&lt;code&gt;||&lt;/code&gt; 表示分层、&lt;code&gt;*&lt;/code&gt; 表示重要内容、圈出关键名词/定义 etc&lt;/li&gt;
&lt;li&gt;整理笔记，定期将书本上的笔记整理到 Blog / Evernote 中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;网络&lt;/h3&gt;
&lt;p&gt;互联网时代，善于利用互联网上的资源，相当于守着一座 “知识金山”&lt;/p&gt;
&lt;p&gt;每天面对海量的信息，如果不加以过滤，我们就会被淹没在信息的海洋之中，浪费了大量时间而毫无收益。我的信息来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RSS 订阅&lt;/p&gt;
&lt;p&gt;以前使用 Google Reader，自从 GR 死了之后，转到了 &lt;a href="http://cloud.feedly.com"&gt;Feedly&lt;/a&gt; 。主要是搜集一些大牛的博客，订阅 &lt;em&gt;真正&lt;/em&gt; 感兴趣的内容。&lt;/p&gt;
&lt;p&gt;RSS 订阅是个时间黑洞，曾经我的 RSS 订阅长期 1000+，而且我从来没有看完过，作为处女座强迫症患者，有时候花费了很多时间，甚至占用上课学习时间。后来看到 &lt;a href="http://mindhacks.cn/"&gt;刘未鹏&lt;/a&gt; 在 &lt;a href="http://book.douban.com/subject/6709809/"&gt;《暗时间》&lt;/a&gt; 中有一篇文章讲自己的学习习惯，才明白原来这是源自人不肯 “关上一扇门” 的心理。&lt;strong&gt;事实上，真正宝贵的信息，在其他来源你也可以接触到。&lt;/strong&gt;于是，我退订了很多从来不看或者很少看的源，从此，告别阅读焦虑。:-D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Google / Wiki&lt;/p&gt;
&lt;p&gt;拒绝做伸手党，我们遇到的很多问题实际上别人都遇到过了，并且提供了解决方法。在网上发帖问别人的时候，很多问题都可以从 FAQ、官方文档中都能找到答案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知乎 / Quora / Stack Overflow&lt;/p&gt;
&lt;p&gt;这绝对是一个值得一生相伴的好东西 :-P 长期混迹于此，瞬间高大上的境界、令人仰视的逼格不再是梦想，相信我，你的人生因此而改变！（利益相关：非广告，深度沉迷者）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;论坛 / 豆瓣小组&lt;/p&gt;
&lt;p&gt;当然是讨论知识的论坛，而非八卦娱乐主题的论坛。长期泡论坛，不仅可以寻找答案，帮助别人，还可以扩展自己的见识，结识大牛，论坛里面的老油条个个都是大神。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用到的工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://cloud.feedly.com"&gt;feedly&lt;/a&gt; 是一款 RSS 阅读器&lt;/p&gt;
&lt;p&gt;同类产品还有很多，比如国外的 Diggo、国内的鲜果、豆瓣九点等 。feedly 在国内访问并不是很稳定，即使这样，我仍然选择它是因为舒服的排版、另外功能上有些源 Diggo 无法抓取到 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://getpocket.com/a/"&gt;pocket&lt;/a&gt; 是一个用于管理互联网文章的应用程序&lt;/p&gt;
&lt;p&gt;PC 上有 chrome 插件，手机上也有相应的客户端，这样我们就可以很方便地在各个平台上、把各个源的文章都收集到一起，稍后阅读（比如排队、休息时）。&lt;/p&gt;
&lt;p&gt;我还它当作汇聚资料的容器使用，比如我写这篇博客，从网上搜集到很多相关内容，把我认为重要的保存在 pocket 当中，然后再做整理 。&lt;/p&gt;
&lt;p&gt;P.S. 还有另外一个方法，feedly 上的文章可以直接保存到 Evernote 中，但是这是付费功能，虽然可以用 ifttt 解决，但是这种方法无法收集其他地方的文章，而且，不知道是不是因为天朝的原因，ifttt 收集的速度并不快，一般要 30 分钟左右才能在 Evernote 中看到收集的文章，最重要的一点，在 Evernote 中看文章，眼睛一直盯着屏幕的右下角，都快成斜眼了 T_T，so 还是 pocket 好！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;p&gt;所谓其他，就是在其它地方，看到的、想到的，使用手机肯定是最方便的。我只使用过两款应用 Google Keep 和 Evernote 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/Google_Keep"&gt;Google Keep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 发布的笔记软件，和其他各种笔记类软件相比，Keep 的功能实在是 “弱爆了”，或许称之为 &lt;em&gt;便签 sticker&lt;/em&gt; 更合适 .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://evernote.com"&gt;Evernote&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大名鼎鼎的笔记软件，功能非常强大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有很多人把这两个软件做比较&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20869752"&gt;Google Keep VS Evernote，你还会继续使用 Evernote 吗？为什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20859926"&gt;刚宣布 Reader 关停，Google Keep 随即上线，这是用来跟 Evernote 竞争的产品吗？谷歌做这个有什么优势？谷歌如何让用户有安全感地放心使用旗下产品？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;事实上，这两个产品的定位根本就不一样，引用里面的某个答案&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Keep 偏重于随时随地记录碎片知识, 建立待办事项, 是个效率工具.完成的事情就随手一滑存档掉, 并没有提供更一步的存储整理的途径. 所以 &lt;strong&gt;Google Keep并不是知识的终点&lt;/strong&gt;,它只是用来记录临时想法的,这恰恰和它的logo形象十分契合(想想卡通里面人物突然奇思妙想了...灯泡就亮了- -). 它就是用来存储这些"灯泡"的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般，我使用 Keep 来记录平时的想法，也把它当作便签来使用，记录杂事，有部分 to-do-list 的作用。毕竟，Evernote 缓慢的启动速度和不方便的操作实在是太影响心情了 。&lt;/p&gt;
&lt;p&gt;还有一个答案，不能同意更多：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;归根到底，&lt;strong&gt;keep是一个轻量级GTD系统，它要解决的问题和evernote是不同的。那些认为keep可以取代evernote的用户，他们本身就不需要evernote&lt;/strong&gt; ——对他们而言，evernote的强大反而太过繁冗，已是多余。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;整理知识&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;获取到知识，下一步就是整理和吸收它们了。&lt;/p&gt;
&lt;h3&gt;Evernote&lt;/h3&gt;
&lt;p&gt;说道 PKM，就不得不提 Evernote 。这么一款大名鼎鼎的笔记软件，有很多人在使用，分享使用技巧 。搜集到一个很全的资源帖：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.douban.com/group/topic/28544265/"&gt;印象笔记 Evernote 教程 (douban)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面总结了官方的教程、民间高手的使用心得。基本上花费一下午的时间在豆瓣 &amp;amp; 知乎上逛一逛，就可以成为高手了 。&lt;/p&gt;
&lt;p&gt;我不是 EN 的高级用户，也没有专门去探索进阶用法，我只是把它当作单纯的电子笔记本，不代替便签（Google Keep），也不代替知识管理软件（Wiz、OneNote），一般也就以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存博客草稿，毕竟 Keep 这样的便签不适合于写大段文字&lt;/li&gt;
&lt;li&gt;记录私人笔记&lt;/li&gt;
&lt;li&gt;摘抄网络上的精彩内容（也是为写 blog 服务），EN 在 chrome 上的 web clipper 插件真心不错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;忍不住跑题说一下我的使用感受：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：全平台、全功能、云同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：大而无当，这是一款变形金刚一样的软件，功能强大到有人为此写出一本厚厚的&lt;a href="http://book.douban.com/subject/24524405/"&gt;使用教程&lt;/a&gt; 。但是，强大的功能也就意味着软件的笨重和操作的繁琐。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和便签类应用相比&lt;/p&gt;
&lt;p&gt;它太笨重了！ 与 Keep 简洁的操作（快速新建、左右滑动归档、撤销），这货简直慢的让人无法忍受。知乎上有个贴子专门讨论这个问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20820355"&gt;为什么有人对印象笔记没有任何兴趣呢？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中有个回答，也是我的感受：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你明知道它的功能正是你需要的，但打開它就是不想用，也不知道從何用起。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和知识管理类应用相比&lt;/p&gt;
&lt;p&gt;仅个人意见，EN 并不适合作知识管理 。它只有 笔记本 和 笔记本组 这两个概念，也就是说，它最多支持 2 级目录，而实际上，我们的知识体系应该是和树一样，不断地分支增长的 。其他笔记类应用比如 Wiz 笔记就要比它好很多 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 我曾经也为用 Keep 还是 EN 纠结过，最终我选择了 Keep，直到后来我看到这句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那些认为keep可以取代evernote的用户，他们本身就不需要evernote&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我才明白，我根本就不需要 EN！我曾经尝试过在 EN 中建立一个完备正交的目录，后来发现，其中最重要的部分和我的博客目录是一模一样的 。我已经有个博客了，为什么还要 EN 呢？（个人认为 blog 比 EN 更好，原因后文解释）&lt;/p&gt;
&lt;p&gt;事实上很多人根本就没有管理知识的必要，因为他们没有那么多知识需要整理。使用 Evernote 的动机无非就是人类的天性 ——“收藏” 癖好，看到什么东西都想收藏，比如用过的袋子，小本子，现在轮到网页，图片，链接了。可是我们收藏了以后还会去看么？就像我们硬盘里面收集的 “世界一百部名著” 一样，它静静地躺在硬盘中，积累了厚厚的灰 。&lt;/p&gt;
&lt;p&gt;EN 的 logo 是一只大象，寓意来自美国谚语 “An elephant never forgets”，大象的记忆力很强，这和它的宣传 “Evernote 是你的第二个大脑” 是一致的，而且是一个永远不会忘记的大脑。&lt;/p&gt;
&lt;p&gt;所以，为什么不就这么用呢？在 EN 中新建几个笔记本，把我们不需要记住但是以后可能会用到的 “知识” 丢进去，加上简单的标签，然后我们只需要记住在笔记里有这么个记录，然后其他的全都可以忘掉了，需要的时候去搜索一下就可以了。利用它强大的接口功能，记录杂事、美食、私人日记、生活小感悟、小常识，但是对于体系结构化的知识，个人认为写一个技术博客是更优的选择（理由在后文） :-P&lt;/p&gt;
&lt;p&gt;漫长的跑题终于结束了，总之就是，&lt;strong&gt;把 EN 当作收集小知识的笔记本即可，个人知识管理选择其他软件/写博客是更优的选择。给它做做减法，使用你需要的功能，不要成为工具的奴隶。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;XMind&lt;/h3&gt;
&lt;p&gt;目前还处于用笔和纸的阶段，大概了解了一些 XMind 的用途，感觉很好很强大。尤其是用它建立的结构化的提纲，对于整理文章、知识体系结构有巨大的帮助。还在探索中，更加进阶的功能和使用心得以后再总结。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;使用/分享知识&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;月光博客中的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知识共享和传播，是为了让别人知道你知道的知识，并得到信息的反馈，为什么要分享，不在于你认识什么人，而在于什么人认识你，不在于什么人影响了你，而在于你影响了什么人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获取、整理知识，接下来就是使用/分享知识。只有把别人的东西转化为自己的，才算是掌握了。我觉得最好的方法就是写 Blog。&lt;/p&gt;
&lt;h3&gt;为什么要写 Blog&lt;/h3&gt;
&lt;p&gt;这个问题曾经我也问过自己，以前只是看到学长学姐们写的 Blog，感觉很厉害，认为自己也应该有这样一个。后来看到 &lt;a href="http://book.douban.com/subject/6709809/"&gt;暗时间&lt;/a&gt; 里面的两篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/"&gt;《书写是为了更好的思考》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/"&gt;《为什么你从现在开始就应该写博客》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;认真总结了一下写博客的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;总结知识&lt;/p&gt;
&lt;p&gt;这是我写 Blog 最直接的一个动机。只有把别人的东西转化为自己的，才算是真正掌握了。记录下自己某段时间的学习收获，思考感悟，不仅可以帮助自己回忆以前的知识，说不定还可以帮助到别人（我就是受益者，从别人的博客中学习到了很多知识）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;帮助思考&lt;/p&gt;
&lt;p&gt;这是写 Blog 最大的好处。这个好处不仅仅局限于写 Blog 这种形式，无论以什么方式，只要写下你的思考过程和内容，就可以帮助你思考问题，也就是 &lt;strong&gt;书写&lt;/strong&gt; 的好处。&lt;a href="http://book.douban.com/subject/6709809/"&gt;《暗时间》&lt;/a&gt; 里面有个很形象的比喻：&lt;em&gt;人的思考就像是在黑暗中打着手电筒前行。&lt;/em&gt;因为人的脑力资源是有限的，所以我们经常遇到想问题想岔了，然后回不到原点的情况。书写不仅可以帮助我们缓存手电筒照到的区域，还可以帮助我们扩大手电筒的照亮直径。比如我写这篇博客，开始只是记录下别人的 PKM 的方法和工具的关键字，然后在大纲和简记的基础上，补充自己的心得完成的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到交流帮助&lt;/p&gt;
&lt;p&gt;Blog 相比于 EN 的最大的优势。写 Blog 是开放的，别人可以随意看，而写 EN 我们只能自己看（EN 的共享笔记体验并不好）。每个人的思考都有盲点，你的盲点可以在别人那里得到补充，知识和思考在讨论得到提炼升华。&lt;/p&gt;
&lt;p&gt;还有一个好处是，敦促你必须认真思考。想象你在给一个玩偶小熊讲一个原理、技术，那么你必须 &lt;em&gt;“彻底反思整个知识体系，弄清这座大厦的根基在什么地方，弄清它的骨架在什么地方，一砖一瓦到底是怎么垒起来的。设想自己在 11 层，给处于 1 层的小熊讲明白一件事。”&lt;/em&gt; 现在你不需要小熊了，因为有更挑剔的的对手 —— 你的博客的读者。你偷懒不写/写出无意义的文章，他们不会像小熊一样包容你，只有写出高质量的博客才对得起观众，否则就是浪费他们的时间了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锻炼心智&lt;/p&gt;
&lt;p&gt;激励你去坚持学习和思考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了让你的博客有价值，你必须不断地总结自己学习的结果，比必须不断思考，给出比别人深刻、读到的见解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让你学会持之以恒地做一件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;理性地书写的时候，大脑逐渐进入推理分析模块，一切不愉快的情绪，烦躁感都会逐渐消隐下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述体验在写代码时也能体会到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锻炼文字功底&lt;/p&gt;
&lt;p&gt;对于码农，这算是优点么？反正没有坏处 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;写在最后&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;总结一下总的流程就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取知识&lt;/strong&gt;：书籍 + feedly + pocket + Google Keep&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整理知识&lt;/strong&gt;：Evernote + XMind&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 / 分享知识&lt;/strong&gt;：Blog&lt;/p&gt;
&lt;p&gt;总结出来并且在实际行动中加以利用才是王道。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sand-ox.com/2011/02/pkm-tools/"&gt;我，和我的知识工具们 (2011-02-15 更新)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.williamlong.info/archives/3388.html"&gt;我的知识管理工具列表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/topic/19557303"&gt;Evernote on zhihu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/topic/19558457"&gt;PKM on zhihu&lt;/a&gt;&lt;/p&gt;</summary><category term="PKM"></category></entry><entry><title>把时间当作朋友 书评</title><link href="http://guqian110.github.io/pages/2014/04/25/make_friends_with_time_review.html" rel="alternate"></link><updated>2014-04-25T15:50:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-25:pages/2014/04/25/make_friends_with_time_review.html</id><summary type="html">&lt;h2&gt;如梦初醒&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;突然发现自己已然变成了学校里面的老人，还有不多时日，就要离开在这片我生活了7年的土地，还来不及伤感，更多的是惊慌和不安 。从来没有这么感觉时间不够用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每天都在忙碌，但是不知道在忙碌什么；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;论文貌似总在和我捉迷藏，连影子都不显露；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静心思考自己的 “核心战斗力”。才发现自己还是当年的那个 “战五渣”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生活中有那么多美好的事物，等着我去发现、去体验，比如健身、阅读、骑行...还有写不完的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归结起来就是一句话：&lt;strong&gt;时间不够用&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;解决方法也很简单：&lt;strong&gt;管理时间&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;“管理时间” 这个话题当初我是如此的不屑，因为我 &lt;em&gt;自信&lt;/em&gt; 自己的自制力，现在看来，更确切的说法应该是我的 &lt;em&gt;自负&lt;/em&gt; 。亡羊补牢，为时未晚！于是，从豆瓣、大神们的博客上搜集到了几本书，甚至还有平时买书是赠送的 “心灵鸡汤” ...是时候认真规划一下了，学会管理时间 。&lt;/p&gt;
&lt;p&gt;暂时手头有以下几本书，后续还有很多计划看的书单 :-D（关于时间管理，正在学习ing，以后再总结）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3609132/"&gt;把时间当作朋友&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6709809/"&gt;暗时间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1958547/"&gt;How to Get Things Down&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523251/"&gt;超级时间整理术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;花费了将近两周的时间，在闲时看完了这本 《与时间做朋友》 。写写心得体会吧～&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;把时间当作朋友&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;关于作者 &lt;a href="http://lixiaolai.com/"&gt;李笑來&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先来点正面的：（&lt;a href="http://baike.baidu.com/view/664966.htm?fr=wordsearch"&gt;某度百科&lt;/a&gt;，没有搜到 wiki）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上大学学的是会计，出来做的却是销售。再后来加盟新东方，任教至今已有N年。其间学生数万。著有畅销 TOEFL 辅导书籍《TOEFL核心词汇21天突破》、《TOEFL高分作文》、《把时间当作朋友》、《SAT官方指南全程导学》、《新托福iBT词汇分类突破》，常年位于同类图书销售排行榜首。授课风格以朴实、有效为长。格外注重培养学生的独立思考能力，凡事都从独特的视角出发，而不限于书本知识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;李笑来最大的贡献是《TOEFL核心词汇21天突破》，这本词汇书里面的很多词汇出现的频率都很高，里面共有2140个单词，可以很快的背一遍然后重复很多遍，这样容你有时间把所有单词都记住；如果说背那种有10000多个单词的书恐怕难以坚持到最后。 因为这种优点，笑来成为托福考试旗帜性的人物。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;于2007年2月前后开始动手写的大约八九十篇文章的集合。2009年6月 出版《把时间当做朋友》，至次年6月已经重印11次，深受读者喜爱。这本书从心智成长的角度来谈时间管理，指出时间管理是成功的关键所在。作者引述自己从事的职业中所遇到的事例，告诉我们：如何打开心智，如何运用心智来和时间做朋友，如何理解时间管理的意义，在时间管理上取得突破，进而用心智开启自己的人生成功之旅。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来点负面的～&lt;/p&gt;
&lt;p&gt;从买到书，然后知道了这个人，关注到了一些李笑來老师的言论（博客、twitter、微薄），再结合对这本书的感受，个人对李老师不是很感冒 =.=&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20367798"&gt;李笑来有哪些明显错误的观点？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://lixiaolai.com/archives/10529.html"&gt;臭不要脸的流氓都一个德行&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/19596976"&gt;对李笑来的有关知乎《臭不要脸的流氓都一个德行》一文有什么看法？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;李笑來老师在书中一直强调 “开启心智，获得解放”，但就我从网络上他的言论来看，他远远没有达到这个标准，我认为，任何一个达到开启心智的人，不会在网上撒破，写 blog 破口大骂，武断地下结论，在 twitter 上和网友通宵争论 。一个人连自己的嘴巴都管不好，竟然也写书教导别人 “开启心智”.&lt;/p&gt;
&lt;p&gt;我阴暗地猜测一下，或许是因为他在新东方当老师的经历的后遗症（是的，我对新东方老师存有偏见，结合身边的一些同学的感受，或许称新东方老师为推销员更合适...）；也许和他的学历有关，这里不是对学历的歧视，学历低的牛人多了去了，只是有时候学历会限制一个人的眼界和修养，这本书的第一版出版人 &lt;a href="http://www.zhihu.com/people/yeka/about"&gt;周筠&lt;/a&gt; 在知乎上评论李笑來时就如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若李笑来当年的求学环境更好，可能思维会比现在灵活而视野宽广。基本上靠自学、野路子出身、容易剑走偏锋的他，最需要的还是对自己的反思。这种反思，还尤其包括对自己优势和短处的清晰判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一种可能，这是他的营销手段，毕竟他在创业，使自己时刻处于舆论之中，就是绝佳的免费广告 。&lt;/p&gt;
&lt;h3&gt;读书心得&lt;/h3&gt;
&lt;p&gt;首先，不得不承认，这本书的口碑相当不错，在豆瓣上评分为8.8 分，在书的扉页介绍中也是特意提到了这一点 。而且被列为 “中国书刊发行协2010年度全行业优秀畅销品种”，但是于我而言，看这本书的过程是 “惊喜——还可以——一般”  。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理自己&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“要管理的不是时间，而是自己 。” 可能这是我从本书中学习到的最有用的观点吧 。时间不会因为我们管理减缓流逝速度，我们能做的只有管理自己 。&lt;/p&gt;
&lt;p&gt;事实上，这本书关于管理自己，争取时间的内容并不多，甚至没有占到总篇幅的一半 .书名是 “把时间当作朋友”，开篇说 “你是不是很缺时间？你想不想和时间做朋友？相信我，你并不孤独，只要看下去就能找到和时间做朋友的方法！”，然后在草草介绍了时间管理方面的内容之后，文章开始转向另外一个话题——运用心智获得解放 ... 甚至类似跑题问在具体每一小节中都有不同程度的复现 。&lt;/p&gt;
&lt;p&gt;关于管理自己、规划时间的内容，目前还在看 GTD 相关的书，看完再总结～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成功学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这本书在序言中就在抨击 “成功学”，并且申明本书绝对不是一本成功学，也不是心灵鸡汤，也不是讲大道理的书，也不是一本随便翻翻就可以的书 。尽管作者尽量以朴素的方式总结自己的经验，并且以朴素的语言表达出来，但是正如自己所言， “不可避免地透漏出说教的神态” 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Critical Thinking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在读这本书前，我对 &lt;a href="http://en.wikipedia.org/wiki/Critical_thinking"&gt;critical thinking&lt;/a&gt; 只是有所了解，于是运用自己理解的方法，来审视这本书的内容，不失为一个绝佳的练习方法 :-D 然后我发现文章中很多地方的逻辑并不严密，甚至有些结论无中生有，或者过于武断，牵强附会 。&lt;/p&gt;
&lt;p&gt;P.S. 关于 critical thinking ，阅读更多的书以后再总结 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论点、论据、论证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这本书一开始描绘的问题让我仿佛找到知己，因为我就是这样一个时间不够用患者，顺带 拖延症晚期，看到李老师说可以 “开启心智，获得解放，和时间做朋友” 时，可以想想我是多么的激动，差点就泪流满面了 T_T&lt;/p&gt;
&lt;p&gt;然后我就抱着 “开启心智” 的伟大目标开始了后面的阅读，但是让人失望的是，作者在后面的论述并没有表现出和前言相当的精彩内容。首先，他的某些结论或许是他长期思考总结出来的，适合于他，但是并不能作为普适的经验，甚至有些结论过于武断，只是他的生活经验，缺乏科学的支持；其次，作为一个典型的工科学生，对他的论点、论据、论证方法实在无法赞同，很多时候感觉是想到哪里写到哪里，到后面都忘了前文的目的，转而说下一个问题，就像是聊天一样，扯到十万八里之外了。完全没有达到 “critical thinking” 的标准 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;总之，抛开对作者的映像，就这本书而言，还是比较值得一读的（只是没有像宣传的那么唬），作为一本心理学、时间管理、自我实现方面的入门级书，看看总是没有错的 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;其他人的评价&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;豆瓣上有篇书评，个人感觉相当精髓，不能同意更多：&lt;a href="http://book.douban.com/review/5598312/"&gt;李氏“中医”？&lt;/a&gt;，其中有一句&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我相信这本书是有阶段性意义的，对我个人而言，甚至可以说相当大。 就是在这本书里，我看到一个勇于面对自己的缺点的人，一个认同个人奋斗改变人生的人，令人遗憾的是，我也看到一个仅仅是文笔简洁的人，一个至今仍局限于个人经验而不愿意走出来的人。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/people/yeka/about"&gt;周筠&lt;/a&gt;老师评价：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我是李笑来《把时间当作朋友》第一版的出版人，他的书中的好些观点对我都有触动，给我不少帮助，为此很感谢他。&lt;strong&gt;至今，我还是认为《把时间当作朋友》对很多迷途中的年轻人会有较大帮助，不能因为其中有些观点经不起推敲，就否定这本书的价值。&lt;/strong&gt;对我来说，这本书是有营养的，所以我才会热心出版。&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="时间管理"></category><category term="review"></category></entry><entry><title>学习 Linux 软件包依赖管理</title><link href="http://guqian110.github.io/pages/2014/04/21/learning_linux_package_management.html" rel="alternate"></link><updated>2014-04-21T13:43:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-21:pages/2014/04/21/learning_linux_package_management.html</id><summary type="html">&lt;h2&gt;Linux 软件包依赖问题&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;早期的 Linux 系统上的软件是通过源码方式发布的，大家下载下来，在自己的机器上编译，得到可执行程序 。&lt;/p&gt;
&lt;p&gt;但是，任何程序员写程序都有可能会依赖一些别人已经写成的库，所以几乎一定规模的程序必然有依赖 。尤其是对于 Linux 系统，因为它是 &lt;strong&gt;free（自由，not 免费）&lt;/strong&gt;，开源软件的开发者不是在一个体系下，软件包的依赖关系就比较伤脑筋了， 尤其是当我们的系统里有成百上千的软件时，软件包管理的必要性就更明显了 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;比如我们需要安装 package_a，而 package_a  依赖于 package_b 才能运行，但是我们的系统没有安装 package_b，如果强制安装 package_a，软件很可能不能正常运行 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;  其实在 Windows 下也存在相似的问题，只是因为有微软统一的体系，很多 &lt;code&gt;dll&lt;/code&gt; 被集成在系统中，所以这个问题不明显 。&lt;/p&gt;
&lt;p&gt;不同的系统对于这个问题有不同的处理方法，这也体现出它们不同的处理问题的哲学：&lt;/p&gt;
&lt;p&gt;知乎上的问题：&lt;a href="http://www.zhihu.com/question/20443067"&gt;Unix 的包依赖是如何形成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有个回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GNU/Linux：通常这个系统大多数软件是自由软件，换句话说，他们通常依赖的库也是自由的，所以软件开发者认为你可以自由的获取这些依赖库，自然就不需要自己再提供了。由系统“发行版”负责维护属于这个系统的所有依赖库，并且安装软件时确定依赖
&lt;br&gt;
这个体系的特点是：
&lt;br&gt;
1. 系统依赖通常是统一的，如果有多个程序依赖同一个库，在这个系统中通常是同一份
&lt;br&gt;
2. 具有庞大的资源。例如 Debian 系现成的可依赖软件多达 30G，所以通常不可能预先把所有依赖都安装全，但庞大的依赖库给编程人员提供了很多方便
&lt;br&gt;
3. 你安装的软件越多，共同依赖所体现出的价值越高，解决依赖问题就越简单（因为当你安装足够多软件时，主流的依赖已经全部在你系统了）
&lt;br&gt;
4. 由于巨大的共同依赖库存在，软件本身可以很小
&lt;br&gt;
&lt;br&gt;
Windows：通常而言，这个系统的软件是商业软件，因此，他们依赖的库也很有可能是商业软件，所以，不可能要求用户自行获取这些依赖，这些依赖通常在发布软件的时候提供。如果你安装的软件少，这个体系很方便 。
&lt;br&gt;
不过这造成了一些缺点：
&lt;br&gt;
1. 没有一个庞大的公共库，很多功能以及基础库都是每个公司自己实现一套，浪费很多劳动力，编程人员到每个公司得学习一套不同的库，给编程人员带来不便
&lt;br&gt;
2. 所有应用程序都自己带依赖，因此很可能有许多程序同时附带了相同的依赖，并且这些相同依赖还有可能是不同的版本，这会造成许多混乱
&lt;br&gt;
3. 由于所有应用程序都自己提供所有依赖，每个软件体积都很庞大
&lt;br&gt;
4. 系统中安装的软件越多，越容易出问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Linux 包管理系统&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Package_management_system"&gt;Package management system on wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;package management system&lt;/strong&gt;, also called &lt;strong&gt;package manager&lt;/strong&gt;, is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer's operating system in a consistent manner. It typically maintains a database of software dependencies and version information to prevent software mismatches and missing prerequisites.
&lt;br&gt;
&lt;br&gt;
Package management systems are designed to save organizations time and money through remote administration and software distribution technology that eliminate the need for manual installs and updates. This can be particularly useful for large enterprises whose operating systems are based on Linux and other Unix-like systems, typically consisting of hundreds or even thousands of distinct software packages; in the former case, a package management system is a convenience, in the latter case it becomes essential.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 发行版中，几乎每一个发行版都有自己的软件包管理系统 。&lt;/p&gt;
&lt;h3&gt;Dpkg&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Dpkg"&gt;Dpkg on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dpkg 是基于 Debian 系统的包管理软件 。&lt;code&gt;dpg&lt;/code&gt; 可以用来安装、删除、提供&lt;code&gt;.deb&lt;/code&gt; 格式软件包相关信息的文件 。&lt;/p&gt;
&lt;p&gt;dpkg 由 Matt Welsh、Carl Streeter、 Ian Murdock 用 Perl 语言编写，后来在 1994 年。 Ian Jackson 改用 C 重写了大部分内容 。&lt;/p&gt;
&lt;p&gt;dpkg 是 “Debian package” 的缩写，它最初是为 Debian 系统编写的，也可以在使用 &lt;code&gt;.deb&lt;/code&gt; 格式的 Ubuntu 系统上使用 。&lt;/p&gt;
&lt;h4&gt;常用语法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;peackage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deb&lt;/span&gt;        &lt;span class="c1"&gt;// install&lt;/span&gt;
&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deb&lt;/span&gt;         &lt;span class="c1"&gt;// remove&lt;/span&gt;
&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;// list installed package&lt;/span&gt;
&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;    &lt;span class="c1"&gt;// configure package&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h4&gt;详细用法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;
&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;dpkg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Apt&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Advanced_Packaging_Tool"&gt;Advanced Packaging Tool on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Advanced Packaging Tool, or APT, is a free software user interface that works with core libraries to handle the installation and removal of software on the Debian GNU/Linux distribution and its variants. APT simplifies the process of managing software on Unix-like computer systems by automating the retrieval, configuration and installation of software packages, either from precompiled files or by compiling source code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;apt 最初是设计为 dpkg 的前端，用来处理 &lt;code&gt;.deb&lt;/code&gt; 格式的文件，后来它被 &lt;code&gt;APT-RPM&lt;/code&gt; 组织改造可以支持 RPM 包管理系统 。&lt;/p&gt;
&lt;p&gt;apt 由 &lt;code&gt;apt-get&lt;/code&gt;、&lt;code&gt;apt-cache&lt;/code&gt; 和 &lt;code&gt;apt-config&lt;/code&gt; 等小工具组成&lt;/p&gt;
&lt;h4&gt;常用语法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;             &lt;span class="c1"&gt;// install&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;              &lt;span class="c1"&gt;// remove&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;            &lt;span class="c1"&gt;// search&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;                      &lt;span class="c1"&gt;// update source list&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;upgrade&lt;/span&gt;                     &lt;span class="c1"&gt;// upgrade installed software&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h4&gt;详细用法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;
&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;
&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;
&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;upgrade&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h4&gt;彩蛋&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 terminal 中输入 &lt;code&gt;apt-get -h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;help 内容结束的最后一样会有一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This APT has Super Cow Powers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 terminal 中输入 &lt;code&gt;apt-get moo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会显示一头牛 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="o"&gt;/------&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; 
   &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="o"&gt;||&lt;/span&gt;   
  &lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;---/&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; 
     &lt;span class="o"&gt;~~&lt;/span&gt;   &lt;span class="o"&gt;~~&lt;/span&gt;   
   &lt;span class="p"&gt;....&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Have you mooed today?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;h3&gt;Aptitude&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Aptitude_(software)"&gt;aptitude on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;aptitude is a front-end to the Advanced Packaging Tool (APT). It displays a list of software packages and allows the user to interactively pick packages to install or remove. It has an especially powerful search system utilizing flexible search patterns. It was initially created for Debian, but has appeared in RPM Package Manager (RPM) based distributions as well (such as Conectiva).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;aptitude 是 APT 的文本界面客户端，它的交互性比 apt 好，似乎在处理依赖问题上也更好一些（我遇到的问题，用 aptitude 可以很方便地解决而 apt 不行 ）&lt;/p&gt;
&lt;h4&gt;常用语法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;clean&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h4&gt;详细用法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;aptitude&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h4&gt;彩蛋&lt;/h4&gt;
&lt;p&gt;&lt;img alt="aptitude" src="/images/learning-linux-package-management/aptitude.png" /&gt;&lt;/p&gt;
&lt;h3&gt;YUM&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/Yum"&gt;Yellowdog Updater, Modified on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Yellowdog Updater, Modified (yum) is an open-source command-line package-management utility for Linux operating systems using the RPM Package Manager. Though yum has a command-line interface, several other tools provide graphical user interfaces to yum functionality.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;YUM 是一个基于 RPM 包管理的字符前端软件包管理器。能够从指定的服务器自动下载 RPM 包并且安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装 。被 Yellow Dog Linux 本身，以及 Fedora、Red Hat Enterprise Linux 采用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;举个栗子&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;有些软件要求的库的版本高于(&amp;gt;=)xx.xxx，有些软件要求库的版本必须是(=)xx.xxx，如果我们的库不能满足要求则无法安装软件 。一般 &lt;code&gt;apt-get&lt;/code&gt; 会处理比较简单的依赖关系，但是有些依赖关系 &lt;code&gt;apt-get&lt;/code&gt; 并不能解决 。这时候可以试试 &lt;code&gt;aptitude&lt;/code&gt; 。&lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;为新安装的 Ubuntu 安装开发环境时，遇到了库版本过高的问题，执行下面的命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;essential&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;结果 apt-get 提示有不满足依赖关系的包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reading package lists... Done
&lt;br&gt;
Building dependency tree
&lt;br&gt;
Reading state information... Done
&lt;br&gt;
Some packages could not be installed. This may mean that you have
&lt;br&gt;
requested an impossible situation or if you are using the unstable
&lt;br&gt;
distribution that some required packages have not yet been created
&lt;br&gt;
or been moved out of Incoming.
&lt;br&gt;
The following information may help to resolve the situation:
&lt;br&gt;
&lt;br&gt;
The following packages have unmet dependencies:
&lt;br&gt;
&lt;strong&gt;build-essential : Depends: dpkg-dev (&amp;gt;= 1.13.5) but it is not going to be installed&lt;/strong&gt;
&lt;br&gt;
E: Unable to correct problems, you have held broken packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我们手动安装特定的库&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;dpkg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;结果提示我们库版本过高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reading package lists... Done
&lt;br&gt;
Building dependency tree
&lt;br&gt;
Reading state information... Done
&lt;br&gt;
Some packages could not be installed. This may mean that you have
&lt;br&gt;
requested an impossible situation or if you are using the unstable
&lt;br&gt;
distribution that some required packages have not yet been created
&lt;br&gt;
or been moved out of Incoming.
&lt;br&gt;
The following information may help to resolve the situation:
&lt;br&gt;
&lt;br&gt;
The following packages have unmet dependencies:
&lt;br&gt;
 &lt;strong&gt;dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is to be installed&lt;/strong&gt;
&lt;br&gt;
Recommends: build-essential but it is not going to be installed
&lt;br&gt;
           Recommends: fakeroot but it is not going to be installed
&lt;br&gt;
           Recommends: libalgorithm-merge-perl but it is not going to be installed
&lt;br&gt;
E: Unable to correct problems, you have held broken packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;解决问题 —— 使用 &lt;code&gt;aptitude&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;解决方法就是降级&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;方法有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;apt-get 直接指定安装特定的版本&lt;/p&gt;
&lt;p&gt;首先查询是否提供低版本的包&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;showpkg&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;若有则指定安装某个版本&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 aptitude 自动处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我采用的第二种方法：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;essential&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;结果如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following NEW packages will be installed:
&lt;br&gt;
 build-essential dpkg-dev{ab} 
&lt;br&gt;
The following packages are RECOMMENDED but will NOT be installed:
&lt;br&gt;
fakeroot libalgorithm-merge-perl 
&lt;br&gt;
0 packages upgraded, 2 newly installed, 0 to remove and 18 not upgraded.
&lt;br&gt;
Need to get 718 kB of archives. After unpacking 1,636 kB will be used.
&lt;br&gt;
The following packages have unmet dependencies:
&lt;br&gt;
 dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is installed.
&lt;br&gt;
The following actions will resolve these dependencies:
&lt;br&gt;
&lt;br&gt;
Keep the following packages at their current version:
&lt;br&gt;
1)     build-essential [Not Installed]
&lt;br&gt;
2)     dpkg-dev [Not Installed]
&lt;br&gt;
&lt;br&gt;
Accept this solution? [Y/n/q/?]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然不是中止安装，选择 &lt;code&gt;n&lt;/code&gt;， aptitude 给出另外一个解决方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following actions will resolve these dependencies:
&lt;br&gt;
 Downgrade the following packages:
&lt;br&gt;
&lt;br&gt;
1)     libdpkg-perl [1.16.12ubuntu1 (now) -&amp;gt; 1.16.10ubuntu1 (raring)]
&lt;br&gt;
&lt;br&gt;
Accept this solution? [Y/n/q/?]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这正是我们需要解决的版本过高的问题，将库软件版本降级&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following packages will be DOWNGRADED:
&lt;br&gt;
libdpkg-perl 
&lt;br&gt;
The following NEW packages will be installed:
&lt;br&gt;
 build-essential dpkg-dev{a} 
&lt;br&gt;
The following packages are RECOMMENDED but will NOT be installed:
&lt;br&gt;
fakeroot libalgorithm-merge-perl 
&lt;br&gt;
0 packages upgraded, 2 newly installed, 1 downgraded, 0 to remove and 18 not upgraded.
&lt;br&gt;
Need to get 904 kB of archives. After unpacking 1,632 kB will be used.
&lt;br&gt;
Do you want to continue? [Y/n/?] &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选择 &lt;code&gt;y&lt;/code&gt;。然后 aptitude 会完成剩余的工作 。&lt;/p&gt;
&lt;p&gt;问题解决啦！&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20443067"&gt;Unix 的包依赖是如何形成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://daway320.blog.163.com/blog/static/3878369920107331733393/"&gt;apt-get install安装软件问题(安装包的依赖库版本过高问题)&lt;/a&gt;&lt;/p&gt;</summary><category term="Package Management"></category></entry><entry><title>学习 Vim 保存项目设置</title><link href="http://guqian110.github.io/pages/2014/04/20/learning_vim_save_project_configuration.html" rel="alternate"></link><updated>2014-04-20T14:32:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-20:pages/2014/04/20/learning_vim_save_project_configuration.html</id><summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关于 Vim 和 IDE 的争论，这是程序猿的圣战，不再浪费时间 :-D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在参考了很多人分享的博客和教程之后，终于把 Vim 搭建成为一个自己定制的 IDE（这种说法严格意义上说，是不对的，应该是 “组合一组工具成为一个 IDE ”），总结一下～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本系列的内容很多都是参考别人的博客写的，也包含部分自己摸索的结果 。虽然部分内容和参考文章相同，但是总结一下自己的学习过程还是一件有必要的事 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;很多编辑器都有一个功能是以前打开过的文档会有记忆，再次打开时会直接跳转到上次编辑的地方，比如  &lt;a href="http://www.sublimetext.com/2"&gt;&lt;code&gt;Sublime Text 2&lt;/code&gt;&lt;/a&gt;，强大的 Vim 当然也有这个功能，&lt;strong&gt;我们的目标就是让 Vim 和其他 IDE 一样，可以记住上次的编辑状态 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vim 要实现这个功能，涉及到两个地方的配置：&lt;code&gt;session&lt;/code&gt; &amp;amp; &lt;code&gt;viminfo&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Session&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Intro&lt;/h3&gt;
&lt;p&gt;在 Vim 中输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就可以看到关于 &lt;code&gt;session&lt;/code&gt; 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Session keeps the Views for all windows, plus the global settings.  You can save a Session and when you restore it later the window layout looks the same. You can use a Session to quickly switch between different projects, automatically loading the files you were last working on in that project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我使用的 Vim 7.3 中， &lt;code&gt;help&lt;/code&gt; 中的 &lt;code&gt;usr_21.txt&lt;/code&gt; 的主题是 &lt;code&gt;Go away and come back&lt;/code&gt;，其中 &lt;code&gt;21.4&lt;/code&gt;  节保存的就是关于 session 的说明，在 Vim 中输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="mf"&gt;21.4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就可以看到关于 session 的详细介绍 。&lt;/p&gt;
&lt;h3&gt;Config&lt;/h3&gt;
&lt;p&gt;Session 保存的信息由 &lt;code&gt;sessionoptions&lt;/code&gt; 确定，详细用法可以查看 help&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sessionoption&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;'sessionoptions' 'ssop' string  (default: &lt;strong&gt;"blank,buffers,curdir,folds,help,options,tabpages,winsize"&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It is a comma separated list of words.  Each word enables saving and restoring something&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 session 保存的会话的属性默认的有 8 个 ：&lt;strong&gt;当前编辑的空窗口、缓冲区、当前目录、折叠信息、帮助信息、选项、标签页、窗口大小信息 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面的设置中，不要同时包含 &lt;code&gt;curdir&lt;/code&gt; 和 &lt;code&gt;sesdir&lt;/code&gt; 两个选项，若两个选项都不包含，则保存 session 时，会保存绝路径 。添加 &lt;code&gt;sesdir&lt;/code&gt; 可以将当前目录设置为 &lt;code&gt;session-file&lt;/code&gt;  所在的目录，这个设置有个很有用的地方就是，当我们通过网络访问我们的工程或者有很多个工程版本，这时候只需要每个工程下保存一个 session-file 即可 。&lt;/p&gt;
&lt;p&gt;删除/加入 某个选项的方法&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;curdir&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;sesdir&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Save&lt;/h3&gt;
&lt;p&gt;详细的语法可以在 help 中查看&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;mksession&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;mksession&lt;/code&gt; 命令保存会话&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptopms&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;curdir&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;sesdir&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mksession&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;如果 session-file 已经存在，则使用&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mksession&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Load&lt;/h3&gt;
&lt;p&gt;然后退出 Vim，在别的目录下打开，干点别的事，这时候我们想起刚才的工程里面有个小 bug，想恢复过去，这时候就是只需要使用 &lt;code&gt;source&lt;/code&gt; 命令即可 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;source&lt;/code&gt; 命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;PATHto&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这时候可以看到，已经恢复了之前的状态 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;只使用 session 就可以恢复一些上次编辑的信息，但是这还不够，我们还可以配合使用 &lt;code&gt;viminfo&lt;/code&gt; 来恢复更多的信息 。在 Vim 的 &lt;code&gt;:help 21.4&lt;/code&gt; 中有介绍两者的关系&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sessions store many things, but not the position of marks, contents of registers and the command line history.&lt;/strong&gt;  You need to use the viminfo feature for these things.&lt;/li&gt;
&lt;li&gt;In most situations you will want to use sessions separately from viminfo. This can be used to switch to another session, but keep the command line history.  And yank text into registers in one session, and paste it back in another session.&lt;/li&gt;
&lt;li&gt;You might prefer to keep the info with the session.  You will have to do this yourself then.&lt;/li&gt;
&lt;li&gt;You could also use a Session file.  &lt;strong&gt;The difference is that the viminfo file does not depend on what you are working on.&lt;/strong&gt;  There normally is only one viminfo file.  Session files are used to save the state of a specific editing Session.  You could have several Session files, one for each project you are working on.  Viminfo and Session files together can be used to effectively
enter Vim and directly start working in your desired setup.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Viminfo&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Intro&lt;/h3&gt;
&lt;p&gt;在 Vim 中输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就可以看到关于 &lt;code&gt;viminfo&lt;/code&gt; 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you exit Vim and later start it again, you would normally lose a lot of information.  The viminfo file can be used to remember that information, which enables you to continue where you left off.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Vim 7.3 中， &lt;code&gt;help&lt;/code&gt; 中的 &lt;code&gt;usr_21.txt&lt;/code&gt; 的主题是 &lt;code&gt;Go away and come back&lt;/code&gt;，其中 &lt;code&gt;21.3&lt;/code&gt;  节保存的就是关于 viminfo 的说明，在 Vim 中输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="mf"&gt;21.3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就可以看到关于 viminfo 的详细介绍 。&lt;/p&gt;
&lt;p&gt;viminfo 文件可以保存的内容有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The command line history 命令行历史&lt;/li&gt;
&lt;li&gt;The search string history 字符串搜寻历史&lt;/li&gt;
&lt;li&gt;The input-line history 输入行历史&lt;/li&gt;
&lt;li&gt;Contents of non-empty register 非空寄存器内容&lt;/li&gt;
&lt;li&gt;Marks for serval files 文件位置标记&lt;/li&gt;
&lt;li&gt;Last search/substitute pattern 最近模式匹配搜索历史&lt;/li&gt;
&lt;li&gt;The buffer list 缓冲区列表&lt;/li&gt;
&lt;li&gt;Global variables 全局变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Save&lt;/h3&gt;
&lt;p&gt;其实 Vim 每次退出时都会在 &lt;code&gt;～/&lt;/code&gt; 目录下保存一个 &lt;code&gt;.viminfo&lt;/code&gt; 的文件，但是每次打开关闭一个文件都会覆盖上次的记录，所以我们需要为工程手动保存一个 viminfo 文件，并且保存在工程目录下，防止被覆盖 。&lt;/p&gt;
&lt;p&gt;保存命令 &lt;code&gt;:wviminfo&lt;/code&gt; 的帮助&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;wviminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;wviminfo&lt;/code&gt; 保存&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;wviminfo&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;载入 viminfo 文件&lt;/h3&gt;
&lt;p&gt;载入命令 &lt;code&gt;rviminfo&lt;/code&gt; 帮助&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rviminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;载入 viminfo 文件&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rviminfo&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;为了节省每次都要手动输入一些设置命令，我们可以把部分相同的设置放在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;curdir&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;sesdir&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;每次退出 Vim 时保存&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mksession&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;wviminfo&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;进入 Vim 想恢复项目设置时&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;projetc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rviminfo&lt;/span&gt; &lt;span class="n"&gt;projetc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-session-file-and-viminfo/"&gt;vi/vim使用进阶: 使用会话和viminfo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-save-project-configuration/"&gt;vi/vim使用进阶: 保存项目相关配置&lt;/a&gt;&lt;/p&gt;</summary><category term="Vim"></category></entry><entry><title>学习 Vim 使用 Vundle 管理插件</title><link href="http://guqian110.github.io/pages/2014/04/16/learning_vim_vundle.html" rel="alternate"></link><updated>2014-04-16T17:06:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-16:pages/2014/04/16/learning_vim_vundle.html</id><summary type="html">&lt;p&gt;学习 Vim，使用 Vundle 管理插件 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Vim 插件&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Vim 的强大之处在于它的可扩展性，你可以把它当作一个简单的文本编辑器，也可以安装各种功能强大的插件，把它武装成一个 IDE 。&lt;/p&gt;
&lt;p&gt;我们可以从以下几个地方找到 Vim 插件，一般比较常用的插件从官网上都可以找到，还有一些插件是大神们自己写的，托管在 GitHub 上 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script_search_results.php"&gt;Vim 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;什么是 Vundle&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Vim 的插件虽然强大，但是因为 Vim 根本就没有插件管理这个概念，所有插件的文件都散布在~/.vim下的几个文件夹中，配置 vim 的过程, 就是在网上不停的搜插件，拷贝到 &lt;code&gt;~/.vim&lt;/code&gt; 下，发现更新，要重新下载重新拷贝，想要删除某个不需要插件，更是要小心翼翼的不要删错。配置出顺手的 Vim, 需要极大的耐心和运气，而且如果换一台电脑，就要重复一次这样的痛苦经历 。&lt;/p&gt;
&lt;p&gt;自然地，因为管理插件的需求，最早出现了一些管理插件的脚本，但是写脚本需要一定的 shell 知识，直接 copy 别人的自己并不一定适用 。后来，出现了一些插件，比如 pathogen，muzuiget，vim-flavor，Vundle 等 。&lt;/p&gt;
&lt;p&gt;目前比较流行的方式是采用 Vundle 来管理插件（别的我也没有试过...）&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/gmarik/Vundle.vim"&gt;Vundle on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=3458"&gt;Vundle on vim.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vundle 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vundle is short for Vim bundle and is a Vim plugin manager.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vundle 可以在交互的方式下做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;.vimrc&lt;/code&gt; 中管理和配置插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按名字搜索插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何使用 Vundle 管理插件&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;安装 Vundle&lt;/h3&gt;
&lt;p&gt;Vundle 的安装需要 &lt;a href="http://git-scm.com/"&gt;Git&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;从 GitHub 上 clone 下来就可以了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/gmarik/vundle.git ~/.vim/bundle/vundle&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;配置 Vundle&lt;/h3&gt;
&lt;p&gt;将下列内容加入到 &lt;code&gt;.vimrc&lt;/code&gt; 文件中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;nocompatible&lt;/span&gt;              &lt;span class="s"&gt;&amp;quot; be iMproved, required&lt;/span&gt;
&lt;span class="n"&gt;filetype&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;                  &lt;span class="s"&gt;&amp;quot; required&lt;/span&gt;

&lt;span class="s"&gt;&amp;quot; set the runtime path to include Vundle and initialize&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;rtp&lt;/span&gt;&lt;span class="o"&gt;+=~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bundle&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vundle&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;vundle&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; alternatively, pass a path where Vundle should install plugins&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;let path = &amp;#39;~/some/path/here&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;call vundle#rc(path)&lt;/span&gt;

&lt;span class="s"&gt;&amp;quot; let Vundle manage Vundle, required&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;gmarik&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vundle&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; The following are examples of different formats supported.&lt;/span&gt;

&lt;span class="s"&gt;&amp;quot; Keep Plugin commands between here and filetype plugin indent on.&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; scripts on GitHub repos&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;tpope&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fugitive&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Lokaltog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;easymotion&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;tpope&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rails&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; Pass the path to set the runtimepath properly.&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rstacruz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sparkup&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rtp&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; scripts from http://vim-scripts.org/vim/scripts.html&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;L9&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;FuzzyFinder&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; scripts not on GitHub&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//git.wincent.com/command-t.git&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; git repos on your local machine (i.e. when working on your own plugin)&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;///home/gmarik/path/to/plugin&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; ...&lt;/span&gt;

&lt;span class="n"&gt;filetype&lt;/span&gt; &lt;span class="n"&gt;plugin&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;     &lt;span class="s"&gt;&amp;quot; required&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; To ignore plugin indent changes, instead use:&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;filetype plugin on&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; Brief help&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; :PluginList          - list configured plugins&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; :PluginInstall(!)    - install (update) plugins&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; :PluginSearch(!) foo - search (or refresh cache first) for foo&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; see :h vundle for more details or wiki for FAQ&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; NOTE: comments after Plugin commands are not allowed.&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; Put your stuff after this line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;从上面的配置文件中可以看到，Vundle 把插件分为了 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;scripts on GitHub repos&lt;/p&gt;
&lt;p&gt;GitHub 上的脚本，需要按照 &lt;code&gt;usrname/repos&lt;/code&gt; 的格式写出插件的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scripts from http://vim-scripts.org/vim/scripts.html &lt;/p&gt;
&lt;p&gt;Vim scripts 上的脚本，不用作者名，直接写插件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scripts not on GitHub&lt;/p&gt;
&lt;p&gt;不是 GitHub 上的脚本，需要写出插件的详细路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;运行 Vundle&lt;/h3&gt;
&lt;p&gt;修改好 &lt;code&gt;.vimrc&lt;/code&gt; 文件后，打开 Vim，使用以下命令管理插件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;列表&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Bundles&lt;/span&gt;    &lt;span class="c1"&gt;// 列出所有插件（包括未安装的）&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleList&lt;/span&gt; &lt;span class="c1"&gt;// 列出已安装的插件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleSearch&lt;/span&gt;   &lt;span class="c1"&gt;// 后面不接插件名时，同 Bundles，列出了 4000 个插件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中删除/注释掉相应的插件名，然后输入命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleClean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; P.S. 我安装的插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列出一些我安装的插件，这些插件都是大家比较常用的，可以从相关的网站或者帮助文档中找到使用说明或者 &lt;code&gt;README&lt;/code&gt;，计划在后续中写一写使用心得～&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;taglist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NERD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;SuperTab&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;snipMate&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;L9&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;FuzzyFinder&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bufexplorer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zip&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;winmanager&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Markdown&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Conque&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Shell&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;vimwiki&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;genutils&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;lookupfile&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Bundle &amp;#39;ManPageView&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;calendar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;AutoClose&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;scripts on GitHub repos&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;suan&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;instant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;godlygeek&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tabular&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://zuyunfei.com/2013/04/12/killer-plugin-of-vim-vundle/"&gt;vim中的杀手级插件: vundle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zfanw.com/blog/vundle-vim-plugin-management.html"&gt;Vundle 管理 Vim 插件&lt;/a&gt;&lt;/p&gt;</summary><category term="Vim"></category><category term="vundle"></category></entry><entry><title>学习 Vim 初步配置 Vim</title><link href="http://guqian110.github.io/pages/2014/04/16/learning_vim_vimrc_preliminary.html" rel="alternate"></link><updated>2014-04-16T12:44:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-16:pages/2014/04/16/learning_vim_vimrc_preliminary.html</id><summary type="html">&lt;p&gt;总结初步配置 Vim，让 Vim 更顺手 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;在哪里配置 Vim&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6126937/"&gt;学习 Vi 和 Vim 编辑器&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim 依照特定顺序寻找初始化的信号，它执行找到的第一组指令（可以是 环境变量 or 配置文件），然后开始编辑工作 。所以，Vim 在下列清单中遇到的第一个项目，就是清单中被执行的唯一项目 。书寻如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VIMINIT&lt;/code&gt; 。它是环境变量，如果不为空，Vim 把它的内容当作 ex 命令执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户 &lt;code&gt;vimrc&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exrc&lt;/code&gt; 选项 。如果设置了 Vim 的 exrc 选项，它会寻找三个额外的配置文件 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;vimrc&lt;/code&gt;（vim runtime configure）文件一般有 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;/etc/vim/vimrc&lt;/p&gt;
&lt;p&gt;本配置文件影响所有的用户，一般不应该更改这个配置文件，因为谁也不能保证别人的喜好和自己一样 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/usr/share/vim/vimrc&lt;/p&gt;
&lt;p&gt;输入命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="n"&gt;ll&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;share&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vimrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就可以看到，本文件是 &lt;code&gt;/etc/vim/vimrc&lt;/code&gt; 的软链接 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;~/.vimrc&lt;/p&gt;
&lt;p&gt;一般来说，配置 vim 就是在这个文件中配置，如果不存在的话 &lt;code&gt;touch&lt;/code&gt; 一个新文件并命名 &lt;code&gt;。vimrc&lt;/code&gt; 。我们在下面说的配置都是在本文件中配置 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;映射 &lt;code&gt;esc&lt;/code&gt; 键&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;因为历史原因，Joy 设计 vi 时采用的键盘和我们现在用的标准键盘布局并不一样，当时他的键盘的 &lt;code&gt;esc&lt;/code&gt; 键在现在我们的 &lt;code&gt;Caps Lock&lt;/code&gt; 键的位置，所以才设计使用 &lt;code&gt;esc&lt;/code&gt; 作为模式转换键 。为了更加方便顺手地使用 vim，当然要把这两个键相互调换一下 。&lt;/p&gt;
&lt;p&gt;在 vim 的官网上就有介绍如何实现两个按键的调换&lt;/p&gt;
&lt;p&gt;&lt;a href="http://vim.wikia.com/wiki/Map_caps_lock_to_escape_in_XWindows"&gt;Map caps lock to escape in XWindows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体方法，在 &lt;code&gt;～/&lt;/code&gt; 目录下新建一个文件，加入一下内容&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="n"&gt;Swap&lt;/span&gt; &lt;span class="n"&gt;caps&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;escape&lt;/span&gt;
&lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Caps_Lock&lt;/span&gt;
&lt;span class="n"&gt;keysym&lt;/span&gt; &lt;span class="n"&gt;Escape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Caps_Lock&lt;/span&gt;
&lt;span class="n"&gt;keysym&lt;/span&gt; &lt;span class="n"&gt;Caps_Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Escape&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Caps_Lock&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;保存为 .speedswrapper&lt;/p&gt;
&lt;p&gt;然后输入命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;xmodmap&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;speedswrapper&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这时，对于整个系统范围，这两个键已经调换了位置 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;设置颜色主题 colorscheme&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Vim 自带一些颜色主题，一般存放在 &lt;code&gt;/usr/share/vim/vim7x&lt;/code&gt; 目录下（我的 Vim 版本为 7.3，所以路径为 &lt;code&gt;/usr/share/vim/vim73&lt;/code&gt;）.&lt;/p&gt;
&lt;p&gt;如果对系统自带的主题不满意，网上有很多不错的主题，个人最喜欢 &lt;a href="https://github.com/tomasr/molokai"&gt;molikai&lt;/a&gt; 主题，把下载下来的配色文件拷贝到 &lt;code&gt;usr/share/vim/vim73&lt;/code&gt; 路径下，打开 vim 后 输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;colorscheme&lt;/span&gt; &lt;span class="n"&gt;molikai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就 ok 了～ 不过这个方法在关闭 vim 后就恢复了，要想省去每次都输命令的烦恼，只需要在下一步 .vimrc 文件中加入以下内容就可以了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;colorscheme&lt;/span&gt; &lt;span class="n"&gt;molikai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;编写 .Vimrc&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;vimrc 文件是配置 Vim 编辑特性比较好的地方，差不多任何 Vim 选项都能在次文件中被设置为打开或者关闭，而且它特别适合设置全局变量与定义函数、缩写、按键映射 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注释以双引号 &lt;code&gt;“&lt;/code&gt; 开始，可位于一行的任何2位置，所有位于双引号后面的文本，包括双引号都会被视为注释而忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用冒号 &lt;code&gt;:&lt;/code&gt; 表示 ex 命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;配置 Vim 特性&lt;/h3&gt;
&lt;p&gt;vimrc 配置很简单，网上有很多人都分享了自己的配置方案 。我找到一份注释良好的&lt;a href="https://github.com/amix/vimrc"&gt;配置范例&lt;/a&gt;，这篇博客的作者总结了自己 8 年的使用经验，给出了两份配置文件，基本版 &lt;a href="https://github.com/amix/vimrc/blob/master/vimrcs/basic.vim"&gt;Basic&lt;/a&gt; 和 终极版&lt;a href="https://github.com/amix/vimrc"&gt;Ultimate&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;作为码农，当然要选择终极版了～不过个人喜欢用 Vundle 管理我的 Vim 插件（计划下篇博客记录我的配置过程），不是很喜欢作者选择的所有插件，想自己定制插件组合，那么目前只需要看 基础版就足够了 。&lt;/p&gt;
&lt;p&gt;copy 了一份基础版到自己的 github 中，有备无患 :-D&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Copy of basic vimrc configure file&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我自己的配置文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;My .vimrc file&lt;/a&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;General&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;set nocompatible&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nb"&gt;Set&lt;/span&gt; &lt;span class="nx"&gt;how&lt;/span&gt; &lt;span class="nx"&gt;many&lt;/span&gt; &lt;span class="nx"&gt;lines&lt;/span&gt; &lt;span class="nx"&gt;of&lt;/span&gt; &lt;span class="nx"&gt;history&lt;/span&gt; &lt;span class="nx"&gt;VIM&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="nx"&gt;rememer&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;800&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Enable filetype plugins&lt;/span&gt;
&lt;span class="s2"&gt;filetype plugin on&lt;/span&gt;
&lt;span class="s2"&gt;filetype indent on&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nb"&gt;Set&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="nb"&gt;read&lt;/span&gt; &lt;span class="nx"&gt;when&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt; &lt;span class="nx"&gt;is&lt;/span&gt; &lt;span class="nx"&gt;changed&lt;/span&gt; &lt;span class="nb"&gt;from&lt;/span&gt; &lt;span class="nx"&gt;the&lt;/span&gt; &lt;span class="nx"&gt;outside&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;autoread&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Set leader key&lt;/span&gt;
&lt;span class="s2"&gt;let mapleader = &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;let g:mapleader = &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;fast&lt;/span&gt; &lt;span class="nx"&gt;saving&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="o"&gt;!&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; fast saving&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;leader&amp;gt;q :q!&amp;lt;cr&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;fast&lt;/span&gt; &lt;span class="nx"&gt;editing&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;aq&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;qa&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; Vim user interface&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nb"&gt;Set&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="nx"&gt;lines&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="nx"&gt;the&lt;/span&gt; &lt;span class="nx"&gt;cursor&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Turn on the wild menu&lt;/span&gt;
&lt;span class="s2"&gt;set wildmenu&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Ignore&lt;/span&gt; &lt;span class="nx"&gt;complited&lt;/span&gt; &lt;span class="nx"&gt;files&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;wildignore&lt;/span&gt;&lt;span class="o"&gt;=*&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="err"&gt;~&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;pyc&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Always show current postion&lt;/span&gt;
&lt;span class="s2"&gt;set ruler&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Highlight&lt;/span&gt; &lt;span class="nx"&gt;current&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;cursorline&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Height of command bar&lt;/span&gt;
&lt;span class="s2"&gt;set cmdheight=2&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;A&lt;/span&gt; &lt;span class="nx"&gt;buffer&lt;/span&gt; &lt;span class="nx"&gt;becomes&lt;/span&gt; &lt;span class="nx"&gt;hidden&lt;/span&gt; &lt;span class="nx"&gt;when&lt;/span&gt; &lt;span class="nx"&gt;it&lt;/span&gt; &lt;span class="nx"&gt;is&lt;/span&gt; &lt;span class="nx"&gt;abandoned&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;hid&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Configure backsapce so it acts as it should act&lt;/span&gt;
&lt;span class="s2"&gt;set backspace=eol,start,indent&lt;/span&gt;
&lt;span class="s2"&gt;set whichwrap+=&amp;lt;,&amp;gt;,h,l&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Ignore&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;when&lt;/span&gt; &lt;span class="nx"&gt;searching&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;ignorecase&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; When searching try to be smart about cases&lt;/span&gt;
&lt;span class="s2"&gt;set smartcase&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Highlight&lt;/span&gt; &lt;span class="nb"&gt;search&lt;/span&gt; &lt;span class="nb"&gt;results&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;hlsearch&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Make search act like in morden browsers&lt;/span&gt;
&lt;span class="s2"&gt;set incsearch&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Don&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;t redraw while executing marcros&lt;/span&gt;
&lt;span class="s1"&gt;set lazyredraw&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; For regular expressions turn magic on&lt;/span&gt;
&lt;span class="s1"&gt;set magic&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Show matching brackets when text indicator is over them&lt;/span&gt;
&lt;span class="s1"&gt;set showmatch&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; How many tenths of a second to blink when matching brackets&lt;/span&gt;
&lt;span class="s1"&gt;set mat=2&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Colors and Fonts&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Enable syntax highlight&lt;/span&gt;
&lt;span class="s1"&gt;syntax enable&lt;/span&gt;
&lt;span class="s1"&gt;colorscheme molokai&lt;/span&gt;
&lt;span class="s1"&gt;set background=dark&lt;/span&gt;
&lt;span class="s1"&gt;:set t_Co=256&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Set utf8 as standard encoding and en_US as the standard language&lt;/span&gt;
&lt;span class="s1"&gt;set encoding=utf8&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Use Unix as the standard file type&lt;/span&gt;
&lt;span class="s1"&gt;set ffs=unix,dos,mac&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Files, backups and undo&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Turn backup off, since most stuff is in SVN. git et.c anyway&lt;/span&gt;
&lt;span class="s1"&gt;set nobackup&lt;/span&gt;
&lt;span class="s1"&gt;set nowb&lt;/span&gt;
&lt;span class="s1"&gt;set noswapfile&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Text, tab and indent related&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Use sapce instead of tabs&lt;/span&gt;
&lt;span class="s1"&gt;set expandtab&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Be smart when using tabs&lt;/span&gt;
&lt;span class="s1"&gt;set smarttab&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; 1 tab = 4 spaces&lt;/span&gt;
&lt;span class="s1"&gt;set shiftwidth=4&lt;/span&gt;
&lt;span class="s1"&gt;set tabstop=4&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Linebreak on 500 characters&lt;/span&gt;
&lt;span class="s1"&gt;set lbr&lt;/span&gt;
&lt;span class="s1"&gt;set tw=500&lt;/span&gt;

&lt;span class="s1"&gt;set ai &amp;quot;Auto indent&lt;/span&gt;
&lt;span class="s1"&gt;set si &amp;quot;Smart indent&lt;/span&gt;
&lt;span class="s1"&gt;set wrap &amp;quot;Wrap lines&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Moving around, tabs, windows and buffers&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Treat long lines as break lines&lt;/span&gt;
&lt;span class="s1"&gt;map j gj&lt;/span&gt;
&lt;span class="s1"&gt;map k gk&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Smart way to move between windows&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;C-j&amp;gt; &amp;lt;C-w&amp;gt;j&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;C-k&amp;gt; &amp;lt;C-w&amp;gt;k&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;C-h&amp;gt; &amp;lt;C-w&amp;gt;h&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;C-l&amp;gt; &amp;lt;C-w&amp;gt;l&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Status line&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Show line number&lt;/span&gt;
&lt;span class="s1"&gt;set number&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Always show the status line&lt;/span&gt;
&lt;span class="s1"&gt;set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s1"&gt;%d/%m/%y\ -\ %H:%M&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s1"&gt;)}&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l&lt;/span&gt;


&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Spell checking&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Pressing ,ss will toggle and untoggle spell checking&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;leader&amp;gt;ss :setlocal spell!&amp;lt;cr&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;leader&amp;gt;sn ]s&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;leader&amp;gt;sp [s&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;leader&amp;gt;sa zg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6126937/"&gt;学习vi 和 Vim 编辑器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/amix/vimrc"&gt;The Ultimate vimrc&lt;/a&gt;&lt;/p&gt;</summary><category term="Vim"></category></entry><entry><title>如何优雅地使用 Gmail</title><link href="http://guqian110.github.io/pages/2014/04/11/how_to_use_gmail_elegantly.html" rel="alternate"></link><updated>2014-04-11T23:33:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-11:pages/2014/04/11/how_to_use_gmail_elegantly.html</id><summary type="html">&lt;p&gt;Gmail 是 Google 提供的邮箱，细数使用 Gmail 已经快 5 年了，但是最近才发现自己的使用方法根本不对，摸索了 2 天，总结一下使用心得～&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;为何使用 Gmail&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;关于 QQ mail 和 Gmail 谁好谁坏的问题，知乎上有一堆&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20010081"&gt;为什么这么多人说 Gmail 好用？Gmail 和 QQmail 相比到底好在哪里？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/19606703"&gt;为什么现在这么多受过高等教育的人喜欢用 Gmail，国内的邮箱如何？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/19724238"&gt;不喜欢 Gmail 而喜欢 QQ 邮箱的人，为什么会产生这样的偏好？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我选择 Gmail 的理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Gmail 账户是 Google 所有服务的入口，除了可以使用 Gmail 外和其他所有 Google 产品都有无缝的整合 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强大的功能，比如我最喜欢的 &lt;em&gt;邮件对话功能&lt;/em&gt; 和 &lt;em&gt;label 功能&lt;/em&gt;，还有 &lt;em&gt;过滤器&lt;/em&gt;，Chrome + Gmail，给你最简洁强大的体验 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全，邮件不会受到某些机器&amp;amp;人工的监视，免受 GFW 的干扰&lt;/p&gt;
&lt;p&gt;这恰恰是一些人不使用 Gmail 的原因，因为 Gmail 不稳定，但是关于这个问题，引用 &lt;a href="http://www.zhihu.com/people/hecaitou"&gt;和菜头&lt;/a&gt; 在知乎上的一句话 &lt;a href="http://www.zhihu.com/question/19580396"&gt;“因为Gmail总有访问正常的一天，只要Google不死。对未来没有信心做人和一条咸鱼又有什么区别？”&lt;/a&gt;，况且，在 Geek 面前这都不是问题 。）&lt;/p&gt;
&lt;p&gt;关于 Google 和百度、天朝的恩怨，一个有独立判断能力的人都明白为什么 Google 退出中国 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我是 G 粉，Gmail 代表了自由 :-D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gmail 可以代收发邮件，测试了一下 QQ mail 和 163 是可以用的，所以，只需要 一个 Gmail 就可以管理 3 个邮箱了。&lt;/p&gt;
&lt;p&gt;对于中国人来说，邮箱貌似是一个很边缘化的东西，而对于西方国家来说，邮箱交流是一件再普通的事了。听说微软 和 Google 公司即使一个办公室内的同事，上下级都是用邮件交流的（国内互联网公司貌似也有，但是没有达到那么频繁的程度），全世界的邮件流量超过 80% 在欧美 。所以，QQ mail 上到处是贺卡、问候、漂流瓶，这也是为什么用 QQ mail 发一份简历时为什么显得不正式的原因 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何优雅地使用 Gmail&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;擅自使用知乎风格来命名这个子标题，其实只是我个人的一些使用心得 :-D&lt;/p&gt;
&lt;p&gt;完整的攻略当然是官方的&lt;a href="https://support.google.com/mail/?hl=zh-Hans#topic=3394144"&gt;帮助&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;代收其他邮箱&lt;/h3&gt;
&lt;p&gt;官方帮助文档，导入&lt;a href="https://support.google.com/mail/answer/21289?hl=zh-Hans&amp;amp;ref_topic=3394220"&gt;邮箱账户&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="import" src="/images/how-to-use-gmail-gracefully/import.png" /&gt;&lt;/p&gt;
&lt;p&gt;Gmail 最多可以导入 5 个邮箱账户的邮件，对于普通人来说，远远足够了 。&lt;/p&gt;
&lt;h3&gt;Inbox /Archive&lt;/h3&gt;
&lt;p&gt;这是我最喜欢 Gmail 的地方，也是我以前一直没有正确使用的功能 。以前，我的 inbox 里面有大概 800+  份邮件，包括已读/未读，私人邮件、工作邮件、广告、各个网站注册激活链接、社交网络消息提醒等，全部混在一起 。&lt;/p&gt;
&lt;p&gt;从知乎上找到一个改变我对邮箱 Inbox/Archive 的认识的回答，问题是 &lt;a href="http://www.zhihu.com/question/20042480"&gt;如何有效地使用 Gmail 的 Archive（归档）功能？&lt;/a&gt; ，回答者是&lt;a href="http://www.zhihu.com/people/unogzx"&gt;钢盅郭子&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;精髓就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Inbox = 待/未处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Archive = 已/不处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阅读完邮件（已读），却无法立刻做出响应（回复或开展相关工作）的可能性是很高的，此时可以将邮件留在收件箱内留待日后处理。&lt;/p&gt;
&lt;p&gt;而将邮件存档，则说明已经不再对此邮件感兴趣了，即便它始终未读，我们也可以通过其他信息（标题、收件人不是自己）确定这是一封不需要关注的邮件。&lt;/p&gt;
&lt;p&gt;有人认为 Inbox 可以覆盖 Archive 的功能。我觉得可以理解，毕竟，喜欢把所有工作都堆放在办公桌台面上的也是大有人在。但即使我们有许多的文件夹或标签可用来分类、标识，抽屉总还是办公桌的默认配置吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;像我以前一样，读完的文件仍然保留在 Inbox 中，就像每次都在办公桌面上读完文件都不收拾，越摆越多，只是这个虚拟的办公桌不会堆不下文件 。&lt;/p&gt;
&lt;p&gt;正确的使用方法应该是把 Inbox 视为一个 tmp，在阅读完邮件后，该删除的删除、该归档的归档、该打标签的打标签，就像保持桌面整洁一样 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 事实上，Inbox 只是一个标签，所谓 归档（Archive） 就是删除这个标签，一份处理完的邮件不再应该打上 Inbox 的标签，所以我们要进行归档 。&lt;/p&gt;
&lt;h3&gt;标签 &amp;amp; 文件夹&lt;/h3&gt;
&lt;p&gt;Gmail 使用了标签代替文件夹，真是一个革命性的创举 。&lt;/p&gt;
&lt;p&gt;帮助里面[列举][lable]了 标签 相比于 文件夹 的优势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个会话可以拥有一个以上的标签，而一封邮件只能放在一个文件夹中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话可以同时存在于多个位置（收件箱、所有邮件、已发邮件等等），便于日后查找 。而在文件夹中，您必须记住邮件的存档位置，才能找到它 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;您可以利用标签对会话进行搜索，而您不可能总是在文件夹内进行搜索 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，我们需要做的就是阅读邮件，然后按照邮件的属性，给它打上标签（label），比如私人邮件、工作邮件、学习邮件、注册验证邮件、社交邮件等等 。每种表情可以自定义颜色，按照邮件在我们心目中的重要程度，给每种标签赋予不同的颜色，一眼看上去，简洁明了，而且很好看 。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://support.google.com/mail/answer/118708?rd=1"&gt;了解如何创建、修改、删除和搜索标签&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;星标邮件 &amp;amp; 重要邮件&lt;/h3&gt;
&lt;p&gt;Gmail 提供了自动识别邮件重要性的功能，它可以根据算法，用户使用习惯等自动识别，标记一个邮件是否是 “重要的”，除此之外，我们可以自己给邮件打星标，来标记邮件的重要程度 。&lt;/p&gt;
&lt;p&gt;根据我的使用习惯，感觉超过 5 个标签，就有点让人迷惑了，所以，我使用的星标一共有 4 个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黄色星星   表示一般重要文件&lt;/li&gt;
&lt;li&gt;红色叹号 表示非常重要邮件&lt;/li&gt;
&lt;li&gt;紫色问号   表示未处理完，将来还需要处理&lt;/li&gt;
&lt;li&gt;绿色对号   表示已经处理完，暂时一段时间都不需要处理的邮件，除非我手动搜索&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;has&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;过滤器&lt;/h3&gt;
&lt;p&gt;使用强大的过滤器，我们可以让 Gmail 实现自动对邮件进行分类&lt;/p&gt;
&lt;p&gt;比如，邮件里包含 “注册”、“激活”、“Active”、“Registration”、“Verify” 等单词，就可以自动打上 “注册验证”标签 。&lt;/p&gt;
&lt;p&gt;再比如，为转发邮箱 QQ mail 或者 163 邮箱设置自动打标签，标记为已读，自动存档、转发、删除等 。&lt;/p&gt;
&lt;h3&gt;实验室功能&lt;/h3&gt;
&lt;p&gt;Gmail 实验室有一些很好玩的功能，比如在邮件中看 Google Map，查看 Google Calendar，取消发送等 。至于 Google 目前主推的 Google+ 和 Google Drive 已经整合进 Gmail 了 。&lt;/p&gt;
&lt;p&gt;强大的 Gmail 真是让人越用越不释手 :-D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://xuyazhou.com/archives/248"&gt;收发Gmail 必学12招，善用邮件分类、前端管理当Gmail 达人&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.acgtyrant.com/how-to-use-gmail-and-mailinglist-correctly.html"&gt;如何優雅地使用 Gmail &amp;amp; Mailing List&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/topic/19550519/top-answers?page=1"&gt;知乎 Gmail 精华问题&lt;/a&gt;&lt;/p&gt;</summary><category term="Gmail"></category></entry><entry><title>在 Ubuntu 下运行 WarCraft</title><link href="http://guqian110.github.io/pages/2014/04/10/run_warcraft_on_ubuntu.html" rel="alternate"></link><updated>2014-04-10T10:58:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-10:pages/2014/04/10/run_warcraft_on_ubuntu.html</id><summary type="html">&lt;p&gt;闲来无聊，在 Ubuntu 下 wine 了一个 WarCraft 3 玩&lt;/p&gt;
&lt;p&gt;在实验室的 ”老爷车“ 电脑上运行。稍微有一点卡，在5年前买的笔记本（core 2 T6600, 4G RAM）上运行就感觉不到卡了 。&lt;/p&gt;
&lt;p&gt;实验室电脑配置：&lt;/p&gt;
&lt;p&gt;Processor: Pentium(R) Dual-Core CPU E5200 @ 2.50GHz × 2 &lt;/p&gt;
&lt;p&gt;Graphics: Gallium 0.4 on NV86&lt;/p&gt;
&lt;p&gt;Memory: 2.0 GiB&lt;/p&gt;
&lt;p&gt;OS type: 32-bit&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;安装 Wine&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Wine_(software)"&gt;Wine&lt;/a&gt; 是 wine is not an emulator 的缩写，它可以在 x86、x86-64 上容许类 Unix 操作系统在 X Window System 下运行 Microsoft Windows 程序的软件 .它的官方网址：http://www.winehq.org/&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;Ubuntu 软件仓里搜索 Wine，就可以找到 &lt;code&gt;Wine Windows Program Loader&lt;/code&gt;，直接安装即可&lt;/p&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;apt-get&lt;/code&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="n"&gt;wine&lt;/span&gt;
&lt;span class="n"&gt;suod&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;wine&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;P.S. 若是其他系统，找不到对应的二进制包，可以直接从官网上下载源码，自己编译（官网上有详细的 &lt;a href="http://wiki.winehq.org/FAQ_zhcn"&gt;FAQ&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;拷贝 WarCraft&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;如果是双系统，则不必拷贝 WarCraft 文件夹，因为我电脑上只有 Ubuntu，所以从同学那里拷贝了一个，放在了 &lt;code&gt;～/&lt;/code&gt; 目录下 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;配置 Wine &amp;amp; WarCraft&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;CD key 注册表问题&lt;/h3&gt;
&lt;p&gt;直接以 wine 运行 &lt;code&gt;war3.exe&lt;/code&gt; 时提示没有 CD key，在 WarCraft 目录下找到了两个注册表文件，&lt;code&gt;War3.reg&lt;/code&gt; 和 &lt;code&gt;一键导入.reg&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在终端下导入注册表&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;regedit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;然后导入这两个文件，再次尝试，还是不行...&lt;/p&gt;
&lt;p&gt;不急，游戏目录下还有一个程序叫 &lt;code&gt;War3RegFixer.exe&lt;/code&gt;，看名字就知道是我们需要的&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;War3RegFixer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;因为我的 Ubuntu 是英文版的，打开后是乱码...&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3regfixer" src="/images/run-warcraft-on-ubuntu/war3regfixer.png" /&gt;&lt;/p&gt;
&lt;p&gt;找了一台 Windows 电脑，运行了一下，按照向导就可以修复 CD key 的问题 。&lt;/p&gt;
&lt;h3&gt;分辨率问题&lt;/h3&gt;
&lt;p&gt;第一次运行的结果一般不会全屏，处女座的强迫症犯了，还好比较简单 ：D&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;regedit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;找到 &lt;code&gt;HKEY_CURRENT_USER/Software/Blizzard Entertainment/Warcraft III/Video&lt;/code&gt;，里面有两个注册表值 &lt;code&gt;resheight&lt;/code&gt; 和 &lt;code&gt;reswidth&lt;/code&gt;，将他们设为和当前分辨率相同的十进制数值就可以了。&lt;/p&gt;
&lt;h3&gt;画面卡&lt;/h3&gt;
&lt;p&gt;因为 Wine 对 DirectX 的支持还不够好，如果电脑配置比较低，运行的时候添加参数 &lt;code&gt;-opengl&lt;/code&gt; 就可以了，为了避免每次运行都要输入参数，可以在注册表 &lt;code&gt;HKEY_CURRENT_USER/Software/Blizzard Entertainment/Warcraft III/&lt;/code&gt; 下新建整数（DWORD），名为 &lt;code&gt;Gfx OpenGL&lt;/code&gt;，值为 1 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;h3&gt;终端下&lt;/h3&gt;
&lt;p&gt;现在就可以在终端下运行 war3.exe 了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;war3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;熟悉的画面就出来了～&lt;/p&gt;
&lt;p&gt;这样子运行如果切出游戏，有时会导致 war3 崩溃或者切换不出去。一个解决方法是以窗口模式运行，只需要添加参数 &lt;code&gt;-window&lt;/code&gt; 即可&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;war3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;window&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;效果如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3window" src="/images/run-warcraft-on-ubuntu/war3window.png" /&gt;&lt;/p&gt;
&lt;p&gt;不过个人不是很喜欢，因为鼠标总是超出窗口，极其不方便，影响游戏操作和感受 ：D&lt;/p&gt;
&lt;h3&gt;桌面启动器&lt;/h3&gt;
&lt;p&gt;我们可以为 war3 添加一个桌面启动器，这样就不用进入终端启动了&lt;/p&gt;
&lt;p&gt;新建文件 &lt;code&gt;frozen-throne.desktop&lt;/code&gt; 文件，添加以下内容&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[Desktop Entry]&lt;/span&gt;
&lt;span class="na"&gt;Version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1.0&lt;/span&gt;
&lt;span class="na"&gt;Name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;Frozen Throne&lt;/span&gt;
&lt;span class="na"&gt;Exec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/home/chien/WarCraft/war3.exe&lt;/span&gt;
&lt;span class="na"&gt;Terminal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;false&lt;/span&gt;
&lt;span class="na"&gt;Icon&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/home/chien/WarCraft/war3.jpg&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;Application&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;然后把这个文件移动到 &lt;code&gt;/usr/share/applicants/&lt;/code&gt; ，这时在 unity 中搜索 &lt;code&gt;froz&lt;/code&gt;，就能看到我们刚才新建的启动器了～&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3desktop" src="/images/run-warcraft-on-ubuntu/war3desktop.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;至此，就可以在 Ubuntu 下享受 War3 了&lt;/p&gt;
&lt;p&gt;gl hf！&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://linux-wiki.cn/wiki/zh-hans/%E7%94%A8Wine%E8%BF%90%E8%A1%8C%E9%AD%94%E5%85%BD%E4%BA%89%E9%9C%B8III"&gt;用Wine运行魔兽争霸III&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.ubuntusoft.com/wine-warcraft-3.html#.U0Xt11SSx38"&gt;Wine 魔兽争霸3的一些设置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://hi.baidu.com/chenwzox/item/4e6346f1575a7ab231c199b4"&gt;Wine魔兽争霸3，流畅运行+键盘操作+窗口化&lt;/a&gt;&lt;/p&gt;</summary><category term="Wine"></category><category term="WarCraft"></category></entry><entry><title>乔布斯传 书评</title><link href="http://guqian110.github.io/pages/2014/04/09/steve_jobs_review.html" rel="alternate"></link><updated>2014-04-09T17:14:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-09:pages/2014/04/09/steve_jobs_review.html</id><summary type="html">&lt;p&gt;一直想买本 &lt;a href="http://book.douban.com/subject/6798611/"&gt;《乔布斯传》&lt;/a&gt;，但是被 ￥68.00 的定价击败了，舍不得花钱买 :D 但是电子书的体验真的太差，看了一半就没有坚持下来。突然发现有个同学有本崭新的《乔布斯传》，于是借来用闲暇时间看了一个多月才看完...&lt;/p&gt;
&lt;p&gt;作为一名资深“挨踢”菜鸟，乔布斯的名字可以说是如雷贯耳，他在普通人眼中，尤其是果粉眼中，基本上就是神一般的存在。以前我也一直这么认为，直到看完这本书，我才发现事实中的“乔帮主”完全是另外一个人，一个有爱有恨，爱哭，执着的同时执着到固执的地步，毫不做作的一个人。&lt;/p&gt;
&lt;p&gt;写几点感触吧，以证明没有白看这本书，看书的价值就在与思考～&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;爱哭的教主&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这是我看书时，最惊奇的地方。有网友统计，传记里记载的乔布斯一共哭泣了 157 次，其中哭倒在地 25 次，大哭并尖叫 34 次，泪流满面 42 次。以前觉得神一样的“乔帮主”肯定是神挡杀神，佛挡杀佛，怎么会动不动就哭鼻子呢。联系他的人生经历，原来这样子更符合他的性格 。&lt;/p&gt;
&lt;p&gt;在知乎上看到&lt;a href="http://www.zhihu.com/question/19875002"&gt;一个回答&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;乔布斯是一个多愁善感的人，他经常哭。他从小就发现这种方式能达到目的。我觉得实际上他是那种不去刻意控制自己情绪的人，想哭就哭，想骂就骂，想夸就夸，不受限制。我们所知道的他哭的例子，只不过是几个很有名的瞬间，被放大了。&lt;/p&gt;
&lt;p&gt;我们从小就被"男儿有泪不轻弹"给害了，变成了貌似坚强，却浅了情感。&lt;/p&gt;
&lt;p&gt;i hope i can cry when i want to.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或许，这样率性，真实的人生是另外一种更值得追求的选择，只是这种性格注定只有两种结局：1. 你很nb，可以把内心的真实想法随意说出来，别人即使很不爽，但是也不能对你怎么样，甚至尊敬你，这种最典型的就是yy小说中的主人公，而现实生活中则没几个，乔布斯就是典型例子；2. 你自己没有什么本事，还有一身尖酸刻薄的臭脾气，最后只能是连一个朋友也没有，一事无成。而大多数人，都会选择作出“正确”的选择——尽量修炼自己，积累知识，同时在这个人情冷漠的年代找到一两个好朋友和“红颜／蓝颜知己” 。&lt;/p&gt;
&lt;p&gt;不是任何一个人想哭就能哭的，这也是需要一定资本足够nb才行...&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ithome.com/html/it/50290.htm"&gt;乔布斯为何而哭？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;嬉皮士＆禅宗＆迷幻药＆现实扭曲力场&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;乔布斯由于自己身世的原因，总是对这种追求人生真谛的事很感兴趣 。（前半句为个人猜测，后半句是事实）他经历了嬉皮士运动，去印度寻找过 “精神导师”，嗑过迷幻药，在遇到罗伯特 弗里德兰之前，他羞涩又谦逊，非常内敛，但是很快他就学会了弗里德兰的强大气场，并且发展成为自己著名的“现实扭曲力场” 。&lt;/p&gt;
&lt;p&gt;乔布斯从来都不是标准意义上的“好学生”，相反，他叛逆，敏感，但是他也喜欢思考，在养父的影响下，他培养出了对细节要求到苛刻的“工匠精神” 。他直接给惠普的创始人打电话要求一份临时工的工作，参见工程师的会议，探索自己感兴趣的电路，和沃兹一起做出 “能打电话的盒子”，大发一笔 。另一方面，他又直接逼自己的养父母同意退学，去了里德学院，结果还是不去上课，上了一半就退学了 。&lt;/p&gt;
&lt;p&gt;这样的上学经历，在中国人看来，真的是无可就药，他能有后来的成就真的是不可思议。我好像为自己翘课，学习成绩不好找到了一个完美的借口...关于为什么中国出不了乔布斯，中外教育制度差别等话题都被谈烂了，个人认为，外界的客观环境是一方面，自身的努力也很重要（不仅中国出不了乔布斯，事实上，全世界也就这么一位，在美国，乔布斯也不是普通人能效仿的，不然美国遍地都是乔布斯了 -.-）。&lt;/p&gt;
&lt;h2&gt;站在人文与科技的十字路口&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://apple4us.com/2011/10/jobs-begin-end.html"&gt;乔布斯：初心与终点&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;乔布斯是令人倾慕的天才、艺术家、犀利的商业决策者，而他亦正亦邪的浪子一面，暴君般肆虐、魔鬼般欺骗、傀儡师般操控他人，则平添戏剧性和张力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;乔布斯与他的同行们不同。盖茨、Facebook 的扎克伯格和亚马逊的贝佐斯们所致力的，都是将技术融入生活：无论让每户人家的桌子上摆一台电脑、让每个人将自己的身份及社会关系映射到互联网上，还是通过互联网销售书籍、音乐和电影。他们像工业革命时代掌握蒸汽机的人一样，以更高级的技术破坏既有的世界规则，并以此打造庞大的商业帝国 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而科技对于乔布斯，更像画笔之于梵高、刻刀之于米开朗基罗。他热爱美好的事物，也希望自己成为一名创作者。自 21 岁创立苹果电脑，到 56 岁宣布退休，35 年间他主导设计的软、硬件各超过百款，而在美国商标专利局备案的署有他的名字的专利就多达 300 余个——相比之下，拥有更深厚技术背景的盖茨名下的专利不过九项、Google 的两名创始人拉里·佩奇和谢尔盖·布林拥有的专利总和也没超过 20 个 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前美国的专利申请很宽松，乔帮主的专利大多数应该是设计方面的吧，而佩奇的专利明显更有技术含量 。&lt;/p&gt;
&lt;p&gt;乔帮主最看不上盖茨的就是 “糟糕的品味”，而盖茨也在访谈中承认自己最想拥有的就是一流的品味。两个人的人生轨迹完全不同，代表了完全相反的两条路，却最终成一生的对手和朋友，多么神奇 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;控制欲&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;乔帮主追求完美的欲望和控制欲强烈到一种不可思议的地步，他想控制产品的方方面面，不但是用户体验，甚至不想让用户拆开 Mac，iphone；里面的电路也和外面一样精致，即使用户永远都不会看到。用户买来直接用就行了，其他的全部由他，苹果公司负责，甚至他认为用户从来不知道自己需要什么样的产品，如汽车的发明人福特说的一样——”在我发明汽车以前，人们只会想买一辆什么样的马车“ 。&lt;/p&gt;
&lt;p&gt;他的这种控制欲望能成功，是建立在高雅的品味之上的。这种软件、硬件一体化，端到端的产品更本轮不到用户插手，这和 Geek 精神完全相悖，在 Apple I 时，他和沃兹的分歧就已经出现了，最终以教主的痛哭流涕收场。幸好这个世界上 Geek 只是少数，幸好他的艺术品味一流高雅，发明了改变P C、手机、动画、音乐等行业的产品，让我们体验到什么是美好的产品 。&lt;/p&gt;
&lt;p&gt;但是这种控制欲和他的 ”现实扭曲力场“ 也有副作用。在饮食上他是严格的素食主义者，面对他得癌症的现实，他也选择性的忽略，即使后来身体状况很糟糕了，他仍然只吃蔬菜和水果。如果他能及早面对癌症肿瘤，或许可以在扩散之前就控制住病情，但是他是乔布斯，所以他不会这样。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Jobs 像个任性的大孩子，尽情挥洒着自己的才能，永不停歇的迈向理想。留给中国人太多感动和反思 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ithome.com/html/it/50290.htm"&gt;乔布斯为何而哭？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://apple4us.com/2011/10/jobs-begin-end.html"&gt;乔布斯：初心与终点&lt;/a&gt;&lt;/p&gt;</summary><category term="Steve Jobs"></category><category term="review"></category></entry><entry><title>C++ const 限定符</title><link href="http://guqian110.github.io/pages/2014/04/09/cosnt_qualifier.html" rel="alternate"></link><updated>2014-04-09T11:13:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-09:pages/2014/04/09/cosnt_qualifier.html</id><summary type="html">&lt;h2&gt;为什么要使用 const 限定符&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;一个需要使用 const 的简单例子&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;&lt;em&gt;C++ Primer&lt;/em&gt;&lt;/a&gt; 中的例子&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这段代码语法上是没有问题的，但是事实上是有两个小问题的，而且两个小问题都和数字 &lt;code&gt;512&lt;/code&gt; 有关 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个问题是 程序的可读性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较 &lt;code&gt;index&lt;/code&gt; 与 &lt;code&gt;512&lt;/code&gt; 有什么意思呢？也就是说 512 这个值作用何在？在程序中这种数字被称为 &lt;code&gt;魔数（magic number）&lt;/code&gt;，它的意义在上下文中没有体现出来，好像这个数是凭空魔术般变出来的 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个问题是 程序的可维护性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如歌这个程序非常庞大，512 这个数字出现了 100 次，进一步假设这 100 次中，有 80 次是表示某个缓冲区的大小，剩余 20 次用于其他目的 。现在，我们需要把缓冲区的大小增大到 1024，要实现这个目标，必须检查每个 512 出现的位置，必须确定哪些是表示缓冲区大小，哪些不是 。&lt;/p&gt;
&lt;p&gt;解决这两个问题的方法是定义一个变量，并且初始化为 512&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;通过定义一个好记的变量，就可以增强程序的可读性，而且需要改变这个值时，只需要咋初始化的地方做修改 。这种方法不仅明显减小了工作量，而且大大减小了出错的可能性 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;看起来问题好像已经解决了，但是，事实上，我们可以进一步&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在上面的代码中，&lt;code&gt;buf_size&lt;/code&gt; 是可以被修改的，它有可能会被有意或者无意修改 。为了避免这种情况，就需要使用 const 限定符了 。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;定义 &lt;code&gt;buf_size&lt;/code&gt; 为 &lt;strong&gt;常量（constant）&lt;/strong&gt;，并且初始化为 512 .&lt;strong&gt;变量（variable）&lt;/strong&gt; &lt;code&gt;buf_size&lt;/code&gt; 仍然是一个左值，但是这个左值现在是不能被修改的。（因为 const 把变量转化为常量，所以在定义的时候必须初始化！）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何使用 const 限定符&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;C++ Primer 中有这么一句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It (const) transforms an object into a constant.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是在这句话之后有说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The variable bufSize is still an lvalue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是矛盾的，因为常量是不能当左值的 。个人感觉严谨的说法应该是 "cosnt 使变量具有了常量的属性“&lt;/p&gt;
&lt;h3&gt;文件的局部变量&lt;/h3&gt;
&lt;p&gt;const 限定符修同时也改变了变量的作用范围 。普通非 const 变量的默认是具有 &lt;em&gt;外部连接（external linkage）&lt;/em&gt;的，在全局作用域内定义非 const 变量时，它在整个程序中都可以被访问 。比如&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file1.cpp&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;//file2.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;但是，对于 全局作用域内的 const 类型的对象，其默认是 &lt;em&gt;内部连接（internal linkage）&lt;/em&gt;，仅在定义该对象的文件内可见，不能被其他文件访问 。要想在整个程序里面访问，就必须在定义的时候显式地声明为 &lt;code&gt;extern&lt;/code&gt; 类型 。比如&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//file1.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fcn&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//fiel2.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;使用 const 的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义在头文件中 inlcude&lt;/p&gt;
&lt;p&gt;如果 const 变量是用常量表达式初始化的，那么就可以把它的定义放在头文件中，即使多次包含这个头文件也不会产生 ”重定义“  的问题 。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file1.h&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// file2.cpp&lt;/span&gt;
&lt;span class="n"&gt;include&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;file1.h&amp;quot;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义时声明为 extern&lt;/p&gt;
&lt;p&gt;如果 const 变量不是用常量表达式初始化的，那么就不能把它当在头文件中 。只能在源文件中定义并初始化 。因为 const 变量是文件局部变量，所以要在其他文件中使用该变量，必须在定义时加上 &lt;code&gt;extern&lt;/code&gt; 声明 。&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file1.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在头文件中声明为 extern 类型，以使其他文件共享。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file1.h&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// fil2.cpp&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;file1.h&amp;quot;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不需要在头文件中声明，在其他文件中使用前声明&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file2.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 在 C 中 const 是默认为外部连接的，在 C++ 中是默认为内部连接的 。&lt;/p&gt;
&lt;p&gt;至于为什么要这么规定，&lt;a href="http://book.douban.com/subject/1459728/"&gt;Thinking in C++&lt;/a&gt; 中有说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Constants were introduced in early versions of C++ while the Standard C specification was
still being finished. It was then seen as a good idea and included in C. But somehow, const in
C came to mean “an ordinary variable that cannot be changed.” &lt;em&gt;In C, it always occupies
storage and its name is global. The C compiler cannot treat a const as a compile-time
constant.&lt;/em&gt; In C, if you say&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;you will get an error, even though it seems like a rational thing to do. Because bufsize
occupies storage somewhere, the C compiler cannot know the value at compile time.&lt;/p&gt;
&lt;p&gt;In C++, a const doesn’t necessarily create storage. In C a const always creates storage.
Whether or not storage is reserved for a const in C++ depends on how it is used. In general, if
a const is used simply to replace a name with a value (just as you would use a #define), then
storage doesn’t have to be created for the const. If no storage is created (this depends on the
complexity of the data type and the sophistication of the compiler), the values may be folded
into the code for greater efficiency after type checking, not before, as with #define. If,
however, you take an address of a const(even unknowingly, by passing it to a function that
takes a reference argument) or you define it as extern, then storage is created for the const.&lt;/p&gt;
&lt;p&gt;Since a const in C++ defaults to internal linkage, you can’t just define a const in one file and
reference it as an extern in another file. To give a const external linkage so it can be
referenced from another file, you must explicitly define it as extern, like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Notice that by giving it an initializer and saying it is extern, you force storage to be created for the const(although the compiler still has the option of doing constant folding here). The
initialization establishes this as a definition, not a declaration. The declaration:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;in C++ means that the definition exists elsewhere (again, this is not necessarily true in C).
&lt;em&gt;You can now see why C++ requires a constdefinition to have an initializer: the initializer
distinguishes a declaration from a definition (in C it’s always a definition, so no initializer is
necessary).&lt;/em&gt; With an external constdeclaration, the compiler cannot do constant folding
because it doesn’t know the value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;const 引用 &amp;amp; const 对象&lt;/h3&gt;
&lt;p&gt;在引用的定义中声明 const，此 const 约束的是引用，而不是引用的对象 。比如&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;其中，&lt;code&gt;const&lt;/code&gt; 修饰的是 &lt;code&gt;int &amp;amp;&lt;/code&gt;，规定了引用 &lt;code&gt;ref&lt;/code&gt; 为 const 类型变量，而 &lt;code&gt;ival&lt;/code&gt; 的类型则由其他语句定义说明 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const 引用： 引用变量为 const 类型，引用对象的类型可以是 const、nonconst、r-value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nonconst 引用： 引用变量为 nonconst 类型，引用对象只能是同类型的 nonconst 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为引用只是对象的另外一个名字，它们指向的是统一块内存空间，所以通过修改引用的值就能达到修改对象的值的目的 。&lt;/p&gt;
&lt;p&gt;当对象是 const 类型时，隐含的含义是该对象不能被修改，所以只能定义 const 类型的引用指向它；nonconst 类型的引用隐含的意思是可以通过引用修改对象值，这对于 const 类型的对象来说是不允许的 。&lt;/p&gt;
&lt;p&gt;当对象是 nonconst 类型时，隐含的含义是该对象可以通过引用来修改，此时，const 引用和 nonconst 引用都可以指向该对象 。当使用 nonconst 引用时，可以通过引用修改对象的值；当使用 const 引用时，虽然对象的值是可以改变的，但是不能通过该引用修改，因为引用的类型是 const，定义以后，不能再修改 。 &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;何时应该使用 const&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Scott Meyers 大神的经典著作 &lt;a href="http://book.douban.com/subject/1842426/"&gt;Effective C++&lt;/a&gt; 里面提到的关于 const 的使用 。&lt;/p&gt;
&lt;h3&gt;Effective C++ 条款 02：尽量以 const、enum、inline 替换 #define（Prefer consts,enums,and inline to #define）&lt;/h3&gt;
&lt;p&gt;使用const 代替 #define，事实上 &lt;code&gt;const&lt;/code&gt; 的最初动机就是取代预处理器 &lt;code&gt;#define&lt;/code&gt; 来进行值替代 。因为 #define 不被视为语言的一部分，这就是它的问题所在 。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define ASPECT_RATIO 1.653;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;记号名 ASPECT_RATIO 也许从未被编译器看见，也许在编译器开始处理代码前就被与处理器移走了，于是记号没有进入记号表，当出现编译错误时，也许会提示是 1.653 而不是 ASPECT_RATIO，这回带来很多困惑 。&lt;/p&gt;
&lt;p&gt;解决之道就是以一个常量代替上述的宏&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;AspectRatio&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.653&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;Effective C++ 条款 03：尽可能使用 const（Use const whenever possile）&lt;/h3&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1459728/"&gt;Thinking in C++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1842426/"&gt;Effective C++&lt;/a&gt;&lt;/p&gt;</summary><category term="const"></category></entry><entry><title>脉冲边沿检测</title><link href="http://guqian110.github.io/pages/2014/04/08/pulse_edge_detection.html" rel="alternate"></link><updated>2014-04-08T18:33:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-08:pages/2014/04/08/pulse_edge_detection.html</id><summary type="html">&lt;p&gt;脉冲边沿检测是 FPGA 设计中经常用到的方法，本文总结一下其原理和实现代码，可以将其加入我们自己的代码库中，以备以后使用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测原理&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="pulse" src="/images/learning-fpga-pulse-edge-detection/pulse.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如图，任何一个脉冲既有上升沿也有下降沿，系统的时钟周期一定要比脉冲宽度小，而且越小越好，即频率越高越好 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脉冲边沿的特点就是：边沿两侧的电平发生了变化 。&lt;/strong&gt; 利用这一点，我们就可以设计出检测边沿的方法 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作方法：&lt;/strong&gt; 建立 2 个寄存器，形成二级寄存器，在时钟触发中，首先把数据送入第一个寄存器中，然后在下一个时钟上沿到来时，将第一个寄存器中的数据存入第二个寄存器，也就是说第二个寄存器中的数据始终比第一个寄存器晚一个周期，即晚一个数据 。根据系统时钟检测，如果前后进来的信号发生了变化，可以用异或运算，异或结果为1，说明电平发生了变化，有边沿产生。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测方法&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;检测是否有边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_edge&lt;/span&gt;  
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trigedge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;end&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;end&lt;/span&gt;  
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trigEdge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl1" src="/images/learning-fpga-pulse-edge-detection/rtl1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim1" src="/images/learning-fpga-pulse-edge-detection/sim1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;检测 上/下 边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;下降沿检测原理：&lt;/strong&gt; 将第一个寄存器中的数据取反与第二个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 1 变为 0 时，就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上升沿检测原理：&lt;/strong&gt; 将第二个寄存器中的数据取反与第一个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 0 变为 1 时（上升沿，此时 r1 变为 1，但 r2 仍保持前一周期的 0），就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;end&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;end&lt;/span&gt;  
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// Detect posedge  &lt;/span&gt;
    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// Detect negedge&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl2" src="/images/learning-fpga-pulse-edge-detection/rtl2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim2" src="/images/learning-fpga-pulse-edge-detection/sim2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外一种写法：&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tirg_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;3&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;2&amp;#39;b01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;2&amp;#39;b10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl3" src="/images/learning-fpga-pulse-edge-detection/rtl3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim3" src="/images/learning-fpga-pulse-edge-detection/sim3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测应用&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;理想的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard1" src="/images/learning-fpga-pulse-edge-detection/keyboard1.png" /&gt;&lt;/p&gt;
&lt;p&gt;然而实际的键盘受制造工艺等影响，其输入特性不可能如上图完美 。当按键按下时，在触点即将接触到完全接触这段时间里，键盘的通断状态很可能已经改变了多次 。即在这段时间里，键盘输入了多次逻辑 0 和 1，也就是输入处于失控状态 。如果这些输入被系统响应，则系统暂时也将处于失控状态，这是我们要尽量避免的 。在触点即将分离到完全分离这段时间也是一样的 。&lt;/p&gt;
&lt;p&gt;实际的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard2" src="/images/learning-fpga-pulse-edge-detection/keyboard2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件消抖&lt;/strong&gt; 要占用系统资源，在系统资源充足的情况下使用软件消抖更加简单 。软件消抖的实质在于降低键盘输入端口的采样频率，将高频抖动略去 。实际应用中通常采用延时跳过高频抖动区间，然后再检测输入做出相应处理。一般程序代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c1"&gt;//一旦检测到键值&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Delay&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;//延时20ms，有效滤除按键的抖动&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;//再次确定键值是否有效&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;    &lt;span class="c1"&gt;//执行相应处理&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这段软消抖程序从机理上看不会有什么问题，通常在软件程序不太 "繁忙" 的情况下也能够很好的消抖并做相应处理 。但是如果在延时期间产生了中断，则此中断可能无法得到响应 。&lt;/p&gt;
&lt;p&gt;对于硬件资源丰富的 FPGA 系统，可以使用硬件来减轻软件工作量，通常称之为 &lt;strong&gt;"硬件加速"&lt;/strong&gt; 。在按键信号输入到软件系统前用逻辑对其进行一下简单的处理即可实现所谓的"硬件消抖"，代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//对输入信号inpio硬件滤波，每20ms采样一次当前值&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//20ms计数器&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;19&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;19&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d500000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; 
        &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;19&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//当前inpio信号锁存，每20ms锁存一拍&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;2&amp;#39;b11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;19&amp;#39;h7ffff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;inpio_swin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//前后20ms两次锁存值都为0时才为0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;该程序中设置了一个 20 ms 计数器，通过间隔 20 ms 对输入信号 inpio 采样两次，两次相同则认为键盘输入稳定，得到用硬件逻辑处理后的 inpio_swin 信号则是消抖处理过的信号 。程序不再需要 delay() 来滤波了，也不会出现使用纯软件处理出现的 "中断失去响应" 的情况了，这就是 "硬件加速" 的效果 。&lt;/p&gt;
&lt;p&gt;我们可以看到，传统单片机等系统大多是串行处理，即顺序执行，只能并行处理一些中断程序 。对于这样的系统，只能采用单纯软件或硬件电路消抖，但都不那么完美 。而对于 FPGA 等并行处理的系统，其优势就很明显，只要片内逻辑资源够用，通过硬件加速软件消抖的处理，完全可以做到按键消抖并行化，不影响系统的实时性 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_213430.HTM"&gt;脉冲边沿检测（Verilog）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/lg2lh/article/details/8104551"&gt;脉冲边沿检测原理verilog版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/LVY33/article/details/6225925"&gt;脉冲边缘检测法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_790c0ca10100srid.html"&gt;按键消抖&lt;/a&gt;&lt;/p&gt;</summary><category term="pulse edge detection"></category></entry><entry><title>(转载) 如何学习 FPGA</title><link href="http://guqian110.github.io/pages/2014/04/07/learning_fpga_how_to.html" rel="alternate"></link><updated>2014-04-07T16:16:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-07:pages/2014/04/07/learning_fpga_how_to.html</id><summary type="html">&lt;p&gt;学习 FPGA 差不多一年多，长期混迹于各大论坛，让我学习到了很多知识，转载一篇文章。&lt;/p&gt;
&lt;p&gt;当年在对于 FPGA 什么都不懂的情况下，觉得这篇文章相当高大上，现在看来，的确如此～和别的入门级别的文章书籍相比，这篇文章没有涉及 FPGA 设计的细节，而是很精炼地讲了 FPGA 设计中最基本的 &lt;em&gt;“世界观”&lt;/em&gt; 。也就是说这篇没有一头扎进 &lt;strong&gt;“术”&lt;/strong&gt; 的内容中让读者无从读起，而是从整体上给出 FPGA 设计的 &lt;strong&gt;“道”&lt;/strong&gt; 。对于初学者——尤其是我这样从软件思维过渡过来的人，的确是不错的入门指导 。&lt;/p&gt;
&lt;p&gt;转载地址：&lt;a href="http://www.ednchina.com/ART_8800513345_18_20010_TA_38ec22f4.HTM"&gt;如何学习FPGA？FPGA学习必备的基础知识&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;FPGA已成为现今的技术热点之一，无论学生还是工程师都希望跨进FPGA的大门。网络上各种开发板、培训班更是多如牛毛，仿佛在告诉你不懂FPGA你就OUT啦。那么我们要玩转FPGA必须具备哪些基础知识呢?下面我们慢慢道来。&lt;/p&gt;
&lt;h2&gt;要了解什么是FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;既然要玩转FPGA，那我们首先最重要的当然是要了解什么 FPGA 。FPGA（Field-Programmable Gate Array），即现场可编程门阵列 。看到编程两个字码农就笑了，不就是编程嘛，那可是我们的强项 。且慢，此编程非彼编程 。一定要把 FPGA 的编程和软件编程区分开来 。软件的编程，处理器会逐条的把语言翻译成各种控制信号，去控制内部电路完成一个个运算或操作 。那么FPGA的编程是怎么实现的呢？无论 Altera 家还是 Xlinix 家的 FPGA，叫法有什么差异，基本单元都相似，都是由真值表和 D 触发器构成 。改变真值表的值就改变了逻辑功能，再通过和D触发器组合来实现任何时序逻辑 。所以我们对 FPGA 的编程，实际上就是去修改这些真值表和连接关系，使他们组成一张专门的真值表，去实现特定的功能 。这和软件编程一步步运行程序有本质的区别 。要想玩转 FPGA，就必须理解 FPGA 内部的工作原理，学习如何利用这些单元实现复杂的逻辑设计 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;正确理解HDL语言&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;HDL（Hardware Description Language），硬件描述语言 。通过名称我们能看出来，HDL语言是一种 “描述” 语言，这一点和 C 语言是有本质区别的 。正确理解描述的含义，对学好 HDL 语言很有帮助 。HDL 语言只是用文本的方式把硬件电路描述出来 。我们在阅读 HDL 程序的时候，在脑子里应该能反映出一个完整的硬件电路结构 。从另一方面说，我们在编写 HDL 语言之前，就已经对要实现的电路有清晰的概念 。所以 HDL 语言只是一个描述我们头脑中具体电路的工具，&lt;strong&gt;玩转 FPGA 的根本不是语言而是逻辑电路设计&lt;/strong&gt;。不要再纠结于我应该学习 VHDL 还是 Verilog，哪种语言更好学这些问题 。如果把学习 FPGA 的重点放在学习语言上，死记硬背一些语法，那自然是抓错了重点 。语言在日常使用中会越用越熟练，不需要花很长的专门时间去学习 。当然一本好的参考资料可以随时方便查询会是很有帮助的 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;数字电路基础&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;说到底，FPGA 就是一堆数字逻辑组合在一起实现特定功能而已 。所以数字电路基础知识是根本 。如果你连触发器，组合电路，时序电路，竞争，毛刺等等基本概念还莫能两可不清不楚的话，那玩转 FPGA 只能是痴人说梦的幻想了 。我们必须要好好的学好数字电路基础这门课，基本的数字电路烂熟于心 。把这些基础打牢固，再往更深的方向发展 。什么时候能够从抽象的算法中提炼算法的结构，再分解成具体的模块并通过硬件电路实现出来，这时候就算从菜鸟级别步入老鸟级别了 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;硬件设计思想&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这一点应该说是重中之重 。学习 FPGA，一定要有硬件设计思想 。在软件编程的时候，比如 1 秒钟能实现 5 次乘法运算，那系统要求 1 秒钟实现 50 次乘法运算怎么办，我们会尽可能的优化代码，让代码更简洁更高效，或者提高系统主频，让系统跑的更快 。但是在 FPGA 里面我们不是这种思维方式。在 FPGA 里实现一个乘法器不够用，那我就实现两个实现三个去满足系统要求；我可以进行流水线设计；串行运行方式不够快了，我可以先串并转换，再并行的做处理 — —只要 FPGA 的资源够用，我可以充分利用资源去满足系统要求 。因为在我手里的就是一堆硬件资源，我要做的是把他们组合成一个好用的电路 。评价硬件描述语言写的好坏的标准和其他软件编程语言的标准是完全不同的 。因此一定要摒弃软件编程的一些固有思路，学会用硬件的方式去解决问题 。时刻提醒自己正在设计的是一个电路，而不是一行行空洞的代码 。这是很多做软件编程的人很难跨过的坎 。FPGA 学了很久还在纠结到底是用 &lt;code&gt;if-else&lt;/code&gt; 语句好呢还是用 &lt;code&gt;case&lt;/code&gt; 语句好？而不能透过这些语句表面看到他们所具体代表的电路 。只有建立了硬件设计思想，才有更深入学习FPGA的可能 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;FPGA 入门简单精通难 。要想入门，买一块开发板跟着例程走一遍，很多人都能在很短的时间内熟悉开发软件的操作方法并且点亮开发板上的 LED 或者再实现个跑马灯什么的，但是再往后进步往往就进展很慢 。上面提到的这四条是玩转 FPGA 的基础，只有打好了坚实的基础后面才能一马平川 。希望每个学习 FPGA 的人最后都能成为大牛，设计出自己的完美电路 。&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>学习 Linux SSH</title><link href="http://guqian110.github.io/pages/2014/04/04/learning_linux_ssh.html" rel="alternate"></link><updated>2014-04-04T17:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-04:pages/2014/04/04/learning_linux_ssh.html</id><summary type="html">&lt;p&gt;实验室的师兄师姐毕业了，继承了他们的旧电脑 。宿舍的笔记本和实验室的电脑出现了相互之间传送同步文件的需求 。想到了两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;云同步&lt;/li&gt;
&lt;li&gt;SSH / SCP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决方案 1 是最省事的，也是目前最流行的，目前各大互联网公司都提供各种云服务，比如国外的 Google Drive、Dropbox，国内的百度云、360 网盘什么的。这种方案最大的有点是跨平台，不过这个方案是借助了第三方的服务器，需要连接到互联网才行，而且对网速是有一定要求的。&lt;/p&gt;
&lt;p&gt;解决方案 2 相比于方案 1 的优势是：不是必须要连接到互联网，在局域网内也可以同步文件 。一般局域网内传输文件的速度要比连外界的服务器快很多 。&lt;/p&gt;
&lt;p&gt;考虑到校园网的环境，明显方案 2 更加好 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;什么是 SSH&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑 。&lt;a href="http://en.wikipedia.org/wiki/Secure_Shell"&gt;SSH&lt;/a&gt; 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置 。&lt;/p&gt;
&lt;p&gt;最初的 SSH 协议是由芬兰的一家公司的研究员 Tatu Ylönen 于 1995 年设计开发的，但是因为受版权和加密算法等等的限制，现在很多人都转而使用 OpenSSH 。OpenSSH 是 SSH 的替代软件包，而且是开放源代码和免费的 。—— Wikipedia&lt;/p&gt;
&lt;p&gt;关于 SSH 的原理，找到了一系列 &lt;a href="http://www.ruanyifeng.com/blog/"&gt;阮一峰&lt;/a&gt;的文章，很简洁明了:&lt;/p&gt;
&lt;h3&gt;SSH&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html"&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html"&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;SSH 的用法&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;最简单明了的教程就是 man page 了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;内容为&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;
    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;—&lt;/span&gt; &lt;span class="n"&gt;OpenSSH&lt;/span&gt; &lt;span class="n"&gt;SSH&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;login&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;SYNOPSIS&lt;/span&gt;
 &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1246&lt;/span&gt;&lt;span class="n"&gt;AaCfgKkMNnqsTtVvXxYy&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;bind_address&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;cipher_spec&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bind_address&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;escape_char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;configfile&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;pkcs11&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;identity_file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bind_address&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hostport&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;login_name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;mac_spec&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;O&lt;/span&gt; &lt;span class="n"&gt;ctl_cmd&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;option&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bind_address&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hostport&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="n"&gt;ctl_path&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;local_tun&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;remote_tun&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;进阶的书籍有：&lt;a href="http://docstore.mik.ua/orelly/networking_2ndEd/ssh/index.htm"&gt;SSH, The Secure Shell: The Definitive Guide&lt;/a&gt;, O'reilly&lt;/p&gt;
&lt;p&gt;目前已经有两台安装了 Ubuntu 的电脑，实验室的一台 name 是 &lt;em&gt;lab&lt;/em&gt; ，宿舍的一台 name 是 &lt;em&gt;dom&lt;/em&gt; ，两台电脑上都有一个用户名为 &lt;em&gt;chien&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的目的是使两台电脑可以相互之间通过 SSH 访问。&lt;/strong&gt; 下面就是整个过程：&lt;/p&gt;
&lt;h3&gt;安装 SSH server&lt;/h3&gt;
&lt;p&gt;SSH 只是一种协议，在 Ubuntu 下，具体实现使用的是 &lt;a href="http://www.openssh.com/"&gt;OpenSSH&lt;/a&gt; 。Ubuntu 默认是安装了 SSH 客户端 &lt;code&gt;openssh-client&lt;/code&gt;，而没有安装 SSH 服务程序 &lt;code&gt;openssh-server&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;检测本机是否已经安装了 SSH server&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;localhost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;如果结果是&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;connect&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="n"&gt;localhost&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Connection&lt;/span&gt; &lt;span class="n"&gt;refused&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;说明 SSH server 还没有安装 。&lt;/p&gt;
&lt;p&gt;安装方法：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;openssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;启动 SSH 服务&lt;/h3&gt;
&lt;p&gt;启动 SSH server&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;查询服务是否正确启动&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ps&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;返回结果应该类似于&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="mi"&gt;4156&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;        &lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;agent&lt;/span&gt;
 &lt;span class="mi"&gt;4606&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;        &lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="n"&gt;sshd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;则说明服务已经正确启动 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;因为两台电脑要相互访问，所以它们的角色即使 server，又是 client，所以需要在两台电脑上都执行上面两步 。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;远程访问&lt;/h3&gt;
&lt;p&gt;首先，查询本机 IP 地址&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ifconfig&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;比如 lab 的 IP 地址是 &lt;code&gt;10.105.55.155&lt;/code&gt;, dom 的 IP 地址是 &lt;code&gt;10.210.111.116&lt;/code&gt; 。（因为是校园网，所以分配到的都是内网地址）&lt;/p&gt;
&lt;p&gt;然后，在宿舍用 dom 访问 lab 这台机器&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mf"&gt;10.105.55.155&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;实际结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="login1" src="/images/learning-linux-ssh/login1.png" /&gt;&lt;/p&gt;
&lt;p&gt;在执行命令前，提示符显示目前的用户是在 dom 这台机器上的用户 chien，本机 home 目录下有 &lt;code&gt;dom&lt;/code&gt; 文件，但是没有 &lt;code&gt;lab&lt;/code&gt; 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 lab 机器，远程机器 home 目录下有 &lt;code&gt;lab&lt;/code&gt; 文件，但是没有 &lt;code&gt;dom&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;p&gt;同理，在实验室用 lab 访问 dom 这台机器&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mf"&gt;10.210.111.116&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;实际结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="login2" src="/images/learning-linux-ssh/login2.png" /&gt;&lt;/p&gt;
&lt;p&gt;在执行命令前，提示符显示目前的用户是在 lab 这台机器上的用户 chien，本机 home 目录下有 &lt;code&gt;lab&lt;/code&gt; 文件，但是没有 &lt;code&gt;dom&lt;/code&gt; 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 dom 机器，远程机器 home 目录下有有 &lt;code&gt;dom&lt;/code&gt; 文件，但是没有 &lt;code&gt;lab&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;h3&gt;省去 IP 地址&lt;/h3&gt;
&lt;p&gt;每次登录都需要记忆、手动输入 IP 地址，其实只需要改 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件，就能省去手动输入 IP 地址的烦恼。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hosts&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;在 dom 的 hosts 文件后面添加&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;lab&lt;/span&gt;    &lt;span class="mf"&gt;10.105.55.155&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;在 lab 的 hosts 文件后面添加&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dom&lt;/span&gt;     &lt;span class="mf"&gt;10.210.111.116&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;以后，登录时只需要输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// from dom to lab&lt;/span&gt;
&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;lab&lt;/span&gt;

&lt;span class="c1"&gt;// from lab to domm&lt;/span&gt;
&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就可以登录了。&lt;/p&gt;
&lt;h3&gt;公钥登录&lt;/h3&gt;
&lt;p&gt;上一步解决了 IP 地址的问题，但是还是需要手动输入密码 。我们可以用公钥登录的方法，免去输密码的烦恼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，什么是数字签名 Digital Signature&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html"&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youdzone.com/signature.html"&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次，生成数字签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 默认安装了 &lt;code&gt;ssh-keygen&lt;/code&gt;，可以生成公钥和私钥&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;keygen&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;命令执行过程中会询问保存密钥文件的路径，还可以为密钥文件设置口令（passphrase）。运行结束以后，在 &lt;code&gt;$HOME/.ssh/&lt;/code&gt; 目录下，会新生成两个文件：&lt;code&gt;id_rsa.pub&lt;/code&gt; 和 &lt;code&gt;id_rsa&lt;/code&gt; 。前者是你的公钥，后者是你的私钥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后，发布数字签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ssh-copy-id&lt;/code&gt; 命令可以把公钥复制到远程机器中 。&lt;/p&gt;
&lt;p&gt;将 dom 的公钥发送到 lab 中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;di&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;将 lab 的公钥发送到 dom 中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;di&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;最后，使用公钥登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时，远程登录时就不再需要输入密码了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// from dom to lab&lt;/span&gt;
&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;lab&lt;/span&gt;

&lt;span class="c1"&gt;// from lab to dom&lt;/span&gt;
&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;使用 SCP 传输文件&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;SSH 提供了一些命令和 shell 用来登录远程服务器 。在默认情况下它不允许你拷贝文件,但是还是提供了一个 "scp" 命令 。scp 命令是 SSH 中最方便有用的命令了，试想，在两台服务器之间直接传送文件。仅仅用 scp 一个命令就完全解决了 。&lt;/p&gt;
&lt;p&gt;man page&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;scp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;内容为&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;
 &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="err"&gt;—&lt;/span&gt; &lt;span class="n"&gt;secure&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;SYNOPSIS&lt;/span&gt;
 &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12346&lt;/span&gt;&lt;span class="n"&gt;BCpqrv&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;ssh_config&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;identity_file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;ssh_option&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;P&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;host1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;file1&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;host2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;file2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;scp 可以实现把 [[user@]host1:]file1 复制到 [[user@]host2:]file2 的功能。所以&lt;/p&gt;
&lt;h3&gt;上传 dom 本地文件至服务器 lab&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="n"&gt;dom&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt;&lt;span class="o"&gt;:~/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;下载 lab 服务器文件至本地 dom&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;若发送文件夹则添加参数 &lt;code&gt;-r&lt;/code&gt; 即可&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt;&lt;span class="o"&gt;:~/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;至此，就实现了两台电脑的之间相互远程访问的功能 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html"&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html"&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html"&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youdzone.com/signature.html"&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;</summary><category term="SSH"></category></entry><entry><title>编写可综合的 Verilog HDL 代码</title><link href="http://guqian110.github.io/pages/2014/04/04/writing_synthesizable_code.html" rel="alternate"></link><updated>2014-04-04T01:35:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-04:pages/2014/04/04/writing_synthesizable_code.html</id><summary type="html">&lt;p&gt;对电路建模方法有很多种，可以用绘制原理图，也可以用 &lt;em&gt;硬件描述语言（Hardware Description Language）&lt;/em&gt; 建模 。硬件描述语言中最常用的就是 Verlilog 和 VHDL 。&lt;/p&gt;
&lt;p&gt;Verilog HDL和VHDL相比有很多优点，有C语言基础的话很容易上手。搜集了一些网上大神的经验总结和书上的例子，所以对于和我一样的初学者，这篇博客应该还是很有提高作用的，至于具体语法，任何一本书都讲的很详细。&lt;/p&gt;
&lt;h2&gt;HDL&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;从网上找到一篇文章，把 HDL 的历史说的非常清楚。&lt;/p&gt;
&lt;p&gt;作者 董培良 &lt;/p&gt;
&lt;p&gt;题目： &lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈VHDL/Verilog的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确的是 VHDL 和 Verilog 并非是针对硬件设计而开发的语言，只不过目前被我们用来设计硬件。HDL 是 Hardware &lt;strong&gt;Description&lt;/strong&gt; Language 的缩写，正式中文名称是 “硬件描述语言”。也就是说，HDL 并不是 “硬件设计语言（Hardware &lt;strong&gt;Design&lt;/strong&gt; Language）”。别看只差这一个单词，正是这一个单词才决定了绝大部分电路设计必须遵循RTL的模式来编写代码，而不能随心所欲得写仅仅符合语法的 HDL 代码。&lt;/p&gt;
&lt;p&gt;VHDL 于 1980 年开始在美国国防部的指导下开发，完成于 1983 年，并于 1987 年成为 IEEE 的标准。当初开发这种语言，是出于美国国防部采购电子设备的需要。美军的装备采购自私人企业，时常要面对这样一种风险：如果某种武器大量装备部队，而其中某个零件的供应商却在几年后倒闭了，那这种武器的再生产、维修和保养都会出现大问题。而电子设备、尤其是集成电路的内部结构较为复杂，若出现前面所说的情况要找其他公司生产代用品非常困难。于是美国防部希望供应商能以某种形式留下其产品的信息，以保证一旦其破产后能由其他厂商迅速生产出代用品。&lt;/p&gt;
&lt;p&gt;显然，当初的设计文档显然是不能交出来的，这在美国会涉及商业机密和知识产权问题。于是美国防部就想出了一种折衷的方法——描述硬件的语言，也就是 VHDL 。通过 VHDL，供应商要把自己生产的集成电路芯片的行为描述出来：比如说，加了什么样的信号后过多少时间它能输出什么等等。这样，如果有必要让其他厂商生产代用品，他们只需照着 VHDL 文档，设计出行为与其相同的芯片即可。这样的代用品相当于是新厂商在不了解原产品结构的情况下独立设计的，所以不太会涉及知识侵权。&lt;/p&gt;
&lt;p&gt;Verilog HDL 也形成于差不多的年代，是由 Gateway Design Automation 公司大约在 1983 年左右开发的。其架构同 VHDL 相似，但主要被用来进行硬件仿真。或许私人公司更注重实用，Verilog 要比 VHDL 简洁得多。&lt;/p&gt;
&lt;p&gt;由此可见，这两种最流行的用于电路设计的语言，没有一种是为了设计硬件而开发的（更何况 80 年代还没有现在的那些功能强大的EDA软件呢）。因此，当初制订 HDL 语言标准的时候，并没有考虑这些代码如何用硬件来实现。换句话说，有些代码写起来简单，实现起来却可能非常复杂，或者几乎不可能实现。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;可综合代码&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;任何符合 HDL 语法标准的代码都是对硬件行为的一种描述，但不一定是可直接对应成电路的设计信息。行为描述可以基于不同的层次，如系统级，算法级，寄存器传输级(RTL)、门级等等。以目前大部分EDA软件的综合能力来说，&lt;strong&gt;只有RTL或更低层次的行为描述才能保证是可综合的&lt;/strong&gt;。而众多初学者试图做的，却是想让软件去综合 &lt;em&gt;算法级或者更加抽象的硬件行为描述&lt;/em&gt;。&lt;/p&gt;
&lt;h3&gt;所有综合工具都支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nx"&gt;always&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="nx"&gt;wire&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;tri&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;inout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;aupply0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;supply1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="nx"&gt;and&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;nand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;nor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;xor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;xnor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;not&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;bufif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;bufif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;notif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;notif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;instantitation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;negedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;posedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;operators&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parameter&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;有些工具支持，有些工具不支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;asex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;casez&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;triand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;trior&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forever&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arrays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;memories&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;repreat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建立可综合模块的原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要用 initial （FPGA 上电时初始状态不定，一般需要上电复位信号，在复位信号有效的时候进行初始化，上电复位信号可以由外部手动输入，也可以系统自己产生 —— 写一个实现上电产生自动复位信号的模块）。P.S. 现在的综合软件功能已经足够强大，即使写了 initial 语句，在 ISE 13.3 中仍然是可综合的，而且没有 warning 和 info 的提示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;#10&lt;/code&gt;（在仿真中有用，实际在硬件上不会实现）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用循环次数不定的循环语句，如 &lt;code&gt;forever&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用用户自定义原语（UDP 原件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除非是关键路径设计，一般不采用调用门级原件描述的设计的方法，建议采用行为语句完成设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用同步方式设计电路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;always&lt;/code&gt; 语句描述组合逻辑时，在敏感信号列表中要列出所有输入信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的内部寄存器都应该可以被复位，在 FPGA 设计时应尽量使用器件的全局复位端信号作为系统的总复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序逻辑使用非阻塞赋值，组合逻辑使用阻塞赋值，同一过程块中不要同时使用阻塞和非阻塞两种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在不同的 &lt;code&gt;always&lt;/code&gt; 过程块中对同一变量赋值（否则综合时会提示有多驱动源错误，&lt;em&gt;multiple source
&lt;/em&gt;），对同一赋值对象，不能既使用阻塞赋值，又使用非阻塞赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不打算把变量综合成锁存器，在 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;case&lt;/code&gt; 语句的所有分支中都要对变量明确赋值（不能省去 &lt;code&gt;else&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt;，原理：在省去的情况下，变量的值会保持原来的值不变，所以系统会综合出一个锁存器 Latch）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免混合使用上升沿和下降沿触发器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一变量的赋值不能受多个时钟控制，也不能受两种不同时钟条件（或不同时钟沿）控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在 &lt;code&gt;case&lt;/code&gt; 语句中使用 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;z&lt;/code&gt; 值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;不可综合代码&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;不可综合语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;defparam&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UDP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wait&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;initial&lt;/code&gt; 只能在 Testbench 中使用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;events&lt;/code&gt; 在 Testbench 中更有用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;real&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;time&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;force&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;assign&lt;/code&gt; 和 &lt;code&gt;deassign&lt;/code&gt; 不支持 &lt;code&gt;reg&lt;/code&gt; 类型的综合，支持 &lt;code&gt;wire&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork...join&lt;/code&gt; 不可综合，可以用非块语句达到同样的效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;primitives&lt;/code&gt; 支持门级原语综合，不支持非门级原语综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;table&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一个 &lt;code&gt;reg&lt;/code&gt; 被多个 &lt;code&gt;always&lt;/code&gt; 块驱动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;延时，不可综合为硬件电路延时，综合工具会忽略延时，但是不会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 &lt;code&gt;x&lt;/code&gt;、&lt;code&gt;z&lt;/code&gt; 比较，综合工具会忽略，所以要保证信号只有两个状态，&lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;判断是否可综合&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;继续引用 &lt;strong&gt;董培良&lt;/strong&gt; 的文章：&lt;/p&gt;
&lt;p&gt;用一句简单的话概括：电脑永远没有你聪明 。具体来说，通常 EDA 软件对 HDL 代码的综合能力总是比人差 。对于一段代码，如果你不能想象出一个较直观的硬件实现方法，那 EDA 软件肯定也不行。比如说，加法器、多路选择器是大家都很熟悉的电路，所以类似&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的运算一定可以综合。而除法、开根、对数等等较复杂的运算，必须通过一定的算法实现，没有直观简单的实现方法，则可以判断那些计算式是不能综合的，必须按它们的算法写出更具体的代码才能实现 。此外，硬件无法支持的行为描述，当然也不能被综合（比如想在 FPGA 上实现 DDR 内存那样的双延触发逻辑，代码很容易写，但却不能实现）。&lt;/p&gt;
&lt;p&gt;不过，这样的判断标准非常主观模糊，遇到具体情况还得按设计人员自己的经验来判断 。如果要一个相对客观的标准，一般来说：在 RTL 级的描述中，所有逻辑运算和加减法运算、以及他们的有限次组合，基本上是可综合的，否则就有无法综合的可能性 。当然，这样的标准仍然有缺陷，更况且 EDA 的技术也在不断发展，过去无法综合的代码或许将来行，某些软件不支持的代码换个软件或许行 。比如固定次数的循环，含一个常数参数的乘法运算等等，有些 EDA 软件支持对它们的综合，而有些软件不行。&lt;/p&gt;
&lt;p&gt;所以，正确的判断仍然要靠实践来积累经验。当你可以较准确判断代码的可综合性的时候，你对 HDL 的掌握就算完全入门了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈VHDL/Verilog的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;</summary><category term="Verilog"></category><category term="synthesis"></category></entry><entry><title>学习 FPGA 入门</title><link href="http://guqian110.github.io/pages/2014/04/03/learning_fpga_getting_started.html" rel="alternate"></link><updated>2014-04-03T12:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-04-03:pages/2014/04/03/learning_fpga_getting_started.html</id><summary type="html">&lt;h2&gt;FPGA 是什么&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 是 PLD 家族中的一员，要说清楚什么是 FPGA，就不得不说一说 PLD 。（&lt;strong&gt;以下内容来自wikipedia&lt;/strong&gt;）&lt;/p&gt;
&lt;h3&gt;PLD &amp;amp; ASIC&lt;/h3&gt;
&lt;p&gt;早期的数字逻辑系统，是由中、小规模集成电路芯片搭建而成的。这种形式的电路在可靠性、工作速度、功耗和体积方面都难以满足大规模、高性能信息处理系统的要求 。后来，随着集成电路的发展，出现可专用集成电路 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专用集成电路&lt;/strong&gt;（Application Specific Integrated Circuits, &lt;a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit"&gt;&lt;code&gt;ASIC&lt;/code&gt;&lt;/a&gt;）是指依产品需求不同而非通用目的，而自定义的特殊规格集成电路 。ASIC 可以将整个系统集成到一个芯片上。由于芯片内集成度高、连线短，所以它可以满足之前 ”搭建系统“ 难以满足的性能指标 。&lt;/p&gt;
&lt;p&gt;随着芯片尺寸的减小和设计工具的发展，这些年来 ASIC 芯片最大的集成度从 5,000 增长到了 超过100,000,000 门 。现代的 ASIC 通常都包含了微处理器、存储块（如 ROM 、RAM 、EEPROM 、Flash 等）。这种 ASIC 被称为 SoC （&lt;a href="http://en.wikipedia.org/wiki/System-on-chip"&gt;system on chip&lt;/a&gt;），ASIC 设计师采用硬件描述语言（Hardware Description Language，HDL），比如 Verilog、VHDL，描述 ASIC 的功能 。&lt;/p&gt;
&lt;p&gt;但是 ASIC 的研制周期长，现代信息处理的快速发展要求集成电路的设计、测试和生产周期尽可能的段，这就促进了可编程逻辑器件的发展 。严格地说，有些可编程器件出现的时间比 ASIC 出现的早，这里说的可编程器件主要是指 CPLD/FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可编程逻辑器件&lt;/strong&gt;（Programmable Logic Device,&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;&lt;code&gt;PLD&lt;/code&gt;&lt;/a&gt;）是一种用来搭建可重配置数字电路的电子器件。和逻辑门（logic gate）不同，PLD 出厂时逻辑功能是没有被定义的，在使用之前，必须先重配置（reconfigure）。&lt;/p&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;h4&gt;ROM as PLD&lt;/h4&gt;
&lt;p&gt;在 PLD 器件被发明之前，就已经有人 &lt;em&gt;将 &lt;a href="http://en.wikipedia.org/wiki/Read-only_memory"&gt;ROM&lt;/a&gt; 以 PLD 的概念来运用&lt;/em&gt;，用 ROM 芯片来充当一些输入性的组合逻辑（combinatorial logic）的函数发生器。ROM 有 m 个地址线，则有 &lt;code&gt;n = 2^m&lt;/code&gt; 个输出结果，这和布尔逻辑是一一对应的，所以如果把 ROM 的地址线当作相互之间没有关系的输入，则相应的输出就可以实现不同的函数。&lt;/p&gt;
&lt;p&gt;早期的 Mask ROM 存储数据的方式是使用内部的硬件电路，所以只能在出厂时就写入数据，而且以后不能更改。这就导致了一系列缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为消费者必须联系制造商才能生产出自定义的芯片，所以只有买大量的 ROM 芯片时才经济划算 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为同样的原因，从设计到最终生产出产品，中间耗费的时间很长 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mask ROM 在研发中基本上不能使用，因为设计师在改进设计时需要经常改动 ROM 里面的值 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个设备中含有故障的 Mask ROM，那么修复这个设备的唯一方法就是召回设备并且更换其中的每一个 Mask ROM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;PROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_read-only_memory"&gt;PROM&lt;/a&gt;（Programmable Read Only Memory）是周文俊于 1956 年发明的。他在纽约 Garden City 的 American Bosch Arma Corporation 工作，当时，美国空军为了提升空军用计算机以及Atlas E/F波段导弹的灵活性和保安性而提出要求，这项技术就是为了满足这一要求而产生的 。&lt;/p&gt;
&lt;p&gt;PROM 是通过熔丝/反熔丝（fuse/antifuse）实现对每个 bit 的设置 。通过使用高电压脉冲改变内部的物理结构，这种方法通常是不可逆的，所以它只允许用户更改一次配置 。PROM 解决了上面提到的问题 1 和问题 2 ，因为公司可以买一大批没有配置过的 PROM，设计人员可以根据自己的需要随意配置 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EPROM"&gt;EPROM&lt;/a&gt;（Erasable Programmable Read Only Memory）是 intel 公司的 Dov Frohman 于 1971 年发明的 。与 PROM 不同的是，EPROM 可利用高电压将资料编程写入，通过紫外线照射的方式不断的重置为未配置状态。因此，在封装外壳上会预留一个石英玻璃所制的透明窗以便进行紫外线曝光。写入程序后通常会用贴纸遮盖透明窗，以防日久不慎曝光过量影响资料。&lt;/p&gt;
&lt;p&gt;因为EPROM 可以重复配置，所以它解决了上面的第 3 个问题 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EEPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EEPROM"&gt;EEPROM&lt;/a&gt;（Electrically Erasable Programmable Read-Only Memory）于 1983 年被发明出来。相比EPROM，EEPROM不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据 。&lt;/p&gt;
&lt;p&gt;如果设备可以从外部接收数据（比如 PC 通过串口线），就可以在线配置 EEPROM，这样它解决了问题 4 。&lt;/p&gt;
&lt;p&gt;虽然解决了上面的 4 个问题，但是把 ROM 当作 PLD 器件使用，还是有很多弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与专用逻辑电路相比，ROM 的速度很慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当输入不同步时（异步状态），ROM 的输出有毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更加耗电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与可编程逻辑相比，价格更贵，尤其是高速应用中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且，大部分 ROM 没有输出寄存器，所以它不能直接应用在时序电路中，所以在状态机的设计中，通常还需要一个外部的 TTL 寄存器 。对电路设计的业余爱好者来说，有时也仍然用“2716”之类的普遍型EPROM芯片来充当PLD，这种用法有时也称为“穷人的PAL”。（PAL也是PLD的一种，以下将再进一步说明）&lt;/p&gt;
&lt;p&gt;于是，就出现了 PLD 器件。&lt;/p&gt;
&lt;h4&gt;早期可编程逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1969 年，Motorola 生产出 XC157，它是一个有 12 个逻辑门和 30 个独立输入/输出管脚的可编程逻辑正列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（PLA）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1971 年，通用电器公司（GE）在新的 PROM 技术的基础上发明了一种可编程逻辑器件。这个实验性质的设备通过使用多层逻辑来提高 IBM 的 ROAM 性能 。GE 的这个设备是最早的 PLD 设备，比 Altera 的 EPLD 早了十几年 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1974 年，GE 和 Monolithic Memories 达成协议，开发一种可编程逻辑器件。这个设备被称为 ”Programmable Associative Logic Array“ 或者是 PALA 。最终于 1976 年完成 MMI 5760 ，它可以实现超过 100 门的时序电路。GE 的开发环境支持这一器件，它可以直接将布尔表达式转化为配置器件的代码，然而最终这个器件却没有上市。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;PLA&lt;/h4&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（&lt;a href="http://en.wikipedia.org/wiki/Programmable_Logic_Array"&gt;PLA&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;PLA 具有一组可编程的 AND 阵列，AND 阵列之后连接一组可编程的 OR 阵列 ，这样就可以只在合乎设定条件时才允许产生逻辑信号输出 。&lt;/p&gt;
&lt;p&gt;虽然名字中含有可编程 3 个字，但是并不是所有的 PLA 都可以现场编程，事实上许多都属遮罩性的可编程化，性质与ROM相同，必须在芯片制造厂内就执行与完成程序化设定，尤其是内嵌于电路较复杂的芯片（例如：微处理器）的PLA多属此种程序化方式。&lt;/p&gt;
&lt;h4&gt;PAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_Array_Logic"&gt;PAL&lt;/a&gt;（Programmable Array Logic）是 Monolithic Memories 公司在 1978 年 3 月提出的，在数字电路中用来搭建逻辑功能的可编程器件的总称 。PAL 内部含有固定的或门阵列，可编程的与门阵列，从而实现所要求的逻辑函数。&lt;/p&gt;
&lt;p&gt;PAL 内部有个 PROM 的核，外部附加的输出逻辑电路，这样就可以实现所需要的逻辑功能 。因为 PAL 是基于 PROM 的，所以要使用特殊的设备，PAL 才具有可编程性，而且是 ”一次编程“ 。&lt;/p&gt;
&lt;h4&gt;GAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Generic_array_logic"&gt;GAL&lt;/a&gt;（Generic array logic）是 PAL 的发展，是 Lattice Semiconductor 于 1985 年发明 。这个设备具有和 PAL 同样的功能，但是可以重配置多次，所以 GAL 在设计中很有用，一旦有错误，只需要擦除后重新配置即可 。&lt;/p&gt;
&lt;p&gt;后来，International CMOS Technology (ICT) 公司发明了 类似的设备，称为 PEEL（programmable electrically erasable logic）。&lt;/p&gt;
&lt;h4&gt;CPLD&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Complex_programmable_logic_device"&gt;CPLD&lt;/a&gt;（Complex programmable logic device）适合用来实现各种运算和组合逻辑（combinational logic）。PAL、GAL仅适合用在约数百个逻辑门所构成的小型电路，若要实现更大的电路则适合用 CPLD，一颗CPLD内等于包含了数颗的PAL，各PAL（逻辑区块）间的互接连线也可以进行程序性的规划、烧录，CPLD运用这种多合一（All-In-One）的整合作法，使其一颗就能实现数千个逻辑门，甚至数十万个逻辑门才能构成的电路。&lt;/p&gt;
&lt;p&gt;CPLD 与 PAL 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非易失性配置存储器。与 FPGA 不同，CPLD v不需要外部的 ROM，只要系统上电，就可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于许多旧的 CPLD 来说，布线约束要求大部分逻辑块要和输入输出相连接，以减少内部状态记录，对于新的 CPLD 系列来说，已经不需要这样了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPLD 与 FPGA 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以利用大量的逻辑资源，CPLD 等价有有数百万的逻辑门资源可以用来实现比较复杂的设计，而 PAL 最多等价有几千个逻辑门，FPGA 有几万到几百万的逻辑门。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供一些更加灵活的资源，比如宏模块之间复杂的反馈连接和整数运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大的 CPLD 和小 FPGA 之间最显著的差别就是 CPLD 含有片内非易失性存储器 。因为非易失性存储器的特点，CPLD 在数字电路设计中被当作 ”boot loader“ 来使用，之后它再把系统的控制权转交给没有这种特性的设备，最好的例子就是使一块 CPLD 从非易失性存储器中装载配置 FPGA 所需要的数据 。&lt;/p&gt;
&lt;h4&gt;FPGA&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA&lt;/a&gt;（Field Programmable Gate Array，FPGA）是在 PAL、GAL、CPLD 等可编程逻辑器件的基础上进一步发展的产物。它是作为专用集成电路领域中的一种半定制电路而出现的，既解决了全定制电路的不足，又克服了原有可编程逻辑器件门电路数有限的缺点。&lt;/p&gt;
&lt;p&gt;当 PAL 忙于进展成 GAL、CPLD 时，另一种 “可编程化” 的流派也逐渐成形，此称之为现场可编程闸阵列（Field Programmable Gate Array，FPGA）。FPGA是以阵列（Gate Array）技术为基础所发展成的一种PLD 。所谓 ”Field Programmable“ 就是说芯片是出厂以后由客户或者设计师配置而工作的 。&lt;/p&gt;
&lt;p&gt;1980 年代后期，Naval Surface Warfare Department 在 Steve Casselman 的提议下成立了实验项目，目的是为了研制一台由 600,000 个逻辑门组成的计算机。Casselman 最后成功了并且在 1992 年获得了专利 。&lt;/p&gt;
&lt;p&gt;Xilinx 公司的共同创世人 &lt;a href="http://en.wikipedia.org/wiki/Ross_Freeman"&gt;Ross Freeman&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Bernard_Vonderschmitt"&gt;Bernard Vonderschmitt&lt;/a&gt; 在 1985 年发明出第一款商业 FPGA —— XC2064 。XC2064 芯片有可以编程的逻辑门和可以编程的内部连接线，这开辟了一项新的技术和市场 。XC2064 有 64 个可配置逻辑块（configurable logic blocks，CLBs），和 3 输入查找表（lookup tables，LUTs）。&lt;/p&gt;
&lt;p&gt;从 1985 开始到 90 年代中期，Xilinx 一直处于高速发展阶段，之后竞争对手出现了，截至 1993 年，Actel 占据了 18% 的市场 。&lt;/p&gt;
&lt;p&gt;90 年代是 FPGA 爆炸式发展的年代，这一期间出现了大量高端技术和产品。在 90 年代初期，FPGA 主要应用于通信领域，在 90 年代后期，FPGA 已经广泛应用于消费品、汽车和工业应用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;FPGA vs ASIC&lt;/h3&gt;
&lt;p&gt;ASIC 的优点：&lt;/p&gt;
&lt;p&gt;ASIC 在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低 。&lt;/p&gt;
&lt;p&gt;ASIC 的缺点：&lt;/p&gt;
&lt;p&gt;设计周期最长，设计成本贵，设计费用最高，适合于批量很大或者对产品成本不计较的场合。&lt;/p&gt;
&lt;p&gt;至于 FPGA 的优点和缺点完全就是 ASIC 的取反 。FPGA 一般来说比专用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA 具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用 FPGA 进行除错的成本较低 。在一些技术更新比较快的行业，FPGA几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时FPGA方便灵活的优势就显得很重要。这也是 FPGA 能够发展起来的原因，市场是不会允许一个毫无优势的技术发展到今天这种地步的 。&lt;/p&gt;
&lt;p&gt;个人认为两者不是对立的，由于各自的特点，它们有各自适用的环境，不能一棒子打死，否定其中一个 。事实上更多的情况是：设计的开发是在普通的FPGA上完成的，然后将设计转移到一个类似于专用集成电路的芯片上 。&lt;/p&gt;
&lt;h3&gt;FPGA vs CPLD&lt;/h3&gt;
&lt;p&gt;为了达到上述目的，还有一种方法是使用 CPLD 。
CPLD和FPGA都包括了一些相对大数量的可以编辑逻辑单元。CPLD逻辑门的密度在几千到几万个逻辑单元之间，而FPGA通常是在几万到几百万。&lt;/p&gt;
&lt;p&gt;FPGA 与 CLPD 最大的区别就是：FPGA 是基于查找表（look up table，LUT），而 CPLD 是基于海门架构（sea-of-gates），也就是它们的系统结构 。CPLD 的结构具有一定的局限性 。这个结构由一个或者多个可编辑的结果之和的逻辑组列和一些相对少量的锁定的寄存器组成 。这样的结果是缺乏编辑灵活性，但是它的优点是，其延迟时间易于预计，逻辑单元对连接单元比率较高 。而FPGA具有的连接单元数量很大，这样虽然让它可以更加灵活的编辑，但是结构却复杂的多 。&lt;/p&gt;
&lt;p&gt;CPLD 和 FPGA 另外一个区别是大多数的 FPGA 含有高层次的内置模块（比如加法器和乘法器）和内置的存储器 。一个由此带来的重要区别是，很多新的 FPGA 支持完全的或者部分的系统内重新配置 。允许他们的设计随着系统升级或者动态重新配置而改变 。一些FPGA可以让设备的一部分重新编辑，而其他部分继续正常运行 。&lt;/p&gt;
&lt;p&gt;CPLD 与 FPGA 之间结构、原理上的差别导致两者应用上的差别 。考虑成本、性能要求等因素，应该根据实际情况选择 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Xilinx &amp;amp; Altera&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 的制造商主要是 Xilinx 和 Altera 两家，他们合起来市场占有率达到了 80% 之多 。两家是 FPGA 技术的领导者也是长期竞争对手 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Xilinx"&gt;Xilinx&lt;/a&gt; 于 1984 年创建于美国加利福尼亚州的硅谷，总部位于硅谷核心的圣何塞。它是一家主要提供 FPGA 的科技公司 。并且就是它的创始人是发明了 FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Altera"&gt;Altera&lt;/a&gt; 是一家位于美国硅谷的可编程逻辑器件和 CPLD 的制造商 。该公司于1984年推出了其首款可编程逻辑设备。&lt;/p&gt;
&lt;p&gt;两家一直是互为竞争对手，一般来说，大学里面都 Altera 的器件和 VHDL 上课，所以在学校里面用 Xilinx 的人比较少 。&lt;/p&gt;
&lt;p&gt;因为原理是一样的，所以只要学会一种，另一种就很容易上手。学校实验室里面用的是 Xilinx 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Xilinx FPGA Architecture（架构）&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 需要反复烧写，所以不能像 ASIC 一样通过固定的与非门来完成，只能采用一种易于反复配置的结构，查找表就可以很好的满足这一要求。目前主流 FPGA 都是采用了基于 SRAM 工艺的查找表结构（军品和宇航级 FPGA 采用 Flash或者熔丝/反熔丝工艺），通过烧写文件改变查找表内容的方法来实现对 FPGA 的重复配置。&lt;/p&gt;
&lt;p&gt;查找表（look-up table，LUT）本质上就是一个 RAM 。当用户通过原理图或 HDL 语言描述了一个电路以后，FPGA 开发软件会计算逻辑电路的所有可能结果，并把真值表事先写入 RAM，这样，每输入一个信号进行逻辑运算就相当于输入一个地址进行查找，这样 LUT 就具有了和逻辑电路相同的功能 。实际上，LUT 具有更快的执行速度和更大的规模 。&lt;/p&gt;
&lt;p&gt;上电时，FPGA将外部存储器中的数据读入片内RAM，完成配置后，进入工作状态；掉电后FPGA恢复为白片，内部逻辑消失。这样FPGA不仅能够反复使用，还无须专门的FPGA编程器，只需通用的EPROM、PROM编程器即可。&lt;/p&gt;
&lt;p&gt;目前，Xilinx FPGA 仍然是基于查找表技术，但是其概念已经远远超出查找表技术的限制，并且整合了常用功能的硬核模块（如块 RAM，时钟管理和 DSP）。Xilinx FPGA 内部大致可以分为 6 部分：&lt;/p&gt;
&lt;h3&gt;IOB&lt;/h3&gt;
&lt;p&gt;可编程输入/输出单元简称 I/O 单元，是芯片与外界电路的接口部分，完成不同电气特性下输入/输出信号的驱动和匹配 。&lt;/p&gt;
&lt;h3&gt;CLB&lt;/h3&gt;
&lt;p&gt;CLB（Configurable Logic Block）是 FPGA 内的基本逻辑单元，Xilinx FPGA 的 CLB 由多个相同的 Slice 和附加逻辑组成 。&lt;/p&gt;
&lt;h3&gt;DCM&lt;/h3&gt;
&lt;p&gt;业内大多数 FPGA 都提供数字时钟管理（Digital Clock Manager）。Xilinx FPGA 提供 DCM 和 PLL 。&lt;/p&gt;
&lt;h3&gt;BRAM&lt;/h3&gt;
&lt;p&gt;大多数 FPGA 都具有内嵌的块 RAM，这大大扩展了 FPGA 的应用范围和灵活度 。块 RAM 可以被配置为单口 RAM、双端口 RAM、内容地址存储器（CAM）和 FIFO 等常用存储结构 。&lt;/p&gt;
&lt;h3&gt;Routing Resource&lt;/h3&gt;
&lt;p&gt;布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速度 。Xilinx FPGA 的布线资源可以分为 4 类：全局布线资源、长线资源、短线资源、分布式资源 。&lt;/p&gt;
&lt;h3&gt;Embedded Module&lt;/h3&gt;
&lt;p&gt;内嵌功能模块只要是指 DLL、PLL、DSP 和 CPU 等 &lt;strong&gt;软核&lt;/strong&gt;，还有底层的 &lt;strong&gt;硬核&lt;/strong&gt; 资源，比如内嵌的 Power PC、ARM9、DSP芯片等 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Xilinx 主流 FPGA&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Xilinx 主流的 FPGA 主要有A系列、K系列、V系列、Spartan系列，如今还有最新的 Zynq 系列，官网上有详细介绍 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;开发流程&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 的开发流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="design flow" src="/images/learning-fpga-getting-started/design-flow.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;整个开发过程就是使用开发工具 ISE Design Suite，按照流程图进行 。图示是标准流程，但是实际上并不是严格按照每一个步骤进行 。&lt;/p&gt;
&lt;p&gt;一般简化过的流程是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计可综合的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合 Systhesis&lt;/p&gt;
&lt;p&gt;前两步主要是确保写的代码是开发工具可以转化为实际电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合后仿真&lt;/p&gt;
&lt;p&gt;这一步保证模块的逻辑功能是正确的，即检验模块的结果是否和预期一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序约束&lt;/p&gt;
&lt;p&gt;为设计添加时序约束和管脚约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现 Implement&lt;/p&gt;
&lt;p&gt;按照约束条件将综合结果映射到实际器件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析&lt;/p&gt;
&lt;p&gt;实际上，一次就能达到时序要求且布线成功的情况并不多，尤其是对于高速设计，所以需要根据上一步的时序结果对设计进行修改，以满足时序要求，类似于写软件的 Debug 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载，在线调试&lt;/p&gt;
&lt;p&gt;将设计下载到芯片中调试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;PLD wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>C/C++ 内置数据类型</title><link href="http://guqian110.github.io/pages/2014/03/31/built_in_types.html" rel="alternate"></link><updated>2014-03-31T13:37:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-03-31:pages/2014/03/31/built_in_types.html</id><summary type="html">&lt;p&gt;类型是程序设计的基础。一些程序设计语言，比如 Smalltalk 和 Python，在运行的时候才检查预计中的对象的类型，想反，C++ 是静态类型（statically typed）语言，在编译时执行类型检查。导致的结果是：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;变量和函数在使用前必须先声明&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;每种类型都定义了其存储空间要求和可以在该类型的所有对象上执行的操作。C++ 是 在 C 的基础上扩充得到的，为了和 C 兼容， C++ 在必要时必须能够直接处理硬件，所以 C++ 提供的一组基本内置类型，如int、char等，这些类型与它们在机器硬件上的标示方式紧密相关。（所以，C++ 可以称为 “具有高级语言库的低级语言”）&lt;/p&gt;
&lt;p&gt;本文只限于总结 C++ 的内置类型（Built-in Types），不讨论自定义类型 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;基本内置类型&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;算术类型&lt;/h3&gt;
&lt;p&gt;C++ 语言自身定义了一组基本类型来表示不同的数据，如整数、浮点数、字母、bool 类型等，这些类型统称为 &lt;em&gt;算术类型（Arithmetic type）&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算术类型的存储空间依机器而定，即用多少二进制位 bit 来表示一个数 。C++ 标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间 。事实上，对于 &lt;code&gt;int&lt;/code&gt; 类型，几乎所有的编译器使用的存储空间都比所要求的大 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;sizeof()&lt;/code&gt; 操作符可以查询对象或类型的大小（以字节为单位），包含头文件&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;limits&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;就可以使用 STL 库中的 &lt;code&gt;numeric_limits&amp;lt;T&amp;gt;::max&lt;/code&gt; 和 &lt;code&gt;numeric_limits&amp;lt;T&amp;gt;::min&lt;/code&gt; 查询各个内置内类类型的最大值和最小值。&lt;/p&gt;
&lt;p&gt;下面是 Ubuntu amd64 版本上的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="size" src="/images/built-in-types/size.png" /&gt;&lt;/p&gt;
&lt;p&gt;算术类型可以分为两类：表示整数的 &lt;em&gt;整型&lt;/em&gt; 和表示浮点数的 &lt;em&gt;浮点型&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Integral Types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示整数、字符、布尔值的算术类型合称为 整型（integral types）。&lt;/p&gt;
&lt;p&gt;整数的基本表示类型是 &lt;code&gt;int&lt;/code&gt; 。int 类型前面可以加两类修饰说明，表示数据位数长短的 &lt;code&gt;short&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; ；表示有无符号的 &lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 。组合出来的结果就有 4 种：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;signed&lt;/span&gt; &lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kt"&gt;signed&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;每一种的数据长短和可以表示的范围都不相同。&lt;/p&gt;
&lt;p&gt;字符类型有两种：&lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;wchar_t&lt;/code&gt; 。char 用来表示 &lt;em&gt;基本字符集&lt;/em&gt; 中的字符，wchar_t 用于 &lt;em&gt;扩展字符集&lt;/em&gt; ，比如汉字和日语 。修饰 int 类型有无符号的 signed 和 unsigned 也可以修饰 char 类型 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt; (chapter 2) 中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike the other integral types, there are three distinct types for char: plain char, signed char, and unsigned char. Although there are three distinct types, there are only two ways a char can be represented. The char type is respresented using either the signed char or unsigned char version. Which representation is used for char varies by compiler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么会有这么奇怪的事呢？上网搜索了一下，按照自己的理解总结了一下：&lt;/p&gt;
&lt;p&gt;signed/unsigned 可以描述的类型有 int 和 char 两种，在 C 的标准里面规定：对于 int 类型，如果没有在类型前显式地声明，默认 int 是 signed 类型，而对于 char 类型，则是 &lt;em&gt;Implementation Defined&lt;/em&gt; 。也就是说由编译器在编译的时候决定具体使用哪一种 。而为什么要作出这么奇怪的规定呢？是因为 char 类型本来就是用来表示字符而非数字的， ASCII 码字只使用 7 bit，所以使用 signed/unsigned 对其没有影响，但是如果使用 char 类型来表示一个 8 bit 的数字（有时候空间不够用时不得不这样做，比如嵌入式系统中），为了可移植性，必须写明 signed/unsigned 。所以，如果用来表示字符，则直接使用 char 就行，如果用来表示整数，则声明是signed/unsigned 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.51cto.com/art/200912/166574.htm"&gt;Linux C编程一站式学习：整型&lt;/a&gt; 中进一步解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器可以定义char型是无符号的，也可以定义char型是有符号的，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种，x86平台的gcc定义char型是有符号的。这也是C标准的Rationale之一： &lt;em&gt;优先考虑效率，而可移植性尚在其次。&lt;/em&gt; 这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用。另一方面，写不可移植的代码有时候也是必要的，比如Linux内核代码使用了很多只有gcc支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写。如果不是为了效率，一般来说就没有理由故意编写不可移植的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网上有&lt;a href="http://www.cppblog.com/wuzimian/archive/2012/05/28/176427.aspx"&gt;博客&lt;/a&gt;说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VC 编译器、x86 上的 GCC 都把 char 定义为 signed char，而 arm-linux-gcc 却把 char 定义为 unsigned char 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是，编写一个测试小程序就可以知道我们使用的编译器是如何处理的。&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ch1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch1 = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ch1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="char" src="/images/built-in-types/char.png" /&gt;&lt;/p&gt;
&lt;p&gt;结果说明，gcc 把 char 默认为 signed char 处理。&lt;/p&gt;
&lt;p&gt;布尔类型表示 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。可以将任何算术类型的值赋给 &lt;code&gt;bool&lt;/code&gt; 对象，&lt;code&gt;0&lt;/code&gt; 表示 &lt;code&gt;false&lt;/code&gt; ，任何非 &lt;code&gt;0&lt;/code&gt; 值都表示 &lt;code&gt;true&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Floating-Point Types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;float&lt;/code&gt; 表示 单精度浮点数&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;double&lt;/code&gt; 表示 双精度浮点数&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;long double&lt;/code&gt; 表示 扩展精度浮点数&lt;/p&gt;
&lt;p&gt;从前面的运行结果可以看出在我的电脑上 float 使用 1 个字（32 bit） 表示，double 使用 2 个字（64 bit） 表示，long double 使用 4 个字（128 bit） 表示 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt; (chapter 2)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The float type is usually not precise enough for real programsfloat is guaranteed to offer only 6 significant digits. The double type guarantees at least 10 significant digits, which is sufficient for most calculations.&lt;/p&gt;
&lt;p&gt;Determining which floating-point type to use is easier: It is almost always right to use double. The loss of precision implicit in float is significant, whereas the cost of double precision calculations versus single precision is negligible. In fact, on some machines, double precision is faster than single. The precision offered by long double usually is unnecessary and often entails considerable extra run-time cost.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;void&lt;/h3&gt;
&lt;p&gt;void 类型没有对应的值，仅用在有限的一些情况下，通常用作无返回值函数的返回类型。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;初始化 Initialize&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;初始化 &amp;amp; 赋值&lt;/h3&gt;
&lt;p&gt;首先是初始化的必要性：&lt;/p&gt;
&lt;p&gt;在 C++ 中，初始化是一个非常重要的概念，给变量一个初始值几乎总是正确的，但不要求必须这么做。定义变量时，应该给变量赋初始值，除非确定将变量用于其他意图之前会覆盖这个初值。如果不能保证读取变量前重置变量，就应该初始化变量。变量没有初始化是很常见的导致程序崩溃/结果错误的原因，而且有时候很难像 Debug 一样找到这个错误（bug 导致程序一定不对，但是没有初始化的变量的结果是随机的）。所以，良好的习惯是对每个变量都进行初始化 。&lt;/p&gt;
&lt;p&gt;其次是初始化和赋值的区别：&lt;/p&gt;
&lt;p&gt;初始化 &lt;code&gt;Initialization&lt;/code&gt;：创建变量并且给它赋初始值&lt;/p&gt;
&lt;p&gt;赋值 &lt;code&gt;Assigment&lt;/code&gt;：擦除变量的当前值并用新值代替&lt;/p&gt;
&lt;p&gt;C++ 提供两种初始化变量的方法：复制初始化（&lt;code&gt;copy-initialization&lt;/code&gt;）和直接初始化（&lt;code&gt;direct-initialization&lt;/code&gt;）。复制初始化使用 &lt;code&gt;=&lt;/code&gt;，直接初始化使用 &lt;code&gt;()&lt;/code&gt; 。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// copy-initialization&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;ival&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// direct-initialization&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;=&lt;/code&gt; 很容易让人把初始化和赋值混淆在一起，但是在 C++ 中这是两种不同的操作，当涉及到类对象时，两种不同的初始化方式的区别是很微妙的。目前先不考虑这点，只需要知道直接初始化语法更灵活而且效率高。&lt;/p&gt;
&lt;h3&gt;内置类型初始化&lt;/h3&gt;
&lt;p&gt;当我们定义一个变量却没有初始化时，系统 &lt;em&gt;有可能&lt;/em&gt; 会为我们进行隐式的初始化。至于系统是否帮我们隐式初始化变量，以及为变量赋予一个怎样的初始值，这要取决于 &lt;em&gt;该变量的类型&lt;/em&gt; 以及我们 &lt;em&gt;在何处定义的该变量&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;这里我们只考虑内置类型的初始化：&lt;/p&gt;
&lt;p&gt;内置类型的变量是否自动初始化取决于变量定义的位置。在函数体外（全局范围）定义的变量都初始化为 0，函数体内定义的变量不进行自动初始化 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;算术类型转换&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;隐式类型转换&lt;/h3&gt;
&lt;p&gt;当两个操作数类型不同时，C++ 并不是直接把两个数加在一起，而是提供了一组转换规则，以便在执行算术操作之前，将两个数转换为同一数据类型。这些转换规则由编译器自动执行，不需要程序眼介入，有时甚至不需要程序员了解。因此，它们被称为 隐式类型转换 (&lt;code&gt;implicit type conversion&lt;/code&gt;) 。&lt;/p&gt;
&lt;p&gt;在以下情况会发生隐式类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;混合类型表达式，操作数被转换为相同类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;dval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ival&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;dval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// ival converted to double&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用作条件表达式被转化为 bool 型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// ival converted to bool&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;// cin converted to bool&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用表达式初始化（赋值）某一变量，表达式被转化为该变量类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.14&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 3.14 converted to int&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// the int 0 converted to a null pointer of type int *&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，函数调用时也可能发生隐式类型转化。&lt;/p&gt;
&lt;h3&gt;算术类型转换&lt;/h3&gt;
&lt;p&gt;C++ 语言为内置类型提供了一组转化规则，其中最常用的就是算术转化（arithmetic conversion）。算术转化规则定义了一个 &lt;em&gt;类型转换层次&lt;/em&gt;，该层次规定了操作数应该按照什么次序转换为表达式中最宽的数据类型。&lt;/p&gt;
&lt;p&gt;有两条通用规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为了保留精度，如果有必要，数据总是被提升为较宽的类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有含有小于整形的有序类型的算术表达式在计算之前其类型都会被转换成整型（整型提升 integral promotion）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于有符号数和无符号数，原则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不同级数据转换，若较宽的类型可以表示所有较窄的类型的数，则直接将较窄的类型提升为较宽的类型，否则，把两个数都转换为无符号的较宽的类型 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同级数据转换，unsigned int 和 int ，signed 类型会转换为 unsigned 类型 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;unsigned 操作数的转换依赖于机器中整型的相对大小，所以，这类转换依赖于机器。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;short 类型 与 int 类型 。在我的机器上，short 类型所占用的宽度为半字（2 Byte），int 类型占用的宽度为 1个字（4 Byte）。所有的 unsigned short 的值都包含在 int 之中，所以，unsigned short 转换为 int 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面程序&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;signed&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;unsigned int b&amp;#39; = &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;运行结果为&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4294967276&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;因为 &lt;code&gt;b = -2&lt;/code&gt; 被转化为一个很大的正数 &lt;code&gt;b' = 4294967276&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;references&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;c++ Primer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cppblog.com/wuzimian/archive/2012/05/28/176427.aspx"&gt;C++之char , signed char , unsigned char，以及Integral Promotion&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.51cto.com/art/200912/166574.htm"&gt;Linux C编程一站式学习：整型&lt;/a&gt;&lt;/p&gt;</summary><category term="data type"></category></entry><entry><title>Ubuntu 下安装 ISE &amp; Modelsim</title><link href="http://guqian110.github.io/pages/2014/03/27/install_ise_modelsim_on_ubuntu.html" rel="alternate"></link><updated>2014-03-27T20:52:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-03-27:pages/2014/03/27/install_ise_modelsim_on_ubuntu.html</id><summary type="html">&lt;p&gt;从 Windows 平台转移到 Linux，于是把 FPGA 的开发平台也搬过来。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;软件版本：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 13.10 Desktop amd64 &lt;/p&gt;
&lt;p&gt;ISE 14.7 for Linux&lt;/p&gt;
&lt;p&gt;ModelSim 6.5b for Linux&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE Design Suit for Linux&lt;/h3&gt;
&lt;p&gt;Xilinx 官方网站上有&lt;a href="https://secure.xilinx.com/webreg/register.do?group=dlc&amp;amp;htmlfile=&amp;amp;emailFile=&amp;amp;cancellink=&amp;amp;eFrom=&amp;amp;eSubject=&amp;amp;version=14.7&amp;amp;akdm=1&amp;amp;filename=Xilinx_ISE_DS_Lin_14.7_1015_1.tar"&gt;下载链接&lt;/a&gt;，但是在校园网内下载速度实在是蛋疼，还好有校内 bt 资源。&lt;/p&gt;
&lt;p&gt;我下载下来的 ISE 版本为 &lt;strong&gt;14.7&lt;/strong&gt;，tar 包大小为 6.5 G 。&lt;/p&gt;
&lt;h3&gt;ModelSim for Linux&lt;/h3&gt;
&lt;p&gt;网上的教程（2011 年前）都说是 &lt;a href="http://www.mentor.com/products/fpga/model"&gt;ModelSim 官方网站&lt;/a&gt; 上提供 ftp 下载链接，但是好像现在官网上不再提供下载链接了，我只找到 ModelSim PE Student Edition，而且还是 Windows 平台的...&lt;/p&gt;
&lt;p&gt;花费了一下午的时间，不停地在各个论坛注册下载附件，终于把 ModelSim_6.5b for Linux 下载下来了,结果安装时提示找不到 &lt;code&gt;libxp.so.6&lt;/code&gt; 库，于是 &lt;code&gt;apt-get&lt;/code&gt; 到一些 &lt;code&gt;libxp&lt;/code&gt; 的库，安装后仍然提示找不到，无奈放弃了，准备老老实实用 &lt;code&gt;ism&lt;/code&gt; 了（以后有时间了再慢慢折腾 T_T）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE DS 14.7&lt;/h3&gt;
&lt;p&gt;首先解压&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xvf&lt;/span&gt; &lt;span class="n"&gt;Xilinx_ISE_DS_Lin_14&lt;/span&gt;&lt;span class="mf"&gt;.7&lt;/span&gt;&lt;span class="n"&gt;_1015_1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;接着进入解压出来的目录并给安装文件赋予执行的权限&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;Xilinx_ISE_DS_Lin_14&lt;/span&gt;&lt;span class="mf"&gt;.7&lt;/span&gt;&lt;span class="n"&gt;_1015_1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;xsetup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;然后执行 xsetup&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;xsetup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;然后熟悉的图形界面就出来，和 Windows 下一样，同意安装许可协议，不停地下一步就可以安装成功。&lt;/p&gt;
&lt;p&gt;安装完成以后，运行&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;14.7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE_DS&lt;/span&gt;
&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;settings64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;此时，已经可以从终端运行 ISE 了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;nohup&lt;/span&gt; &lt;span class="n"&gt;ise&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;熟悉的图形界面出来了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ise" src="/images/install-ise-modelsim/ise_start.png" /&gt;&lt;/p&gt;
&lt;p&gt;P.S.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择安装版本时，选择 &lt;code&gt;System Edition&lt;/code&gt;，因为这个版本功能最全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择安装组件时，不要勾选 &lt;code&gt;Install Cable Drivers&lt;/code&gt;，我们自己编译安装另外一个驱动（因为此驱动只能在 Linux 内核 &amp;lt; 2.6的版本中使用，所以即使勾选了最后安装完成时会提示 &lt;em&gt;Driver installation failed&lt;/em&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Crack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又到了该和谐的地方了 =.=&lt;/p&gt;
&lt;p&gt;第一次打开 ISE 时，会自动弹出 License Management Tools 提示我们添加 License 。网上有一大堆破解包，我使用以前在 Windows 中生成的 Lincese，直接就可以使用了～&lt;/p&gt;
&lt;p&gt;再次声明：仅供技术交流，请支持正版软件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;installing Cable Drivers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如前面所说，因为 ISE 自带的驱动程序依赖于一个叫 windrvr 的文件。 而该文件目前只有 Linux 内核 2.4 的二进制版本，因此遇到高于 2.4 内核的 Linux发布版，如我使用的Ubuntu 13.10（Linux version 3.11.0-12-generic ） 就不工作了。&lt;/p&gt;
&lt;p&gt;好在一个叫 Michael Gernoth 的德国人，大公无私地写了一个 windrvr 的替代版本，并且开放源码，这样，无论碰到什么版本的内核，现场编译一个驱动并安装， 就能解决 Linux 内核版本匹配的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://rmdir.de/~michael/xilinx/"&gt;XILINX JTAG tools on Linux without proprietary kernel modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以按照说明&lt;/p&gt;
&lt;p&gt;首先安装 usb 驱动开发包，在 64 位系统下&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;libusb&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="n"&gt;libc6&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt; &lt;span class="n"&gt;fxload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;接着下载驱动程序的源代码&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//git.zerfleddert.de/usb-driver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;然后编译驱动程序&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;usb&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;下载下来的源代码中有个脚本可以设置好一切，我们只需要运行脚本就 ok&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;setup_pcusb&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;14.7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE_DS&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;把 Xilinx 路径添加到系统 PATH 中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;PATH=\$PATH:/opt/Xilinx/13.2/ISE_DS/ISE/bin/lin64/&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;export PATH&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这时候，写个小测试的程序，&lt;code&gt;Systhesize&lt;/code&gt; -&amp;gt; &lt;code&gt;Implement&lt;/code&gt; -&amp;gt; &lt;code&gt;Generate Programming File&lt;/code&gt;，打开 &lt;code&gt;iMPACT&lt;/code&gt;, 如图所示，可以看到已经识别出 JTAG 链上的芯片&lt;/p&gt;
&lt;p&gt;&lt;img alt="jtag" src="/images/install-ise-modelsim/jtag.png" /&gt;&lt;/p&gt;
&lt;h3&gt;ModelSim&lt;/h3&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;配置 ISE &amp;amp; ModelSim&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE&lt;/h3&gt;
&lt;p&gt;其实也没有特殊配置的地方，主要是自定义代码编辑器，目前我的主要使用的是 &lt;code&gt;sublime text 2&lt;/code&gt;，正在向 &lt;code&gt;vim&lt;/code&gt; 过度ing&lt;/p&gt;
&lt;p&gt;具体步骤 Edit -&amp;gt; Preferences -&amp;gt; Editors，选择 &lt;code&gt;custom&lt;/code&gt;，在右侧的 “Command line syntax” 中写自定义编辑器的执行路径&lt;/p&gt;
&lt;p&gt;配置自定义编辑器为 vim&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;gnome&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;terminal&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;maximize&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h3&gt;ModelSim&lt;/h3&gt;
&lt;p&gt;ModelSim 编译 Xilinx库，ISE 关联 ModelSim&lt;/p&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://rmdir.de/~michael/xilinx/"&gt;XILINX JTAG tools on Linux without proprietary kernel modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.george-smart.co.uk/wiki/Xilinx_JTAG_Linux"&gt;Xilinx JTAG Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/yunz1994/article/details/12350071"&gt;【Linux软件安装】Ubuntu12.04: Xilinx ISE 14.6&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="ISE"></category><category term="Modelsim"></category></entry><entry><title>学习 Vim 存活</title><link href="http://guqian110.github.io/pages/2014/03/25/learning_vim_survival.html" rel="alternate"></link><updated>2014-03-25T21:23:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-03-25:pages/2014/03/25/learning_vim_survival.html</id><summary type="html">&lt;p&gt;这个系列的博客是我学习 Vim 过程中的记录和总结，内容基本上来自网络上前辈们的博客，还有部分内容是我自己学习的心得。真心感谢前辈们的分享，我会尽量在后面的文章中标明内容出处，比如我学习 Vim 的路线就是按照这个博客&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/"&gt;vi/vim使用进阶: 目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来学习的。希望我的学习历程可以帮助到和我一样的菜鸟，能更好地使用这款神器～&lt;/p&gt;
&lt;p&gt;第一篇：入门/存活 Survival&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;
&lt;nr&gt;&lt;/p&gt;
&lt;h2&gt;Vim 是什么&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;简单的说，&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim&lt;/a&gt; 就是广大的编辑器中的一员，但是对程序猿来说，她并不是一款简单的编辑器。她强大的编辑能力、苗条的身材（软件体积小、启动速度快）和 Linux 系统的血缘关系（几乎是 Linux 系统的标配），使其在全世界有成千上万的粉丝，以至于掌握 Vim 成为每个码农必备技能。&lt;/p&gt;
&lt;p&gt;Wikipedia 上 Vim 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim (an acronym for Vi IMproved) is a text editor written by Bram Moolenaar and first released publicly in 1991. Based on the vi editor common to Unix-like systems, Vim is designed for use both from a command line interface and as a standalone application in a graphical user interface. Vim is free and open source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The license is compatible with the GNU General Public License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;摘抄（翻译）自 &lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;Wikipedia&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 vi/Vim 的发展，还是从头说起：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Ed_(text_editor)"&gt;ed&lt;/a&gt;&lt;/strong&gt; 是 UNIX 界最古老最基本的编辑器，它由 &lt;a href="http://en.wikipedia.org/wiki/Ken_Thompson_(computer_programmer)"&gt;Ken Thompson&lt;/a&gt; (UNIX 之父)于 1971 年在 &lt;a href="http://en.wikipedia.org/wiki/PDP-11"&gt;PDP-11&lt;/a&gt;/20 上用汇编写成 。ed 的许多特性来自于 &lt;a href="http://en.wikipedia.org/wiki/Ken_Thompson_(computer_programmer)"&gt;Thompson&lt;/a&gt; 在加州伯克利大学上学时受到的&lt;a href="http://en.wikipedia.org/wiki/QED_(text_editor)"&gt;qed&lt;/a&gt; 编辑器的影响 。Thompson 对 qed 非常熟悉，他在 &lt;a href="http://en.wikipedia.org/wiki/Compatible_Time-Sharing_System"&gt;CTSS&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Multics"&gt;Multics&lt;/a&gt; 操作系统上重新实现了一边 qed ，并且在他的版本中，第一次实现了正则表达式（ &lt;a href="http://en.wikipedia.org/wiki/Regular_expression"&gt;regular expressions&lt;/a&gt;）。虽然正则表达式也是 ed 的一部分，但是一般认为在 qed 中正则表达式的实现更多一些 。&lt;/p&gt;
&lt;p&gt;ed 是为电传机（&lt;a href="http://en.wikipedia.org/wiki/Teletype"&gt;teletype&lt;/a&gt;）而不是终端显示器（&lt;a href="http://en.wikipedia.org/wiki/Display_terminal"&gt;display terminals&lt;/a&gt;）设计的行编辑器，它是一个行编辑器。在它的起源地 —— AT&amp;amp;T 实验室，人们似乎很满意把 ed 设置为默认的编辑器，即使它的功能很基本而且很不友好。 &lt;a href="http://en.wikipedia.org/wiki/George_Coulouris_(computer_scientist)"&gt;George Coulouris&lt;/a&gt; 回忆说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] for many years, they had no suitable terminals. They carried on with TTYs and other printing terminals for a long time, and when they did buy screens for everyone, they got Tektronix 4014s. These were large storage tube displays. You can't run a screen editor on a storage-tube display as the picture can't be updated. Thus it had to fall to someone else to pioneer screen editing for Unix, and that was us initially, and we continued to do so for many years.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Coulouris 认为 ed 的隐藏的命令只适合于 “神人”（immortals），所以在 &lt;a href="http://en.wikipedia.org/wiki/Queen_Mary,_University_of_London"&gt;Queen Mary College&lt;/a&gt; 当讲师的期间，他在 Thompson 的代码的基础上加强了 ed，并且命名为 em （the "editor for mortals"）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;em&lt;/strong&gt; 是为终端显示器设计（display terminals）的，一次只显示一行的可视化编辑器，它是 UNIX 中第一个大量使用 "raw terminal input mode" 的程序，这种模式下，由应用程序而不是终端的驱动处理键盘的输入。1976 年夏天，Coulouris 参观 &lt;a href="http://en.wikipedia.org/wiki/University_of_California,_Berkeley"&gt;UC Berkeley&lt;/a&gt; 时，他带着一卷录有 em 的 DEC 磁带，他给很多人演示了 em ，有的人认为 em 只是有潜力，但是有的人却对此留下了深刻影响，其中就包括 &lt;a href="http://en.wikipedia.org/wiki/Bill_Joy"&gt;Bill Joy&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;受到 em 的鼓舞，加上他们自己使用 ed 时的技巧，Bill Joy 和 Chuck Haley 这两个刚从 UC Berkeley 的毕业的研究生使用 em 的代码，设计了一个叫 en 的编辑器，然后把 en 扩展为 &lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Ex_(editor)"&gt;ex&lt;/a&gt;&lt;/strong&gt; v0.1 。&lt;/p&gt;
&lt;p&gt;ex 仍然只显示一行而非一屏的内容。后来，Chuck Haley 退出了开发，Bruce Englar 鼓励 Bill Joy 重新设计了 ex，在 1977 年 6 月到 10 月期间，他为 ex 添加了全屏可视化模式 ，ex 的 visual mode 也就是 &lt;strong&gt;vi&lt;/strong&gt; 的命名原因 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;vi Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vi /ˈviːˈaɪ/ is a screen-oriented text editor originally created for the Unix operating system. The portable subset of the behavior of vi and programs based on it, and the ex editor language supported within these programs, is described by (and thus standardized by) the Single Unix Specification and POSIX.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;据 Bill Joy 讲，很多 vi 的可视化灵感来自于另外一个叫做 &lt;a href="http://en.wikipedia.org/wiki/Bravo_(software)"&gt;Bravo&lt;/a&gt; 的编辑器，在一次关于 vi 的起源的访谈中，他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A lot of the ideas for the screen editing mode were stolen from a Bravo manual I surreptitiously looked at and copied. Dot is really the double-escape from Bravo, the redo command. Most of the stuff was stolen. There were some things stolen from ed—we got a manual page for the Toronto version of ed, which I think Rob Pike had something to do with. We took some of the regular expression extensions out of that.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于为什么 vi 要设计成这么不友好，其实是有历史原因的：&lt;/p&gt;
&lt;p&gt;Joy 使用的是 Lear Siegler ADM3A 终端，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="Terminal_ADM3A" src="/images/learning-vim-survival/Terminal_ADM3A.png" /&gt;&lt;/p&gt;
&lt;p&gt;在这个终端上，&lt;code&gt;ESC&lt;/code&gt; 键的位置是现在 &lt;a href="http://en.wikipedia.org/wiki/IBM_PC_keyboard"&gt;IBM PC keyboard&lt;/a&gt; 键盘的 &lt;code&gt;Tab&lt;/code&gt; 键的位置，所以，选择 &lt;code&gt;ESC&lt;/code&gt; 作为模式切换键是很方便的设计 。同时，&lt;code&gt;h&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; 键也起方向键的作用，所以，vi 也采用相同的设计 。Joy 解释说，因为他开发软件时使用的 Modem 的速率只有 300 波特，显示器上的刷新速度还没有他的思考速度快，所以他设计了单字符这样的简洁风格的命令。&lt;/p&gt;
&lt;p&gt;1978 年 3 月，Joy 负责的 BSD Unix 发布了，系统自带了 ex 1.1，这为他的编辑器在 UC Berkeley 积攒了大量人气。从那时起，Unix 系统自带的编辑器只有 ed 和 ex 。在 1984 年的一次采访中，Joy 把 vi 的成功归功于免费，当时的其他编辑器，比如 Emacs 要花费数百美金 。&lt;/p&gt;
&lt;p&gt;观察显示基本上，所有的 ex 用户都是在 visual mode 下工作，所以在 ex 2.0（作为 1979 年 5 月的 BSD Unix 的一部分）中，Joy 把 vi 作为 ex 的硬链接，这样用户一打开 ex，就默认进入 visual mode ，所以说，vi 并不是 ex 的进化，vi 就是 ex 。&lt;/p&gt;
&lt;p&gt;虽然在今天看来，vi 是一个很小的，轻量级的程序，但是 Joy 把 ex 2.0(vi) 描述为一个非常大的程序，因为它几乎占据了 &lt;a href="http://en.wikipedia.org/wiki/PDP-11#Models"&gt;PDP-11/70&lt;/a&gt; 的所有内存。在 1979 年第3版 BSD 中，PDP-11 已经无法存储v3.1 的 vi 。&lt;/p&gt;
&lt;p&gt;Joy 一直领导着 vi 的开发，一直到 1979 年 6 月的 vi 2.7，到 1980 年 8 月的 v3.5 版本中，还作出偶尔的贡献。在谈及 vi 的起源和他为何退出开发时，他说，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I wish we hadn't used all the keys on the keyboard. I think one of the interesting things is that vi is really a mode-based editor. I think as mode-based editors go, it's pretty good. One of the good things about EMACS, though, is its programmability and the modelessness. Those are two ideas which never occurred to me. I also wasn't very good at optimizing code when I wrote vi. I think the redisplay module of the editor is almost intractable. It does a really good job for what it does, but when you're writing programs as you're learning... That's why I stopped working on it.&lt;/p&gt;
&lt;p&gt;What actually happened was that I was in the process of adding multiwindows to vi when we installed our VAX, which would have been in December of '78. We didn't have any backups and the tape drive broke. I continued to work even without being able to do backups. And then the source code got scrunched and I didn't have a complete listing. I had almost rewritten all of the display code for windows, and that was when I gave up. After that, I went back to the previous version and just documented the code, finished the manual and closed it off. If that scrunch had not happened, vi would have multiple windows, and I might have put in some programmability—but I don't know.&lt;/p&gt;
&lt;p&gt;The fundamental problem with vi is that it doesn't have a mouse and therefore you've got all these commands. In some sense, its backwards from the kind of thing you'd get from a mouse-oriented thing. I think multiple levels of undo would be wonderful, too. But fundamentally, vi is still ed inside. You can't really fool it.
It's like one of those pinatas—things that have candy inside but has layer after layer of paper mache on top. It doesn't really have a unified concept. I think if I were going to go back—I wouldn't go back, but start over again.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 1979 年， &lt;a href="http://en.wikipedia.org/wiki/Mary_Ann_Horton"&gt;Mark Horton&lt;/a&gt; 接管了 vi 的开发，他添加了对方向键和功能键的支持，用  terminfo 代替了 termcap，提高了 vi 的性能 。&lt;/p&gt;
&lt;p&gt;到 1981 年的 8 月，v3.7 版的 vi 以前，UC Berkeley 是 vi 开发的中心，但是随着 1982 年初 Joy 的离开去创办 &lt;a href="http://en.wikipedia.org/wiki/Sun_Microsystems"&gt;Sun Microsystems&lt;/a&gt;，AT&amp;amp;T 的  &lt;a href="http://en.wikipedia.org/wiki/UNIX_System_V"&gt;UNIX System V&lt;/a&gt; (1983 年 1 月)采用 vi，vi 代码库的变化开始变得缓慢混乱，而且变得相互不兼容。在 UC Berkeley，虽然有修改代码，但是版本号一直没有超过 3.7 。商业的 Unix 制造商，比如 Sun, &lt;a href="http://en.wikipedia.org/wiki/HP"&gt;HP&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Digital_Equipment_Corporation"&gt;DEC&lt;/a&gt;, 和 &lt;a href="http://en.wikipedia.org/wiki/IBM"&gt;IBM&lt;/a&gt;，他们的系统 &lt;a href="http://en.wikipedia.org/wiki/Solaris_(operating_system)"&gt;Solaris&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/HP-UX"&gt;HP-UX&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Tru64_UNIX"&gt;Tru64 UNIX&lt;/a&gt;, 和 &lt;a href="http://en.wikipedia.org/wiki/AIX"&gt;AIX&lt;/a&gt;，今天仍然在使用从 3.7 release 中衍生出来的代码，但是加入了新的特性，比如可以调整的按键映射、加密等 。&lt;/p&gt;
&lt;p&gt;虽然商业的制造商可以使用 Joy 的代码库（直至今天），但是有许多人却不能使用。因为 Joy 是在 Thompson 的 ed 的基础上开发的，所以 ex 和 vi 是派生出来的产品，不能发布给没有 AT&amp;amp;T 的许可证的人使用。想在类 Unix 系统上找到一个编辑器的话必须在别的地方寻找。1985年，一个 Emacs 的版本（&lt;a href="http://en.wikipedia.org/wiki/MicroEMACS"&gt;MicroEmacs&lt;/a&gt;）在很多平台上可以使用，但是直到 1987 年 6 月才出现一个 vi 的克隆版本 —— Steive 。在 1990 年 1 月初，Steve Kirkendall 为发布了一个新的 vi 克隆版本 &lt;a href="http://en.wikipedia.org/wiki/Elvis_(text_editor)"&gt;Elvis&lt;/a&gt;，它比 Stive 更加完整更加忠实于 vi 。它很快就吸引了社区用户的热情，&lt;a href="http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"&gt;Andrew Tanenbaum&lt;/a&gt; 马上在社区讨论在 &lt;a href="http://en.wikipedia.org/wiki/Minix"&gt;Minix&lt;/a&gt; 中使用哪一个当中 vi 的克隆，结果 Elvis 胜利了，直到今天仍然在 Minix 中当作 vi 的克隆体使用 。&lt;/p&gt;
&lt;p&gt;在 1989 年，&lt;a href="http://en.wikipedia.org/wiki/Lynne_Jolitz"&gt;Lynne Jolitz&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/William_Jolitz"&gt;William Jolitz&lt;/a&gt; 开始着手把 BSD Unix 移植到 386 系列的处理器上，为了发布一个免费版本，他们必须绕过 AT&amp;amp;T 含有的代码，其中就包括 Joy 的 vi 。为了填补 vi 的空白，他们在 1992 年的 386BSD 发布版中采用了 Elvis 作为 vi 的替代品，386BSD 后来的分支 &lt;a href="http://en.wikipedia.org/wiki/FreeBSD"&gt;FreeBSD&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/NetBSD"&gt;NetBSD&lt;/a&gt; 也延续了这一决定。但是在 UC Berkely，Keith Bostic 使用 Kirkendall 的 Elvis（v1.8）代码，编写了 &lt;a href="http://en.wikipedia.org/wiki/Nvi"&gt;nvi&lt;/a&gt;，并于 1994 年春发布。当 FreeBSD 和 NetBSD 在  4.4-Lite2 代码库的基础上重新同步以后，他们也采用了 nvi，并且一直延续到今天。&lt;/p&gt;
&lt;p&gt;虽然有很多 vi 的克隆体，而且它们都有很多加强的特性，但是在 2000 年前左右，Gunnar Ritter 使用了 2.11BSD 中的 Joy 的代码，并把 vi 移植到了类 Unix 系统中，比如 Linux 和 FreeBSD 。从技术上讲，他没有许可证而发布 vi 的做法是非法的，但是，到了 2002 年 1 月，AT&amp;amp;T 的许可证被取消了，vi 可以作为开源项目在其他发布版中使用。Ritter 继续在 Joy 的代码的基础上加强 vi 的特性，就像那些商业版一样。他的成果 &lt;a href="http://ex-vi.cvs.sourceforge.net/"&gt;Traditional Vi&lt;/a&gt; 在很多系统上运行。&lt;/p&gt;
&lt;p&gt;虽然 Joy 的 vi 现在又可以在 BSD Unix 上使用，但是 很多 BSD 的粉丝都转移到 更加强大、但仍然保留着 vi 的某些特性的 nvi 的阵地。从某种意义上说，这是一个奇怪的反常现象，在 Joy 的 vi 的发源地 BSD 中不再使用 vi，但是缺少它的 AT&amp;amp;T 的发行版却仍然保留了它并使用至今。&lt;/p&gt;
&lt;p&gt;在 1984 年 Emacs 发布以前，vi 几乎是所有 Hacker 使用的 Unix 标准编辑器，从 2006 年开始，作为 &lt;a href="http://en.wikipedia.org/wiki/Single_UNIX_Specification"&gt;”单一Unix标准“（Single UNIX Specification）&lt;/a&gt;的一部分，vi 和 vi 的变形体一定可以在今天的系统中找到。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Bram_Moolenaar"&gt;Bram Moolenaar&lt;/a&gt; 于 1988 年买了一台 [Amiga][Amiga] 计算机，Amiga 上没有他常用的 vi，于是他在开源的 Stevie 的基础上，于 1991 年发布了 Vim v1.14 。&lt;/p&gt;
&lt;p&gt;起初 &lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim&lt;/a&gt;&lt;/strong&gt; 是 &lt;em&gt;”Vi IMitation“&lt;/em&gt; 的缩写，但是后来 1993 年 12 发布的 Vim 2.0 版本中改名为 &lt;em&gt;"Vi IMproved"&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;vim 现在是 &lt;a href="http://en.wikipedia.org/wiki/GNU_General_Public_License"&gt;GNU General Public （GPL）&lt;/a&gt;下的自由软件，几乎在所有的 Linux 系统和 苹果 OS X 系统中都可以找到她的身影。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 Vim&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;程序猿界的 &lt;strong&gt;圣战：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows&lt;/strong&gt; vs &lt;strong&gt;Linux&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vim/Emacs&lt;/strong&gt; vs &lt;strong&gt;IDE&lt;/strong&gt; (&lt;strong&gt;Vim&lt;/strong&gt; vs &lt;strong&gt;Emacs&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt; vs &lt;strong&gt;JAVA&lt;/strong&gt; vs &lt;strong&gt;Python&lt;/strong&gt; vs ...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先是在 Vim 和 IDE 之间的争论。&lt;/p&gt;
&lt;h3&gt;Vim &amp;amp; IDE&lt;/h3&gt;
&lt;p&gt;”到底是该选择 vim 还是 IDE ？“ 在 Stackoverflow 和 知乎 上有非常多的这样的帖子。&lt;/p&gt;
&lt;p&gt;比如这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim"&gt;What is your most productive shortcut with Vim?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再比如这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/21504638"&gt;为什么不少程序员极度推崇 Vim 和 Emacs，却对 IDE 嗤之以鼻？??&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总之，萝卜芹菜各有所爱，有 Geek 精神、喜欢折腾的人不用你去说服，他自然会去学习 Vim，没有心情、懒得折腾的人，你再怎么说 Vim 好，他也不会去尝试 。（是的，我就是喜欢折腾的人 ^_^）&lt;/p&gt;
&lt;p&gt;个人选择 Vim 的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Vim 是 Linux 的 ”标配“ 编辑器，在 Linux 下开发，不会 Vim 的程序猿不是好程序猿&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还是因为 Linux 的原因。大多数 Linux 下的程序都是不需要界面的，终端才是 Linux 的精华，千万不要成迷于界面。在终端下，除了选择 Vim 你说还能选谁呢？ 因为 Vim 和 Linux 的 ”血缘“ 关系，终端 &amp;amp; Vim 给你纯正的 Linux 哲学体验（再说当你远程ssh登录时，总不能还用 IDE 吧？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim 下有着高度的编码一致性体验。学会了 Vim，写不同语言不同代码的体验是一样的，妈妈再也不用担心我要花时间学习不同的 IDE 了~&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我写的代码基本只限定在底层开发，主要代码是 C/C++、Shell脚本、Python脚本，不会涉及到 JAVA，更不会涉及前端开发；而且都是我的 ”玩具小程序“，几乎不涉及好几百个源文件的项目，所以我不需要 IDE 的强大的管理能力，写一个 makefile 就 OK 了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习过 CPU 知识的人都知道，频繁打断流水线才是最影响效率的东西。在调试代码的时候，显然纯键盘流要比不停的 ”鼠标 -&amp;gt; 键盘 -&amp;gt; 鼠标 -&amp;gt; ...“ 有效率的多，而且省事。&lt;a href="http://www.zhihu.com/question/22096642/answer/20290505"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;崇尚 Geek 文化，喜欢 ”折腾“，Linux 哲学教导我要学习轻量级的 Vim，而不是笨重的 IDE 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;vim &amp;amp; emacs&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;来自 wiki 百科：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Editor_war"&gt;Editor war&lt;/a&gt; 是指两类文本编辑器 Vi（以及衍生版本） 和 Emacs 之间的争论，这已经成为 hacker 文化和自由软件社区文化的一部分 。&lt;/p&gt;
&lt;p&gt;因为他们都认为自己的选择是完美的，所以相互蔑视，相互之间争论（点燃战火）。相比其他的 IT 领域战争（如浏览器大战、操作系统之争、编程语言之争、代码缩进风格之战)，编辑器的选择其实通常只是个人问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vim 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;遵循“简单工具，多样组合”的理念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小，符合Unix哲学中的“只做一件事，并做好它”，避免了功能蔓延。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比Emacs快（至少历史上是这样的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可运行于任何实现了C标准库的系统之上，包括UNIX、Linux、AmigaOS、DOS、Windows、Mac、BeOS和POSIX兼容系统等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让“QWERTY”键盘用户将手指保持在默认键位上，使编辑时手指移动更少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更普及。基本上所有Unix和类Unix系统都默认提供了vi或其变体。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Emacs 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符合“厨房水槽”理念，提供了比 vi 更多的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移植最广泛的非试用计算机程序之一。它能在各种操作系统上运行，包括大多数类 Unix 系统（GNU/Linux、各种 BSD、Solaris、AIX、IRIX、AmigaOS、Mac OS X等）、MS-DOS、Microsoft Windows 和 OpenVMS。Unix 系统，无论自由版本或商业版本，均随系统提供 Emacs 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展和可定制（Lisp的变体 - Emacs Lisp）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;幽默&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Richard_Stallman"&gt;Richard Stallman&lt;/a&gt; 组建了 The Church of Emacs，它称 vi 为 “魔鬼的编辑器”（vi-vi-vi 在罗马数字中表示兽名数目）。然而它并不反对 vi；相反，它视私有软件为诅咒。（“使用自由版本的 vi 不是罪恶，而是赎罪。”）它还有专门的新闻组，alt.religion.emacs，发布主题宣扬这个滑稽的宗教。&lt;/p&gt;
&lt;p&gt;Stallman 曾称自己是St IGNU−cius，Emacs教会的圣人。&lt;/p&gt;
&lt;p&gt;vi支持者也成立了对立的 Cult of vi，较强硬的 Emacs 的用户攻击这是“抄袭他们的创意”。&lt;/p&gt;
&lt;p&gt;关于vi的模式，一些 Emacs 用户说 vi 有两个模式 – “不停地哔哔叫” 和 “搞砸一切”。vi 用户则指责 Emacs 的快捷键会引发 "腕管综合症"，或者拿 EMACS 这个缩写词作文章，比如 “Escape Meta Alt Control Shift”（攻击Emacs太依赖修改键）。一些人断定是代表 “Eight Megabytes And Constantly Swapping”（8 MB，还不断进行内存交换，过去这已经是很多内存了），或者 “EMACS Makes Any Computer Slow”（EMACS使一切计算机跑得慢，这是斯托曼惯用的递归缩写），讽刺Emacs对系统资源的高需求。&lt;/p&gt;
&lt;p&gt;针对 Emacs 的“功能蔓延”，vi 支持者认为 Emacs 是 “一个伟大的操作系统，只缺个体面的编辑器”。&lt;/p&gt;
&lt;p&gt;UNIX 用户中流行一个游戏，考验一个 Emacs 用户对这个编辑器的理解深度，或者是拿 Emacs 的复杂性开玩笑，内容是：预测一下，如果一个用户按住修改键（比如 Control 或 Alt），然后键入自己的名字，会发生什么事。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;开始学习 Vim&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;闲扯了这么多，终于开始学习 vim 了...&lt;/p&gt;
&lt;p&gt;结合我的痛苦的学习过程，至今还在痛苦ing，我觉得以下的学习顺序比较适合我这样的新手：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入门：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，在终端下输入 vimtutor 就能进入一个 vim 自带的教程，大概花半个小时的时间就能做完。完成以后基本上就可以说是可以使用这款 大(chou)名(ming)鼎(zhao)鼎(zhu) 的 ”反人类“  的编辑器～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习 陈皓 大神在 &lt;a href="http://coolshell.cn/"&gt;coolshell&lt;/a&gt; 的博客 &lt;a href="http://coolshell.cn/articles/5426.html"&gt;vim 练级攻略&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同样，&lt;a href="http://coolshell.cn/"&gt;coolshell&lt;/a&gt; 上介绍的一个关于 Vim 的游戏 —— &lt;a href="http://vim-adventures.com/"&gt;vim adventrue&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去图书馆借本书 &lt;em&gt;&lt;a href="http://book.douban.com/subject/3041178/"&gt;Learning the vi and Vim Editors&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;阅读 Vim manpage 和 &lt;a href="https://github.com/asins/vimcdoc"&gt;安装 vim docs 中文版插件&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一本书 &lt;em&gt;&lt;a href="http://book.douban.com/subject/10599776/"&gt;Pratical Vim&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim 作者 Bram Moolenaar 的文档 &lt;em&gt;&lt;a href="http://www.moolenaar.net/habits.html"&gt;seven habits for effective text editing&lt;/a&gt;&lt;/em&gt;  和 &lt;a href="http://v.youku.com/v_show/id_XMTIwNDY5MjY4.html"&gt;演讲视频&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/"&gt;vi/vim使用进阶&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;vi wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="Vim"></category></entry><entry><title>Code 书评</title><link href="http://guqian110.github.io/pages/2014/03/21/code_review.html" rel="alternate"></link><updated>2014-03-21T16:33:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-03-21:pages/2014/03/21/code_review.html</id><summary type="html">&lt;p&gt;最近花了一个星期的时间，终于把 &lt;a href="http://book.douban.com/subject/1494026/"&gt;&lt;em&gt;Code&lt;/em&gt;&lt;/a&gt; 看完了，看完全书，观后感总结出来就一个字——爽～&lt;/p&gt;
&lt;p&gt;书名： &lt;a href="http://book.douban.com/subject/1494026/"&gt;&lt;em&gt;Code:  The Hidden Language of Computer Hardware and Software&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者： &lt;a href="http://charlespetzold.com/"&gt;Charles Petzold&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这本书的作者 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; 是 Windows 编程界一位大师，世界顶级技术作家。1994 年 5 月，Petzold 作为仅有的七个人之一（并且是唯一的作家）被《Window Magazine》和 Microsoft 公司授予 “Windows Pioneer” 奖，以表彰他对 Microsoft Windows 的成功做出的贡献 。&lt;/p&gt;
&lt;p&gt;关于这本书的 “江湖地位” ，只需要来看看 stackoverflow 上的这个帖子就明白了：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read"&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本书排名在 &lt;em&gt;第15&lt;/em&gt;，当然绝对排名没有很大的意义，但是也能说明本书的影响力 。另外本书号称 “完全不懂计算机的人也能看懂”... 如果这都不读，我不知道还有什么样的书值得我们去花费时间 : D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;打通任督二脉&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;纵观程序员的 “武功秘籍”，不外乎两种：一种是讲 &lt;code&gt;道&lt;/code&gt;，另外一种是讲 &lt;code&gt;术&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;道&lt;/code&gt; 即 “道理”（真理），是脱离了具体事物，抽象出来的事物的本质 。比如平时学习的 &lt;em&gt;数学&lt;/em&gt;、&lt;em&gt;物理&lt;/em&gt;、&lt;em&gt;化学&lt;/em&gt; 知识，再比程序中的 &lt;em&gt;算法&lt;/em&gt;、分析解决问题的 &lt;em&gt;思维方式&lt;/em&gt; 等，都不会因时间和环境变化而不适用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;术&lt;/code&gt; 即 “技术”（技巧），是人们在具体工程实践中总结出来的一些技巧。比如 “The art of XXX” ，“The principle of XXX” 等 。&lt;/p&gt;
&lt;p&gt;是的，这本书既不是单独讲 &lt;code&gt;道&lt;/code&gt;，也不是单独讲 &lt;code&gt;术&lt;/code&gt;，而是将两者结合起来，让你不仅明白 &lt;em&gt;道&lt;/em&gt;  的深奥，也明白 &lt;em&gt;术&lt;/em&gt; 的精妙；让你体会到 &lt;em&gt;道&lt;/em&gt; 是如何在 &lt;em&gt;术&lt;/em&gt; 中实现，也体会到 &lt;em&gt;术&lt;/em&gt; 是如何在 &lt;em&gt;道&lt;/em&gt;   的约束下追求极限的 。更加关键的是全书都是用很平白的语言讲述，平白到 “即使完全不懂计算机的人也能读懂”的地步，这就是其厉害之处了。&lt;/p&gt;
&lt;p&gt;就好像你学习了五花八门的心法秘籍和各式武功，每一门都厉害无比，可偏偏无法把这些武功融会贯通，修至大成 。这时候，你需要的不是一本《葵花宝典》，而是《论天下武功之间的关系及其融会贯通方法》，打通自己的任督二脉，也就是这本 &lt;a href="http://book.douban.com/subject/1494026/"&gt;Code&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;读这本书时，让我想起了在大学 4 年间读的各种课程：&lt;/p&gt;
&lt;p&gt;读到 第 6 章 “电报机与继电器” 让我想起 &lt;em&gt;大学物理&lt;/em&gt; ，虽然翘了很多课，但是电磁感应什么的有中学基础，还好没有忘记 。&lt;/p&gt;
&lt;p&gt;读到 第 7～9 章，书中对计数的方法和进制的讨论，让我想起 &lt;em&gt;大学计算机基础&lt;/em&gt; ，然后花了一天时间去把以前一知半解的 “原码、反码、补码” 仔细推敲总结一遍，收获颇大 。&lt;/p&gt;
&lt;p&gt;读到 第 10 章，布尔代数 让我想起 &lt;em&gt;离散数学&lt;/em&gt; ，尤其发人深醒的是布尔发明了 布尔逻辑 100 多年后， 才有人（香农）将其和电路联系起来 。&lt;/p&gt;
&lt;p&gt;读到 第 11～13 章，跟随作者的思路，我才明白当年令人痛不欲生的 &lt;em&gt;模拟电路&lt;/em&gt; 、&lt;em&gt;数字电路&lt;/em&gt;  到底是来干什么的，数字电路是如何从最基本的门搭建出来更强的功能的元器件的，联系前面学习的 编码的知识，明白这样做的道理 。&lt;/p&gt;
&lt;p&gt;读到 第 16～22 章，让我想起 &lt;em&gt;微机原理&lt;/em&gt; ，对微处理器的工作方式不再模糊不清，跟随着作者的思路搭建一台 “计算机”（当然和现在的计算机完全不同，但是原理是一模一样的），为自己搭建的处理器设计一套可以实现自动功能的编程语言，然后写一段程序，甚至一窥操作系统 。&lt;/p&gt;
&lt;p&gt;还有等等...&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;
胡扯了这么多，书固然是好书，但是更让人深思的是 国内外教育的差异 。吐槽我们的教育体制毫无意义，吐槽的人都当不上教育部长，没有能力去改变现状，有能力的 guan猿却根本没有动力去改变。作为普通人，我们能做到的就是自己努力，找真正的好书、向真正的大师学习，比如上面提到过的&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read"&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了技术、还有很多程序员需要看的书。找到一本好书，然后 Let's start it !&lt;/p&gt;</summary><category term="Code"></category><category term="review"></category></entry><entry><title>原码、反码、补码</title><link href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html" rel="alternate"></link><updated>2014-03-19T14:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-03-19:pages/2014/03/19/signed_number_representations.html</id><summary type="html">&lt;p&gt;最近找到一本好书——&lt;a href="http://book.douban.com/subject/4822685/"&gt;《编码: 隐匿在计算机软硬件背后的语言》&lt;/a&gt;。作者是大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; (&lt;a href="http://charlespetzold.com/"&gt;个人网站&lt;/a&gt;)。书的介绍也很有意思，据说完全不懂计算机的人也能看懂...于是买了本来拜读一下（这种文章当然是英文版最好了，只是学生党没银子，只好买翻译版了）&lt;/p&gt;
&lt;p&gt;看到用继电器搭建加法器、减法器，讨论二进制编码方式那章，想起一直不是很清楚的原码、反码、补码等，果断 &lt;a href="https://www.google.com.hk/"&gt;Google&lt;/a&gt;、&lt;a href="http://en.wikipedia.org/wiki/Main_Page"&gt;Wiki&lt;/a&gt;，于是总结出下文。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;机器数&lt;/h3&gt;
&lt;p&gt;顾名思义，一个数字在机器中的存储方式，“&lt;em&gt;数&lt;/em&gt; ” 是指 有符号数（&lt;code&gt;signed number&lt;/code&gt;），即包含了正负号的数，“&lt;em&gt;机器&lt;/em&gt; ” 当然是指计算机（&lt;code&gt;Computer&lt;/code&gt;）了。&lt;/p&gt;
&lt;p&gt;从小学毕业，刚进入初中，我们就知道数字是有符号的：&lt;em&gt;正数&lt;/em&gt; &amp;amp; &lt;em&gt;负数&lt;/em&gt;。但是在计算机的哲学体系中，整个世界只有两个元素：0 &amp;amp; 1 ，没有额外的专门表示正负号的符号。怎么办呢？解决方法就是添加一位来表示符号。于是，人们约定把符号位放在一个数字的 &lt;em&gt;最高有效位&lt;/em&gt;（Most significant bit, &lt;code&gt;MSB&lt;/code&gt;），在&lt;a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F"&gt;大端序&lt;/a&gt;中，&lt;code&gt;MSB&lt;/code&gt; 指的是一个二进制数的最左边的一位。一般，&lt;code&gt;MSB&lt;/code&gt; 等于 0  表示正数，1 表示负数。&lt;/p&gt;
&lt;h3&gt;真值&lt;/h3&gt;
&lt;p&gt;因为机器数中有一位表示符号，所以机器数的形式值不等于真正的数值，机器数对应的数值称为机器数的 &lt;em&gt;真值&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
举个栗子：&lt;/p&gt;
&lt;p&gt;用 8 bit 表示一个数字，因为有符号位的存在，可以表示的范围为 (-127, -0, +0, +127) 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# +5 的 机器数 = 0000_0101 ；真值 = + 000_0101&lt;/span&gt;

&lt;span class="c"&gt;# -5 的 机器数 = 1000_0101 ；真值 = - 000_0101&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种机器数的编码方式称为 &lt;a href="http://en.wikipedia.org/wiki/Signed_magnitude#Signed_magnitude_representation"&gt;&lt;em&gt;原码&lt;/em&gt;&lt;/a&gt; (&lt;code&gt;signed-magnitude&lt;/code&gt;) ，是机器数编码方式中的一种。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The four best-known methods of extending the binary numeral system to represent signed numbers are: sign-and-magnitude, Ones' complement, two's complement, and excess-K.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There is no definitive criterion by which any of the representations is universally superior. The representation used in most current computing devices is two's complement, although the Unisys ClearPath Dorado series mainframes use Ones' complement.&lt;/em&gt;
（&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations"&gt;Wikipeida&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;下面分别讨论：&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;机器数表示法&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;原码（sign and magnitude）&lt;/h3&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数：  0_xxxxxxx&lt;/span&gt;

&lt;span class="c"&gt;# 负数：  1_xxxxxxx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit 的原码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 两数符号相同：  低位相加，最高位的符号位不变（当低位相加产生进位时，溢出 Overflow）&lt;/span&gt;

&lt;span class="c"&gt;# 两数符号不同：  比较绝对值的大小，差的绝对值 = 大数 - 小数 ，符号位和大数的符号位相同&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电路复杂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从前面的计算方法中可以看到，原码中的符号位不能直接参与运算，必须要单独的线路来确定符号位&lt;/li&gt;
&lt;li&gt;原码的计算不能避免减法运算，加法运算是产生 &lt;em&gt;进位&lt;/em&gt;，减法运算需要 &lt;em&gt;借位&lt;/em&gt;，这是两种不同的运算过程，需要额外的电路把 &lt;code&gt;加法器&lt;/code&gt; 改造为 &lt;code&gt;减法器&lt;/code&gt;（&lt;a href="http://www.charlespetzold.com/code/"&gt;《编码》&lt;/a&gt;这本书里面有详细介绍 如何使用继电器搭建 加法器 和 减法器）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0的表示不唯一&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0可以编码为两种方式： &lt;code&gt;0000_0000&lt;/code&gt; 和 &lt;code&gt;1000_0000&lt;/code&gt;，进一步增加了逻辑的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;This approach is directly comparable to the common way of showing a sign (placing a "+" or "−" next to the number's magnitude). Some early binary computers (e.g., &lt;a href="http://en.wikipedia.org/wiki/IBM_7090"&gt;IBM 7090&lt;/a&gt;) used this representation, perhaps because of its natural relation to common usage. Signed magnitude is the most common way of representing the significand in floating point values.
（&lt;a href="http://en.wikipedia.org/wiki/Signed_magnitude#Signed_magnitude_representation"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;虽然 &lt;code&gt;原码&lt;/code&gt; 的编码方式最接近人类的习惯，但是，并不适合在计算机中使用，为了解决原码计算中的一些问题，于是 &lt;code&gt;反码&lt;/code&gt; 就出现了&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;反码（Ones' complement）&lt;/h3&gt;
&lt;p&gt;首先，来看看 &lt;a href="http://www.charlespetzold.com/code/"&gt;Code&lt;/a&gt; 中介绍了基于10进制的补码：&lt;/p&gt;
&lt;p&gt;实现一个减法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照我们从数学课上学习到知识，这个计算需要进行 &lt;em&gt;借位&lt;/em&gt; 操作，为了避免这个在计算机中很难实现的操作，可以稍微变化一下计算过程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个过程中，用两个减法代替了原来的一个减法，避免了烦琐的 &lt;em&gt;借位&lt;/em&gt; 操作。在这个运算中，负数 &lt;code&gt;-176&lt;/code&gt; 转化为另外一个数 &lt;code&gt;999 - 176&lt;/code&gt; ，这个数称为它的 &lt;code&gt;9 的补数(nine's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 9 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;1 的补数(Ones' complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;把减数从一串 1 当中减去，结果就称为这个数的 “1 的补数”，在求 1 的补数的时候，其实并不需要做减法，因为求 1 的补数，只需要将原来的 1 变为 0 ，0 变为 1 即可，也就是取反，在电路中只需要一个反向器就可以实现，所以 &lt;code&gt;1 的补数&lt;/code&gt; 也称为 &lt;code&gt;反码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;从上面的描述就可以很容易写出反码的编码规则&lt;/p&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数    反码 = 原码&lt;/span&gt;

&lt;span class="c"&gt;# 负数    反码 = 符号位不变，其他位取反&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit 的反码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;p&gt;反码的计算不用区分符号和绝对值，直接进行计算，计算结果若有溢出，需要将溢出加到最低位，这种操作称为 “循环进位”（end-around carry）&lt;/p&gt;
&lt;h4&gt;优缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;优点，电路简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，所以反码计算不需要单独的判断符号的电路，也不需要判断两个数绝对值相对大小的电路&lt;/li&gt;
&lt;li&gt;节省了减法器，只需要一组额外的反向器就能把加法器改进为可以计算 加 / 减法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机中仍然需要进行 “循环进位” 的硬件电路，但是这种复杂度的电路是可以接受的&lt;/li&gt;
&lt;li&gt;0的表示不唯一，0的编码仍然有两种方式： &lt;code&gt;0000_0000&lt;/code&gt; 和 &lt;code&gt;1111_1111&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;The &lt;a href="http://en.wikipedia.org/wiki/PDP-1"&gt;PDP-1&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC_160_series"&gt;CDC 160 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC_6000_series"&gt;CDC 6000 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/UNIVAC_1100"&gt;UNIVAC 1100 series&lt;/a&gt;, and the &lt;a href="http://en.wikipedia.org/wiki/LINC"&gt;LINC&lt;/a&gt; computer used Ones' complement representation.（&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations#Ones.27_complement"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;反码&lt;/code&gt; 中仍然没有避免 0 有两种编码方式的问题，虽然对于人来说，+0 和 -0 没有区别，但是对于计算机来说，判断一个数是否为0，要进行两次判断。为了解决 0 的表示问题和硬件上的 “循环进位”，于是人们又发明了 &lt;code&gt;补码&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;补码（Two's complement）&lt;/h3&gt;
&lt;p&gt;前面介绍的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照反码的方法可以转换为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果我们稍微再变形一下，就有&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (1000 - 176) - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个运算中 &lt;code&gt;-176&lt;/code&gt; 转化为 &lt;code&gt;1000 - 176&lt;/code&gt;，这个数称为它的 &lt;code&gt;10 的补数(ten's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 10 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;2 的补数(two's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;因为对一位二进制数 b 取补码就是 &lt;code&gt;1 - b + 1 = 10 - b&lt;/code&gt;，相当于从 2 里面减去 b ,所以，这种方法称为 &lt;code&gt;2 的补数&lt;/code&gt;，这种编码方式简称 &lt;code&gt;补码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;举例说明，要表示 -4 ，需要对 &lt;code&gt;0000_0100&lt;/code&gt;取补码，&lt;code&gt;1111_1111 - 0000_0100 + 1 = 1_0000_0000 - 0000_0100&lt;/code&gt;，相当于从2^8里面减去 4 。&lt;/p&gt;
&lt;p&gt;从上面的计算过程可以很容易写出补码的编码规则&lt;/p&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数    补码 = 原码&lt;/span&gt;

&lt;span class="c"&gt;# 负数    补码 = 反码 + 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit补码可以表示的范围是 [ -128, -1, +0, +127 ]，共 256 个数 。&lt;/p&gt;
&lt;p&gt;目前大多数计算机内部使用的都是补码，所以对于编程中的 32 位 &lt;code&gt;int&lt;/code&gt; 型变量，它可以表示的范围就是 [ -2^32, +2^32 - 1] 。&lt;/p&gt;
&lt;p&gt;P.S. -128 没有对应的 原码 和反码，它的补码为 &lt;code&gt;1000_0000&lt;/code&gt; 。&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;p&gt;采用补码的系统，减法转换成加法（减法等同于加上一个负数，所以不再有减法），忽略计算结果最高位的进位，不必加回到最低位上去。&lt;/p&gt;
&lt;h4&gt;优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;电路简单，从计算法则中可以看到，不用考虑 “循环进位” 的问题，所以，补码系统的电路是最简单的，这也是补码系统应用最广泛的原因&lt;/li&gt;
&lt;li&gt;0 的表示是唯一的，&lt;code&gt;0000_0000&lt;/code&gt;，不再有 -0 的困扰&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;补码中的数学原理&lt;/h4&gt;
&lt;p&gt;补码能将减法转化为加法，其数学原理就是 &lt;em&gt;模&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 如果有个手表的时间为6点，实际时间为4点，那么如何校准呢？&lt;/span&gt;

&lt;span class="c"&gt;# 答案有两种方法：&lt;/span&gt;

&lt;span class="c"&gt;#   1. 逆时针转动  2，也就是做 减法 6 - 2 = 4&lt;/span&gt;
&lt;span class="c"&gt;#   2. 顺时针转动 10, 也就是做 加法 (6 + 10) mod 12 = 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从这个例子中就可以很明白的看到 &lt;em&gt;减法&lt;/em&gt; 是如何转化为 &lt;em&gt;加法&lt;/em&gt; 的，也就是如何将一个 &lt;em&gt;负数&lt;/em&gt; 转化为 &lt;em&gt;正数&lt;/em&gt;的 。&lt;/p&gt;
&lt;p&gt;即有公式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A - B = A + (-B + M)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个式子中的 &lt;code&gt;-B + M&lt;/code&gt; 即为 &lt;code&gt;B&lt;/code&gt; 的 &lt;em&gt;补数&lt;/em&gt; （类似于几何中的&lt;em&gt;补角&lt;/em&gt;） 。&lt;/p&gt;
&lt;h4&gt;溢出问题（摘自 &lt;a href="http://baike.baidu.com/view/60437.htm"&gt;百度百科&lt;/a&gt;）&lt;/h4&gt;
&lt;p&gt;无论采用何种机器数，只要运算的结果大于数值设备所能表示数的范围，就会产生溢出。 溢出现象应当作一种故障来处理，因为它使结果数发生错误。异号两数相加时，实际是两数的绝对值相减，不可能产生溢出，但有可能出现正常进位；同号两数相加时，实际上是两数的绝对值相加，既可能产生溢出，也可能出现正常进位。&lt;/p&gt;
&lt;p&gt;由于补码运算存在符号位进位自然丢失而运算结果正确的问题，因此，应区分补码的溢出与正常进位。&lt;/p&gt;
&lt;p&gt;详细论证过程不再复制粘贴了...直接给出结论&lt;/p&gt;
&lt;p&gt;结论：在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;由 &lt;em&gt;“减去一个数 = 加上一个负数”&lt;/em&gt;，计算机系统内部就不再有减法操作&lt;/p&gt;
&lt;p&gt;由 &lt;em&gt;“负数的表示由取模运算转变为补码表示”&lt;/em&gt;，计算机系统就可以用一个正数来表示负数&lt;/p&gt;
&lt;p&gt;所以，计算机内部只需要加法器就可以完成 加减法 和 正负数 的表示 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Two's complement is the easiest to implement in hardware, which may be the ultimate reason for its widespread popularity. Processors on the early mainframes often consisted of thousands of transistors – eliminating a significant number of transistors was a significant cost savings. Mainframes such as the IBM System/360, the GE-600 series, and the PDP-6 and PDP-10 used two's complement, as did minicomputers such as the PDP-5 and PDP-8 and the PDP-11 and VAX. The architects of the early integrated circuit-based CPUs (Intel 8080, etc.) chose to use two's complement math. As IC technology advanced, virtually all adopted two's complement technology. x86, m68k, Power Architecture, MIPS, SPARC, ARM, Itanium, PA-RISC, and DEC Alpha processors are all two's complement.&lt;/em&gt;(&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations#Two.27s_complement"&gt;Wiki&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;有符号数和无符号数（摘自 &lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;）&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;如果把所有的位数都用来表示数值的大小，那么8 bit 二进制数可以表示的范围是 [0, 255] ，这种称为无符号数 。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c"&gt;#   1000_0010              130                  -126&lt;/span&gt;
    &lt;span class="c"&gt;# + 1111_1000     =&amp;gt;   +   256          =&amp;gt;  +   -  8&lt;/span&gt;
    &lt;span class="c"&gt;# --------------      ---------------      -----------&lt;/span&gt;
    &lt;span class="c"&gt;# 1_0111_1010              122 + 256             122&lt;/span&gt;

    &lt;span class="c"&gt;#                        无符号数（ok）        有符号数（error）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;计算机的加法器在做完计算之后，根据最高位产生的进位设置 &lt;em&gt;进位标志&lt;/em&gt; ，同时根据最高位和次高位产生的进位的异或设置 &lt;em&gt;溢出标志&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;如果看作无符号数130和248相加，计算结果是122进1，也就是122+256，这个结果是对的; 如果把这两个操作数看作有符号数-126和-8相加，计算结果是错的，因为产生了溢出 。&lt;/p&gt;
&lt;p&gt;至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。&lt;/p&gt;
&lt;p&gt;通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有bit都是零则设置零标志，如果计算结果的最高位是1则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;从 &lt;code&gt;原码&lt;/code&gt; 到 &lt;code&gt;反码&lt;/code&gt;，再到 &lt;code&gt;补码&lt;/code&gt;，可以清楚看到为了解决问题而改进的技术路线，虽然这些是非常基础知识，可能对我们对写程序没有很大的帮助，但是搞清楚这些不仅让你对计算机底层更加了解，更加关键的是 &lt;em&gt;这个学习过程&lt;/em&gt; 和 &lt;em&gt;解决编码问题的思路&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations"&gt;Signed number representations——Wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Ones'_complement"&gt;Ones' complement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Two's_complement"&gt;Two's complement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://baike.baidu.com/view/60437.htm"&gt;机器数——百度百科&lt;/a&gt;&lt;/p&gt;</summary><category term="Code"></category></entry><entry><title>First Blood</title><link href="http://guqian110.github.io/pages/2014/03/17/first_blood.html" rel="alternate"></link><updated>2014-03-17T14:29:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-03-17:pages/2014/03/17/first_blood.html</id><summary type="html">&lt;h2&gt;为什么要搭建自己的博客&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;首先，来看看各类门户博客的优缺点。&lt;/p&gt;
&lt;p&gt;国内大多数人的朋友圈都聚集在 QQ、微博、人人等社交平台上。但是这些社区并不适合写博客，面对满屏幕毫无营养的转载文章和五颜六色的广告，谁还有兴趣把自己的生活感悟写下来？其实，我们需要的仅仅是一方可以写字的净土。至于各大技术博客平台，它们明显不适合用来记录生活中的点滴琐事。CSDN 的博客系统一直是人们的吐槽对象，况且，CSDN 已经沦为学生求作业的地方，很多大神都转移阵地，去搭建自己的博客了。&lt;/p&gt;
&lt;p&gt;既然这些平台都不能满足我们的需求，为什么我们不搭建一个属于自己的博客呢？&lt;/p&gt;
&lt;p&gt;我们写博客是为了记录自己的学习、生活和成长，寻找志同道合的知己。个人博客也是一种身份，代表了博主的兴趣爱好和品味。我们自己是博客的主人，可以自己定制主题和内容，而无需经受别人的审核和莫名删除的烦恼。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 Markdown + Pelican + GitHub&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;不同于面向 &lt;em&gt;发布&lt;/em&gt; 的 &lt;code&gt;Html&lt;/code&gt; 语言，&lt;code&gt;Markdown&lt;/code&gt; 是一种面向 &lt;em&gt;书写&lt;/em&gt; 的语言，其目的就是让文档更容易写和读，让人们不再为 &lt;code&gt;Html&lt;/code&gt; 繁琐的标签烦恼。&lt;/p&gt;
&lt;p&gt;搭建个人博客最方便也最简易的方式就是采用 &lt;code&gt;WordPress&lt;/code&gt; 平台。但是，简易也意味着无脑、不能随行所欲地定制。我们只是需要一个写字的地方，显然 &lt;code&gt;WordPress&lt;/code&gt; 太臃肿，用来生成静态博客的 &lt;code&gt;Pelican&lt;/code&gt; 才是我们的最佳选择。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; 是一个共享虚拟主机服务，用于存放使用 &lt;code&gt;Git&lt;/code&gt; 版本控制的软件代码和内容项目。——by &lt;a href="http://zh.wikipedia.org/wiki/GitHub"&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我们只要采用 &lt;code&gt;Markdown&lt;/code&gt; 写下我们的博客内容，用 &lt;code&gt;Pelican&lt;/code&gt; 生成静态网页，然后将其托管到&lt;code&gt;GitHub&lt;/code&gt; 上，就大功告成了！&lt;/p&gt;
&lt;p&gt;折腾了几天，终于在 &lt;a href="https://www.google.com.hk"&gt;Google&lt;/a&gt; 和以下几篇博客的帮助下，初步搭建好了个人的小窝。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.lizherui.com/pages/2013/08/17/build_blog.html"&gt;一步一步打造Geek风格的技术博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.xycoding.com/articles/2013/11/21/blog-create/"&gt;使用Pelican和GitHub Pages搭建个人博客 —— 基础篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.dongxf.com/3_Build_Personal_Blog_With_Pelican_And_GitHub_Pages.html"&gt;用 Pelican 和 GitHub Pages 搭建免费的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://frantic1048.com/bo-ke-dan-sheng-ji-ji-yu-githubpelicanchuang-jian-bo-ke-de-zheng-ge-guo-cheng.html"&gt;博客诞生记:基于GitHub+Pelican创建博客的整个过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何搭建&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;本博客就是在参考以上 4篇博客的教程 + &lt;a href="https://www.google.com.hk"&gt;Google&lt;/a&gt; ，在 &lt;code&gt;Ubuntu 13.10&lt;/code&gt; 下完成的，十分感谢各位博主的分享。在搭建过程中遇到了不少问题，但是在万能的 Google 面前，都一切都不是问题，同时我也学习到了不少知识。&lt;/p&gt;
&lt;p&gt;详细的搭建过程参考以上4篇博客，不再赘述，下面总结一下自己安装过程中遇到的问题吧。&lt;/p&gt;
&lt;h3&gt;学习流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;学习 &lt;code&gt;Git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://gitref.org/"&gt;Git Refence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://git-scm.com/book"&gt;Pro Git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://help.github.com/"&gt;GitHub help&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装、学习使用 &lt;code&gt;Pelican&lt;/code&gt; 搭建博客骨架&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/getpelican/pelican"&gt;Pelican Source Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.getpelican.com/en/latest/"&gt;Pelican Doc&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习 &lt;code&gt;Markdown&lt;/code&gt; 语法，写博客内容&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wowubuntu.com/markdown/#hr"&gt;Markdown语法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sourceforge.net/projects/retext/"&gt;Markdown 编辑器 Retext&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pelican theme&lt;/code&gt; 修改&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.getpelican.com/en/latest/settings.html#themes"&gt;Pelican theme setting&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;问题总结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一种安装方式不成功时，可以试试其他方法。使用命令行安装 &lt;code&gt;Pelican&lt;/code&gt; 时，由于学校的渣网速，我安装了好几遍都 &lt;em&gt;time_out&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须先安装 &lt;code&gt;Pelican&lt;/code&gt;，后安装 &lt;code&gt;Markdown&lt;/code&gt;，否则在生成网页时会报错，不能识别 &lt;code&gt;.md&lt;/code&gt; 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;pelican-quickstart&lt;/code&gt; 时，有些选项是可以在 &lt;code&gt;pelicanconf.py&lt;/code&gt; 中修改的，有些不行 。比如是否启用文章分页，是不能通过后期修改的，如果第一次没有启用，在 pelicanconf.py 中直接修改会报错，只能保存好文章、下载的主题和配置文件，重新用向导生成博客框架 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于薄弱的 &lt;code&gt;Html&lt;/code&gt; 知识， &lt;code&gt;Pelican theme&lt;/code&gt; 的修改花费了很多时间 (Orz...)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;总之，既然搭建好了博客，就要坚持认真写下去，记录下生活中的每一点一滴。&lt;/p&gt;</summary><category term="Build Blog"></category></entry></feed>